import { isAddress, formatEther, encodeFunctionData, decodeEventLog, zeroAddress, zeroHash, maxUint256, toFunctionSelector, keccak256, encodeAbiParameters, toHex, stringToHex, erc20Abi as erc20Abi$1, maxUint32, createPublicClient, createWalletClient } from 'viem';
import * as dotenv from 'dotenv';
import { defineChain } from 'viem/utils';
import { CID } from 'multiformats/cid';
import bs58 from 'bs58';
import { base58btc } from 'multiformats/bases/base58';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return r;
  };
  var t,
    r = {},
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {},
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    return Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    });
  }
  try {
    c({}, "");
  } catch (t) {
    c = function (t, r, e) {
      return t[r] = e;
    };
  }
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            };
          }
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        }
      };
    }(r, n, new Context(o || [])), !0), a;
  }
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  r.wrap = h;
  var f = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var l = {};
  c(l, i, function () {
    return this;
  });
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      });
    });
  }
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == typeof f && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        }, function (t) {
          e("throw", t, a, u);
        }) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        }, function (t) {
          return e("throw", t, a, u);
        });
      }
      u(c.arg);
    }
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        });
      }
      return o = o ? o.then(i, i) : i();
    }, !0);
  }
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i.return && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  }
  function w(t) {
    this.tryEntries.push(t);
  }
  function m(r) {
    var e = r[4] || {};
    e.type = "normal", e.arg = t, r[4] = e;
  }
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  }
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          };
        return a.next = a;
      }
    }
    throw new TypeError(typeof r + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  }, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  }, r.awrap = function (t) {
    return {
      __await: t
    };
  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  }), c(v, "toString", function () {
    return "[object Generator]";
  }), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    };
  }, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function (r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      }
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        }
      }
    },
    abrupt: function (t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        }
      }
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {};
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    },
    complete: function (t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    },
    finish: function (t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      }
    },
    catch: function (t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      }, "next" === this.method && (this.arg = t), f;
    }
  }, r;
}

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var n = 0,
        F = function () {};
      return {
        s: F,
        n: function () {
          return n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[n++]
          };
        },
        e: function (r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function () {
      t = t.call(r);
    },
    n: function () {
      var r = t.next();
      return a = r.done, r;
    },
    e: function (r) {
      u = !0, o = r;
    },
    f: function () {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}

var aeneid = defineChain({
  id: 1315,
  name: "aeneid",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://aeneid.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://aeneid.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    }
  },
  testnet: true
});
var mainnet = defineChain({
  id: 1514,
  name: "mainnet",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://mainnet.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://dev-mainnet.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 340998
    }
  },
  testnet: false
});

function chainStringToViemChain(chainId) {
  switch (chainId.toString()) {
    case "1315":
    case "aeneid":
      return aeneid;
    case "1514":
    case "mainnet":
      return mainnet;
    default:
      throw new Error("ChainId ".concat(chainId, " not supported"));
  }
}
var chain = {
  aeneid: "1315",
  1315: "1315",
  1514: "1514",
  mainnet: "1514"
};
function validateAddress(address) {
  if (!isAddress(address, {
    strict: false
  })) {
    throw Error("Invalid address: ".concat(address, "."));
  }
  return address;
}
function validateAddresses(addresses) {
  return addresses.map(function (address) {
    return validateAddress(address);
  });
}
function getTokenAmountDisplay(amount) {
  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IP";
  return "".concat(formatEther(amount)).concat(unit);
}

function handleError(error, msg) {
  if (error instanceof Error) {
    var newError = new Error("".concat(msg, ": ").concat(error.message));
    newError.stack = error.stack;
    throw newError;
  }
  throw new Error("".concat(msg, ": Unknown error type"));
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}

// AccessController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var accessControllerAbi=[{type:"constructor",inputs:[{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"}],name:"AccessController__BothCallerAndRecipientAreNotRegisteredModule"},{type:"error",inputs:[],name:"AccessController__CallerIsNotIPAccountOrOwner"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessController__IPAccountIsNotValid"},{type:"error",inputs:[],name:"AccessController__IPAccountIsZeroAddress"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"}],name:"AccessController__OwnerIsIPAccount"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"AccessController__PermissionDenied"},{type:"error",inputs:[],name:"AccessController__PermissionIsNotValid"},{type:"error",inputs:[],name:"AccessController__SignerIsZeroAddress"},{type:"error",inputs:[],name:"AccessController__ToAndFuncAreZeroAddressShouldCallSetAllPermissions"},{type:"error",inputs:[],name:"AccessController__ZeroAccessManager"},{type:"error",inputs:[],name:"AccessController__ZeroIPAccountRegistry"},{type:"error",inputs:[],name:"AccessController__ZeroModuleRegistry"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"PermissionSet"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"TransientPermissionSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"checkPermission",outputs:[],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermanentPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getTransientPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setTransientPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var accessControllerAddress={1315:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a",1514:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a"};// ArbitrationPolicyUMA
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var arbitrationPolicyUmaAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__BondAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotCancel"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotDisputeAssertionIfTagIsInherited"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CurrencyNotWhitelisted"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__DisputeNotFound"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__IpOwnerTimePercentAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessBelowMin"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MaxBondBelowMinimumBond"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MinLivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NoCounterEvidence"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__OnlyDisputePolicyUMA"},{type:"error",inputs:[{name:"elapsedTime",internalType:"uint64",type:"uint64"},{name:"liveness",internalType:"uint64",type:"uint64"},{name:"caller",internalType:"address",type:"address"}],name:"ArbitrationPolicyUMA__OnlyTargetIpIdCanDisputeWithinTimeWindow"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroAccessManager"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMaxLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMinLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroRoyaltyModule"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"assertionId",internalType:"bytes32",type:"bytes32",indexed:false},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"AssertionDisputed"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"assertionId",internalType:"bytes32",type:"bytes32",indexed:false},{name:"caller",internalType:"address",type:"address",indexed:false},{name:"liveness",internalType:"uint64",type:"uint64",indexed:false},{name:"currency",internalType:"address",type:"address",indexed:false},{name:"bond",internalType:"uint256",type:"uint256",indexed:false}],name:"DisputeRaisedUMA"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"maxLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32",indexed:false}],name:"LivenessSet"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"maxBond",internalType:"uint256",type:"uint256",indexed:false}],name:"MaxBondSet"},{type:"event",anonymous:false,inputs:[{name:"oov3",internalType:"address",type:"address",indexed:false}],name:"OOV3Set"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionDisputedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionIdToDisputeId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"assertedTruthfully",internalType:"bool",type:"bool"}],name:"assertionResolvedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32"}],name:"disputeAssertion",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputeIdToAssertionId",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipOwnerTimePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"ipOwnerTimePercents",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"maxBonds",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[],name:"minLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeCancel",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onRaiseDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onResolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"oov3",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64"},{name:"maxLiveness",internalType:"uint64",type:"uint64"},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32"}],name:"setLiveness",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"maxBond",internalType:"uint256",type:"uint256"}],name:"setMaxBond",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"oov3",internalType:"address",type:"address"}],name:"setOOV3",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var arbitrationPolicyUmaAddress={1315:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936",1514:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936"};// CoreMetadataModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var coreMetadataModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"CoreMetadataModule__MetadataAlreadyFrozen"},{type:"error",inputs:[],name:"CoreMetadataModule__ZeroAccessManager"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true}],name:"MetadataFrozen"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"metadataURI",internalType:"string",type:"string",indexed:false},{name:"metadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"MetadataURISet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"nftTokenURI",internalType:"string",type:"string",indexed:false},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"NFTTokenURISet"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"freezeMetadata",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isMetadataFrozen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"setAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"}],name:"setMetadataURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"updateNftTokenURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var coreMetadataModuleAddress={1315:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16",1514:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16"};// DerivativeWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var derivativeWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerAndNotTokenOwner"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"DerivativeWorkflows__EmptyLicenseTokens"},{type:"error",inputs:[],name:"DerivativeWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicensingHelper__ParentIpIdsAndLicenseTermsIdsMismatch"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var derivativeWorkflowsAddress={1315:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f",1514:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f"};// DisputeModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var disputeModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"DisputeModule__CannotBlacklistBaseArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__DisputeAlreadyPropagated"},{type:"error",inputs:[],name:"DisputeModule__DisputeWithoutInfringementTag"},{type:"error",inputs:[],name:"DisputeModule__EvidenceHashAlreadyUsed"},{type:"error",inputs:[],name:"DisputeModule__NotAbleToResolve"},{type:"error",inputs:[],name:"DisputeModule__NotAllowedToWhitelist"},{type:"error",inputs:[],name:"DisputeModule__NotArbitrationRelayer"},{type:"error",inputs:[],name:"DisputeModule__NotDerivativeOrGroupIp"},{type:"error",inputs:[],name:"DisputeModule__NotDisputeInitiator"},{type:"error",inputs:[],name:"DisputeModule__NotInDisputeState"},{type:"error",inputs:[],name:"DisputeModule__NotRegisteredIpId"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__RelatedDisputeNotResolved"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessController"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessManager"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicyCooldown"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeEvidenceHash"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPAssetRegistry"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"DisputeModule__ZeroLicenseRegistry"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"cooldown",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicyCooldownUpdated"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"nextArbitrationUpdateTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicySet"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"ArbitrationPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"arbitrationRelayer",internalType:"address",type:"address",indexed:false}],name:"ArbitrationRelayerUpdated"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false}],name:"DefaultArbitrationPolicyUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeCancelled"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"decision",internalType:"bool",type:"bool",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeJudgementSet"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"targetIpId",internalType:"address",type:"address",indexed:false},{name:"disputeInitiator",internalType:"address",type:"address",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false},{name:"targetTag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeRaised"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeResolved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"infringingIpId",internalType:"address",type:"address",indexed:false},{name:"ipIdToTag",internalType:"address",type:"address",indexed:false},{name:"infringerDisputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"IpTaggedOnRelatedIpInfringement"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"TagWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IN_DISPUTE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"arbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"arbitrationPolicyCooldown",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"arbitrationRelayer",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseArbitrationPolicy",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"cancelDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"disputeCounter",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputes",outputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeInitiator",internalType:"address",type:"address"},{name:"disputeTimestamp",internalType:"uint256",type:"uint256"},{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"currentTag",internalType:"bytes32",type:"bytes32"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isIpTagged",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"isWhitelistedArbitrationPolicy",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"}],name:"isWhitelistedDisputeTag",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationUpdateTimestamps",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"data",internalType:"bytes",type:"bytes"}],name:"raiseDispute",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"resolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nextArbitrationPolicy",internalType:"address",type:"address"}],name:"setArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"cooldown",internalType:"uint256",type:"uint256"}],name:"setArbitrationPolicyCooldown",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"arbPolicyRelayer",internalType:"address",type:"address"}],name:"setArbitrationRelayer",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"setBaseArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"setDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipIdToTag",internalType:"address",type:"address"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],name:"tagIfRelatedIpInfringed",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"updateActiveArbitrationPolicy",outputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistDisputeTag",outputs:[],stateMutability:"nonpayable"}];/**

*/var disputeModuleAddress={1315:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5",1514:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5"};// ERC20
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var erc20Abi=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"allowance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientAllowance"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"balance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientBalance"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC20InvalidApprover"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC20InvalidSender"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"account",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"}];/**

*/var erc20Address={1315:"0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E",1514:"0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E"};// GroupingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var groupingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"groupNFT",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddDisputedIpToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"childGroupId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddGroupToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotAddIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotClaimReward"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotCollectRoyalties"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToAlreadyMintLicenseTokens"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToHasDerivativeIps"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPLicenseHasNotSpecifyRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"GroupingModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[{name:"groupNFT",internalType:"address",type:"address"}],name:"GroupingModule__InvalidGroupNFT"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__IpExpectedShareExceedsMaxAllowedShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__MaxAllowedRewardShareExceeds100Percent"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"royaltyToken",internalType:"address",type:"address"}],name:"GroupingModule__RoyaltyTokenNotWhitelisted"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupCurrentToken",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"GroupingModule__TokenNotMatchGroupRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"totalGroupRewardShare",internalType:"uint256",type:"uint256"},{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__TotalGroupRewardShareExceeds100Percent"},{type:"error",inputs:[],name:"GroupingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupNFT"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupRewardPool"},{type:"error",inputs:[],name:"GroupingModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"GroupingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"AddedIpToGroup"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address[]",type:"address[]",indexed:false},{name:"amount",internalType:"uint256[]",type:"uint256[]",indexed:false}],name:"ClaimedReward"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"pool",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"CollectedRoyaltiesToGroupPool"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"groupPool",internalType:"address",type:"address",indexed:true}],name:"IPGroupRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"RemovedIpFromGroup"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract IGroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"addIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"claimReward",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"collectRoyalties",outputs:[{name:"royalties",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"getClaimableReward",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**

*/var groupingModuleAddress={1315:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac",1514:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac"};// GroupingWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var groupingWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"groupNft",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"GroupingWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"GroupingWorkflows__NoLicenseData"},{type:"error",inputs:[],name:"GroupingWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract GroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"currencyTokens",internalType:"address[]",type:"address[]"},{name:"memberIpIds",internalType:"address[]",type:"address[]"}],name:"collectRoyaltiesAndClaimReward",outputs:[{name:"collectedRoyalties",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicense",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicenseAndAddIps",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var groupingWorkflowsAddress={1315:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd",1514:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd"};// IPAccountImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipAccountImplAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"FnSelectorNotRecognized"},{type:"error",inputs:[],name:"IPAccountStorage__InvalidBatchLengths"},{type:"error",inputs:[{name:"module",internalType:"address",type:"address"}],name:"IPAccountStorage__NotRegisteredModule"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroModuleRegistry"},{type:"error",inputs:[],name:"IPAccount__ExpiredSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidCalldata"},{type:"error",inputs:[],name:"IPAccount__InvalidOperation"},{type:"error",inputs:[],name:"IPAccount__InvalidSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidSigner"},{type:"error",inputs:[],name:"IPAccount__UUPSUpgradeDisabled"},{type:"error",inputs:[],name:"IPAccount__ZeroAccessController"},{type:"error",inputs:[],name:"OperationNotSupported"},{type:"error",inputs:[],name:"SelfOwnDetected"},{type:"error",inputs:[],name:"Unauthorized"},{type:"error",inputs:[],name:"UnauthorizedCallContext"},{type:"error",inputs:[],name:"UpgradeFailed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false}],name:"Executed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false},{name:"deadline",internalType:"uint256",type:"uint256",indexed:false},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"signature",internalType:"bytes",type:"bytes",indexed:false}],name:"ExecutedWithSig"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"fallback",stateMutability:"payable"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytes32Data",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytesData",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[],name:"eip712Domain",outputs:[{name:"fields",internalType:"bytes1",type:"bytes1"},{name:"name",internalType:"string",type:"string"},{name:"version",internalType:"string",type:"string"},{name:"chainId",internalType:"uint256",type:"uint256"},{name:"verifyingContract",internalType:"address",type:"address"},{name:"salt",internalType:"bytes32",type:"bytes32"},{name:"extensions",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"operation",internalType:"uint8",type:"uint8"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct ERC6551.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}]},{name:"operation",internalType:"uint8",type:"uint8"}],name:"executeBatch",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"executeWithSig",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytes32Batch",outputs:[{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytesBatch",outputs:[{name:"values",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"hash",internalType:"bytes32",type:"bytes32"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"isValidSignature",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"owner",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes",type:"bytes"}],name:"setBytes",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes32",type:"bytes32"}],name:"setBytes32",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],name:"setBytes32Batch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes[]",type:"bytes[]"}],name:"setBytesBatch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"state",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"token",outputs:[{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"receive",stateMutability:"payable"}];/**

*/var ipAccountImplAddress={1315:"0x7343646585443F1c3F64E4F08b708788527e1C77",1514:"0x7343646585443F1c3F64E4F08b708788527e1C77"};// IPAssetRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipAssetRegistryAbi=[{type:"constructor",inputs:[{name:"erc6551Registry",internalType:"address",type:"address"},{name:"ipAccountImpl",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"ipAccountImplBeacon",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__CallerIsNotGroupingModule"},{type:"error",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__GroupRewardPoolNotRegistered"},{type:"error",inputs:[{name:"groupSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__GroupSizeExceedsLimit"},{type:"error",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__InvalidGroupRewardPool"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredGroupIP"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredIP"},{type:"error",inputs:[{name:"pageSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__PageSizeExceedsLimit"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroERC6551Registry"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImpl"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImplBeacon"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"IPAssetRegistry__InvalidToken"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721Metadata"},{type:"error",inputs:[],name:"IPAssetRegistry__ZeroAccessManager"},{type:"error",inputs:[{name:"name",internalType:"string",type:"string"}],name:"IPAssetRegistry__ZeroAddress"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:true},{name:"implementation",internalType:"address",type:"address",indexed:true},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:false},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"IPAccountRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true},{name:"name",internalType:"string",type:"string",indexed:false},{name:"uri",internalType:"string",type:"string",indexed:false},{name:"registrationDate",internalType:"uint256",type:"uint256",indexed:false}],name:"IPRegistered"},{type:"event",anonymous:false,inputs:[{name:"payer",internalType:"address",type:"address",indexed:true},{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint96",type:"uint96",indexed:false}],name:"IPRegistrationFeePaid"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"feeAmount",internalType:"uint96",type:"uint96",indexed:false}],name:"RegistrationFeeSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ERC6551_PUBLIC_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL_UPGRADEABLE_BEACON",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_SALT",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_GROUP_SIZE",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"addGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"}],name:"containsIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeAmount",outputs:[{name:"",internalType:"uint96",type:"uint96"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"startIndex",internalType:"uint256",type:"uint256"},{name:"size",internalType:"uint256",type:"uint256"}],name:"getGroupMembers",outputs:[{name:"results",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"getGroupRewardPool",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getIPAccountImpl",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getTreasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipAccount",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"isRegisteredGroup",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"isWhitelistedGroupRewardPool",outputs:[{name:"isWhitelisted",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainid",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"register",outputs:[{name:"id",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupNft",internalType:"address",type:"address"},{name:"groupNftId",internalType:"uint256",type:"uint256"},{name:"rewardPool",internalType:"address",type:"address"},{name:"registerFeePayer",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"},{name:"feeToken",internalType:"address",type:"address"},{name:"feeAmount",internalType:"uint96",type:"uint96"}],name:"setRegistrationFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"totalMembers",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newIpAccountImpl",internalType:"address",type:"address"}],name:"upgradeIPAccountImpl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**

*/var ipAssetRegistryAddress={1315:"0x77319B4031e6eF1250907aa00018B8B1c67a244b",1514:"0x77319B4031e6eF1250907aa00018B8B1c67a244b"};// IpRoyaltyVaultImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var ipRoyaltyVaultImplAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"allowance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientAllowance"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"balance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientBalance"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC20InvalidApprover"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC20InvalidSender"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"IpRoyaltyVault__EnforcedPause"},{type:"error",inputs:[],name:"IpRoyaltyVault__GroupPoolMustClaimViaGroupingModule"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"IpRoyaltyVault__InsufficientBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__InvalidTargetIpId"},{type:"error",inputs:[],name:"IpRoyaltyVault__NegativeValueUnsafeCastingToUint256"},{type:"error",inputs:[],name:"IpRoyaltyVault__NoClaimableTokens"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotAllowedToAddTokenToVault"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"from",internalType:"address",type:"address"}],name:"IpRoyaltyVault__SameFromToAddress"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultDoesNotBelongToAnAncestor"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultsMustClaimAsSelf"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroAmount"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"}],name:"IpRoyaltyVault__ZeroBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroDisputeModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroGroupingModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"revenueDebt",internalType:"int256",type:"int256",indexed:false}],name:"RevenueDebtUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenAddedToVault"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenClaimed"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"account",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenList",internalType:"address[]",type:"address[]"},{name:"targetIpId",internalType:"address",type:"address"}],name:"claimByTokenBatchAsSelf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimRevenueOnBehalf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"tokenList",internalType:"address[]",type:"address[]"}],name:"claimRevenueOnBehalfByTokenBatch",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimableRevenue",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimerRevenueDebt",outputs:[{name:"",internalType:"int256",type:"int256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"pure"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"supply",internalType:"uint32",type:"uint32"},{name:"ipIdAddress",internalType:"address",type:"address"},{name:"rtReceiver",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"tokens",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"updateVaultBalance",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"vaultAccBalances",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"}];/**

*/var ipRoyaltyVaultImplAddress={1315:"0x73e2D097F71e5103824abB6562362106A8955AEc",1514:"0x63cC7611316880213f3A4Ba9bD72b0EaA2010298"};// LicenseAttachmentWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseAttachmentWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"LicenseAttachmentWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndDefaultTerms",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerPILTermsAndAttach",outputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var licenseAttachmentWorkflowsAddress={1315:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8",1514:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8"};// LicenseRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseRegistryAbi=[{type:"constructor",inputs:[{name:"groupIpAssetRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"}],name:"LicenseRegistry__AddParentIpToIPGraphFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallerNotLicensingModule"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__CannotAddIpWithExpirationToGroup"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeAlreadyRegistered"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasChild"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasLicense"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIsParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DuplicateParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__EmptyGroupCannotMintLicenseToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupCannotHasParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupIpAlreadyHasLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipCommercialRevShare",internalType:"uint32",type:"uint32"},{name:"groupCommercialRevShare",internalType:"uint32",type:"uint32"}],name:"LicenseRegistry__GroupIpCommercialRevShareConfigMustNotLessThanIp"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupMustBeSoleParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IndexOutOfBounds"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardPool",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotMatch"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotSet"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpired"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpHasNoGroupLicenseTerms"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpLicenseDisabled"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"groupHookData",internalType:"bytes",type:"bytes"}],name:"LicenseRegistry__IpLicensingHookDataNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensingHook",internalType:"address",type:"address"},{name:"groupLicensingHook",internalType:"address",type:"address"}],name:"LicenseRegistry__IpLicensingHookNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"groupMintingFee",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpMintingFeeNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsAlreadyAttached"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsCannotAttachToGroupIp"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsNotExists"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicensorIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__NotLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpExpired"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__ParentIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpIsEmptyGroup"},{type:"error",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpNotRegistered"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpTagged"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpUnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyAncestors"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parents",internalType:"uint256",type:"uint256"},{name:"maxParents",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyParents"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroGroupIpRegistry"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicensingModule"},{type:"error",inputs:[],name:"LicensingModule__DerivativesCannotAddLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsNotFound"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"DefaultLicenseTermsSet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"expireTime",internalType:"uint256",type:"uint256",indexed:false}],name:"ExpirationTimeSet"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:true}],name:"LicenseTemplateRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}],indexed:false}],name:"LicensingConfigSetForLicense"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"EXPIRATION_TIME",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_ANCESTORS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PARENTS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTermsToIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAncestorsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getAttachedLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAttachedLicenseTermsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getDefaultLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getDerivativeIp",outputs:[{name:"childIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"getDerivativeIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicensingConfig",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getParentIp",outputs:[{name:"parentIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"getParentIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"getParentLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPercent",outputs:[{name:"royaltyPercent",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"hasDerivativeIps",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"hasIpAttachedLicenseTerms",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"}],name:"initializeLicenseTemplate",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isDefaultLicense",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isExpiredNow",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"}],name:"isParentIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"isRegisteredLicenseTemplate",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"isUsingLicenseToken",internalType:"bool",type:"bool"}],name:"registerDerivativeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"registerLicenseTemplate",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newLicenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"setDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfigForLicense",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"groupLicenseTemplate",internalType:"address",type:"address"},{name:"groupLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"verifyGroupAddIp",outputs:[{name:"ipLicensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"isMintedByIpOwner",internalType:"bool",type:"bool"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"}];/**

*/var licenseRegistryAddress={1315:"0x529a750E02d8E2f15649c13D69a465286a780e24",1514:"0x529a750E02d8E2f15649c13D69a465286a780e24"};// LicenseToken
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licenseTokenAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"ERC721EnumerableForbiddenBatchMint"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"ERC721OutOfBoundsIndex"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"anotherLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"childIpIp",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"LicenseToken__CallerAndChildIPNotTokenOwner"},{type:"error",inputs:[],name:"LicenseToken__CallerNotLicensingModule"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseToken__ChildIPAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[{name:"commercialRevenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__CommercialRevenueShareExceedMaxRevenueShare"},{type:"error",inputs:[{name:"invalidRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__InvalidRoyaltyPercent"},{type:"error",inputs:[],name:"LicenseToken__NotTransferable"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__RevokedLicense"},{type:"error",inputs:[],name:"LicenseToken__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minter",internalType:"address",type:"address",indexed:true},{name:"receiver",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"LicenseTokenMinted"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_COMMERCIAL_REVENUE_SHARE",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"holder",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"burnLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTemplate",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTokenMetadata",outputs:[{name:"",internalType:"struct ILicenseToken.LicenseTokenMetadata",type:"tuple",components:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"transferable",internalType:"bool",type:"bool"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicensorIpId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"}],name:"getTotalTokensByLicensor",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"imageUrl",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"isLicenseTokenRevoked",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"minter",internalType:"address",type:"address"},{name:"receiver",internalType:"address",type:"address"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"url",internalType:"string",type:"string"}],name:"setLicensingImageUrl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalMintedTokens",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"validateLicenseTokensForDerivative",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licensorIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"commercialRevShares",internalType:"uint32[]",type:"uint32[]"}],stateMutability:"view"}];/**

*/var licenseTokenAddress={1315:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC",1514:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC"};// LicensingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var licensingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicenseRegistry__LicenseTemplateCannotBeZeroAddress"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__CurrentLicenseNotAllowOverrideRoyaltyPercent"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__DerivativeAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[],name:"LicensingModule__DisputedIpId"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"revenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"LicensingModule__ExceedMaxRevenueShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeHookData"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeIsSet"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeLicensingHook"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeMintingFee"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"oldRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__GroupIpCannotDecreaseRoyalty"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotSetExpectGroupRewardPool"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__InvalidLicenseTermsId"},{type:"error",inputs:[{name:"hook",internalType:"address",type:"address"}],name:"LicensingModule__InvalidLicensingHook"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensorIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseDenyMintLicenseToken"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseDisabled"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseNotCompatibleForDerivative"},{type:"error",inputs:[{name:"ipLength",internalType:"uint256",type:"uint256"},{name:"licenseTermsLength",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsLengthMismatch"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"LicensingModule__LicenseTokenNotCompatibleForDerivative"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfigMintingFee",internalType:"uint256",type:"uint256"},{name:"licenseTermsMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicensingConfigMintingFeeBelowLicenseTerms"},{type:"error",inputs:[{name:"licensingHookMintingFee",internalType:"uint256",type:"uint256"},{name:"licenseTermsMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicensingHookMintingFeeBelowLicenseTerms"},{type:"error",inputs:[],name:"LicensingModule__LicensorIpNotRegistered"},{type:"error",inputs:[],name:"LicensingModule__MintAmountZero"},{type:"error",inputs:[{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__MintingFeeExceedMaxMintingFee"},{type:"error",inputs:[],name:"LicensingModule__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"LicensingModule__NoLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__NoParentIp"},{type:"error",inputs:[],name:"LicensingModule__ReceiverZeroAddress"},{type:"error",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"anotherRoyaltyPolicy",internalType:"address",type:"address"}],name:"LicensingModule__RoyaltyPolicyMismatch"},{type:"error",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicensingModule__TooManyAncestorsForMintingLicenseTokenAllowRegisterDerivative"},{type:"error",inputs:[],name:"LicensingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"LicensingModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicensingModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__ZeroModuleRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"childIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false}],name:"DerivativeRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTermsAttached"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"licensorIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"receiver",internalType:"address",type:"address",indexed:false},{name:"startLicenseTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTokensMinted"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_NFT",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"attachDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"}],name:"predictMintingLicenseFee",outputs:[{name:"currencyToken",internalType:"address",type:"address"},{name:"tokenAmount",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"registerDerivative",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"registerDerivativeWithLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfig",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var licensingModuleAddress={1315:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f",1514:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f"};// ModuleRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var moduleRegistryAbi=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"ModuleRegistry__InterfaceIdZero"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressNotContract"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressZeroAddress"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameDoesNotMatch"},{type:"error",inputs:[],name:"ModuleRegistry__NameEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true},{name:"moduleTypeInterfaceId",internalType:"bytes4",type:"bytes4",indexed:true},{name:"moduleType",internalType:"string",type:"string",indexed:false}],name:"ModuleAdded"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true}],name:"ModuleRemoved"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"getModule",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"getModuleType",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleType",internalType:"string",type:"string"}],name:"getModuleTypeInterfaceId",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"},{name:"moduleType",internalType:"string",type:"string"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"registerModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var moduleRegistryAddress={1315:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5",1514:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5"};// Multicall3
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var multicall3Abi=[{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"returnData",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3Value[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"value",internalType:"uint256",type:"uint256"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3Value",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"blockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[],name:"getBasefee",outputs:[{name:"basefee",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],name:"getBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"getBlockNumber",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getChainId",outputs:[{name:"chainid",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockCoinbase",outputs:[{name:"coinbase",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockDifficulty",outputs:[{name:"difficulty",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockGasLimit",outputs:[{name:"gaslimit",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockTimestamp",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"addr",internalType:"address",type:"address"}],name:"getEthBalance",outputs:[{name:"balance",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getLastBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryAggregate",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryBlockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"}];/**

*/var multicall3Address={1315:"0xcA11bde05977b3631167028862bE2a173976CA11",1514:"0xcA11bde05977b3631167028862bE2a173976CA11"};// PILicenseTemplate
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var piLicenseTemplateAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddCommercializers"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevShare"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialEnabled_RoyaltyPolicyRequired"},{type:"error",inputs:[{name:"checker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerDoesNotSupportHook"},{type:"error",inputs:[{name:"commercializerChecker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerNotRegistered"},{type:"error",inputs:[],name:"PILicenseTemplate__CurrencyTokenNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddApproval"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddReciprocal"},{type:"error",inputs:[],name:"PILicenseTemplate__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyRequiresCurrencyToken"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroAccessManager"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"caller",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"DerivativeApproved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTerms",internalType:"bytes",type:"bytes",indexed:false}],name:"LicenseTermsRegistered"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"TERMS_RENDERER",outputs:[{name:"",internalType:"contract PILTermsRenderer",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"allowDerivativeRegistration",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"canAttachToGroupIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"canOverrideRoyaltyPercent",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getEarlierExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTerms",outputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"getLicenseTermsId",outputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"getMetadataURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPolicy",outputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"royaltyPercent",internalType:"uint32",type:"uint32"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"name",internalType:"string",type:"string"},{name:"metadataURI",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeApproved",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isLicenseTransferable",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"registerLicenseTerms",outputs:[{name:"id",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApproval",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"toJson",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalRegisteredLicenseTerms",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],name:"verifyCompatibleLicenses",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"},{name:"licensorIpId",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"}],name:"verifyRegisterDerivative",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"caller",internalType:"address",type:"address"}],name:"verifyRegisterDerivativeForAllParents",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"}];/**

*/var piLicenseTemplateAddress={1315:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316",1514:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316"};// RegistrationWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var registrationWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RegistrationWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RegistrationWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"spgNftContract",internalType:"address",type:"address",indexed:true}],name:"CollectionCreated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftInitParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"createCollection",outputs:[{name:"spgNftContract",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIp",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIp",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContractBeacon",internalType:"address",type:"address"}],name:"setNftContractBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContract",internalType:"address",type:"address"}],name:"upgradeCollections",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var registrationWorkflowsAddress={1315:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424",1514:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424"};// RoyaltyModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyModuleAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"RoyaltyModule__AboveAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxPercent"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxRts"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"rewardPool",internalType:"address",type:"address"}],name:"RoyaltyModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[],name:"RoyaltyModule__InvalidExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__IpExpired"},{type:"error",inputs:[],name:"RoyaltyModule__IpIsTagged"},{type:"error",inputs:[],name:"RoyaltyModule__NoParentsOnLinking"},{type:"error",inputs:[],name:"RoyaltyModule__NotAllowedCaller"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedOrRegisteredRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__PaymentAmountIsTooLow"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyRegisteredAsExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyWhitelistedOrRegistered"},{type:"error",inputs:[],name:"RoyaltyModule__UnlinkableToParents"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccessManager"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAmount"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpGraphAcl"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicensingModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroParentIpId"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroReceiverVault"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroTreasury"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"VaultController__ZeroIpRoyaltyVaultBeacon"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address",indexed:false}],name:"ExternalRoyaltyPolicyRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"ipRoyaltyVault",internalType:"address",type:"address",indexed:false}],name:"IpRoyaltyVaultDeployed"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerAddress",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseMintingFeePaid"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"licensePercent",internalType:"uint32",type:"uint32",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LicensedWithRoyalty"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]",indexed:false},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LinkedToParents"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"royaltyFeePercent",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyFeePercentSet"},{type:"event",anonymous:false,inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyLimitsUpdated"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerIpId",internalType:"address",type:"address",indexed:false},{name:"sender",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyPaid"},{type:"event",anonymous:false,inputs:[{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyTokenWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:false}],name:"TreasurySet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PERCENT",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"accumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"globalRoyaltyStack",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"}],name:"hasAncestorIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipRoyaltyVaultBeacon",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"ipRoyaltyVaults",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipRoyaltyVault",internalType:"address",type:"address"}],name:"isIpRoyaltyVault",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"isRegisteredExternalRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAccumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAncestors",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxParents",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxPercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"pure"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"},{name:"externalData",internalType:"bytes",type:"bytes"}],name:"onLicenseMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]"},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]"},{name:"externalData",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"onLinkToParents",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerAddress",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payLicenseMintingFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payRoyaltyOnBehalf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"registerExternalRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"royaltyFeePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"beacon",internalType:"address",type:"address"}],name:"setIpRoyaltyVaultBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyFeePercent",internalType:"uint32",type:"uint32"}],name:"setRoyaltyFeePercent",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"setRoyaltyLimits",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"}],name:"setTreasury",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"totalRevenueTokensAccounted",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"totalRevenueTokensReceived",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"treasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"newVault",internalType:"address",type:"address"}],name:"upgradeVaults",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyToken",outputs:[],stateMutability:"nonpayable"}];/**

*/var royaltyModuleAddress={1315:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086",1514:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086"};/**

*/var royaltyPolicyLapAddress={1315:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E",1514:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E"};// RoyaltyPolicyLRP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyPolicyLrpAbi=[{type:"constructor",inputs:[{name:"royaltyModule",internalType:"address",type:"address"},{name:"royaltyPolicyLAP",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__AboveMaxPercent"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__CallFailed"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__NotRoyaltyModule"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__SameIpTransfer"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroAccessManager"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroClaimableRoyalty"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroIPGraphACL"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroRoyaltyPolicyLAP"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"ancestorIpId",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTransferredToVault"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_POLICY_LAP",outputs:[{name:"",internalType:"contract IGraphAwareRoyaltyPolicy",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"}],name:"getPolicyRoyalty",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getPolicyRoyaltyStack",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"}],name:"getPolicyRtsRequiredToLink",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"getTransferredTokens",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"isSupportGroup",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"},{name:"",internalType:"bytes",type:"bytes"}],name:"onLicenseMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]"},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]"},{name:"",internalType:"bytes",type:"bytes"}],name:"onLinkToParents",outputs:[{name:"newRoyaltyStackLRP",internalType:"uint32",type:"uint32"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"transferToVault",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var royaltyPolicyLrpAddress={1315:"0x9156e603C949481883B1d3355c6f1132D191fC41",1514:"0x9156e603C949481883B1d3355c6f1132D191fC41"};// RoyaltyTokenDistributionWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyTokenDistributionWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"royaltyPolicyLRP",internalType:"address",type:"address"},{name:"wip",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicensingHelper__ParentIpIdsAndLicenseTermsIdsMismatch"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RoyaltyTokenDistributionWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__RoyaltyVaultNotDeployed"},{type:"error",inputs:[{name:"totalShares",internalType:"uint32",type:"uint32"},{name:"ipAccountBalance",internalType:"uint32",type:"uint32"}],name:"RoyaltyTokenDistributionWorkflows__TotalSharesExceedsIPAccountBalance"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_POLICY_LRP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"WIP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"sigApproveRoyaltyTokens",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"distributeRoyaltyTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var royaltyTokenDistributionWorkflowsAddress={1315:"0xa38f42B8d33809917f23997B8423054aAB97322C",1514:"0xa38f42B8d33809917f23997B8423054aAB97322C"};// RoyaltyWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var royaltyWorkflowsAbi=[{type:"constructor",inputs:[{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ancestorIpId",internalType:"address",type:"address"},{name:"claimer",internalType:"address",type:"address"},{name:"childIpIds",internalType:"address[]",type:"address[]"},{name:"royaltyPolicies",internalType:"address[]",type:"address[]"},{name:"currencyTokens",internalType:"address[]",type:"address[]"}],name:"claimAllRevenue",outputs:[{name:"amountsClaimed",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**

*/var royaltyWorkflowsAddress={1315:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890",1514:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890"};// SPGNFTImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var spgnftImplAbi=[{type:"constructor",inputs:[{name:"derivativeWorkflows",internalType:"address",type:"address"},{name:"groupingWorkflows",internalType:"address",type:"address"},{name:"licenseAttachmentWorkflows",internalType:"address",type:"address"},{name:"registrationWorkflows",internalType:"address",type:"address"},{name:"royaltyTokenDistributionWorkflows",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"AccessControlBadConfirmation"},{type:"error",inputs:[{name:"account",internalType:"address",type:"address"},{name:"neededRole",internalType:"bytes32",type:"bytes32"}],name:"AccessControlUnauthorizedAccount"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"SPGNFT__CallerNotFeeRecipientOrAdmin"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"}],name:"SPGNFT__CallerNotOwner"},{type:"error",inputs:[],name:"SPGNFT__CallerNotPeripheryContract"},{type:"error",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"SPGNFT__DuplicatedNFTMetadataHash"},{type:"error",inputs:[],name:"SPGNFT__MaxSupplyReached"},{type:"error",inputs:[],name:"SPGNFT__MintingClosed"},{type:"error",inputs:[],name:"SPGNFT__MintingDenied"},{type:"error",inputs:[],name:"SPGNFT__ZeroAddressParam"},{type:"error",inputs:[],name:"SPGNFT__ZeroMaxSupply"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[],name:"ContractURIUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"_tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"MetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"previousAdminRole",internalType:"bytes32",type:"bytes32",indexed:true},{name:"newAdminRole",internalType:"bytes32",type:"bytes32",indexed:true}],name:"RoleAdminChanged"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleGranted"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleRevoked"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"function",inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"DERIVATIVE_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_ATTACHMENT_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"REGISTRATION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_TOKEN_DISTRIBUTION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"contractURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"}],name:"getRoleAdmin",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"getTokenIdByMetadataHash",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"hasRole",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"initParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mint",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"payer",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintByPeriphery",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"mintFee",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeRecipient",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintOpen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"publicMinting",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"callerConfirmation",internalType:"address",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"baseURI",internalType:"string",type:"string"}],name:"setBaseURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"contractURI",internalType:"string",type:"string"}],name:"setContractURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"fee",internalType:"uint256",type:"uint256"}],name:"setMintFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newFeeRecipient",internalType:"address",type:"address"}],name:"setMintFeeRecipient",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"setMintFeeToken",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"mintOpen",internalType:"bool",type:"bool"}],name:"setMintOpen",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"isPublicMinting",internalType:"bool",type:"bool"}],name:"setPublicMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"tokenUri",internalType:"string",type:"string"}],name:"setTokenURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"withdrawToken",outputs:[],stateMutability:"nonpayable"}];/**

*/var spgnftImplAddress={1315:"0x5266215a00c31AaA2f2BB7b951Ea0028Ea8b4e37",1514:"0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5"};// WrappedIP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**

*/var wrappedIpAbi=[{type:"error",inputs:[],name:"AllowanceOverflow"},{type:"error",inputs:[],name:"AllowanceUnderflow"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"IPTransferFailed"},{type:"error",inputs:[],name:"InsufficientAllowance"},{type:"error",inputs:[],name:"InsufficientBalance"},{type:"error",inputs:[],name:"InvalidPermit"},{type:"error",inputs:[],name:"Permit2AllowanceIsFixedAtInfinity"},{type:"error",inputs:[],name:"PermitExpired"},{type:"error",inputs:[],name:"TotalSupplyOverflow"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Deposit"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Withdrawal"},{type:"function",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[],name:"deposit",outputs:[],stateMutability:"payable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"nonces",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"v",internalType:"uint8",type:"uint8"},{name:"r",internalType:"bytes32",type:"bytes32"},{name:"s",internalType:"bytes32",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"value",internalType:"uint256",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable"},{type:"receive",stateMutability:"payable"}];/**

*/var wrappedIpAddress={1315:"0x1514000000000000000000000000000000000000",1514:"0x1514000000000000000000000000000000000000"};// SDK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMON =============================================================
function getAddress(address,chainId){return address[chainId||0]||"0x";}// Contract AccessController =============================================================
/**
 * AccessControllerPermissionSetEvent
 *
 * @param ipAccountOwner address
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 *//**
 * AccessControllerSetAllPermissionsRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param permission uint8
 *//**
 * AccessControllerSetBatchPermissionsRequest
 *
 * @param permissions tuple[]
 *//**
 * AccessControllerSetPermissionRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 *//**
 * contract AccessController event
 */var AccessControllerEventClient=/*#__PURE__*/function(){function AccessControllerEventClient(rpcClient,address){var _rpcClient$chain;_classCallCheck(this,AccessControllerEventClient);this.address=address||getAddress(accessControllerAddress,(_rpcClient$chain=rpcClient.chain)===null||_rpcClient$chain===void 0?void 0:_rpcClient$chain.id);this.rpcClient=rpcClient;}/**
   * event PermissionSet for contract AccessController
   */return _createClass(AccessControllerEventClient,[{key:"watchPermissionSetEvent",value:function watchPermissionSetEvent(_onLogs){return this.rpcClient.watchContractEvent({abi:accessControllerAbi,address:this.address,eventName:"PermissionSet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event PermissionSet for contract AccessController
   */},{key:"parseTxPermissionSetEvent",value:function parseTxPermissionSetEvent(txReceipt){var targetLogs=[];var _iterator=_createForOfIteratorHelper(txReceipt.logs),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var log=_step.value;try{var event=decodeEventLog({abi:accessControllerAbi,eventName:"PermissionSet",data:log.data,topics:log.topics});if(event.eventName==="PermissionSet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return targetLogs;}}]);}();/**
 * contract AccessController write method
 */var AccessControllerClient=/*#__PURE__*/function(_AccessControllerEven){function AccessControllerClient(rpcClient,wallet,address){var _this;_classCallCheck(this,AccessControllerClient);_this=_callSuper(this,AccessControllerClient,[rpcClient,address]);_this.wallet=wallet;return _this;}/**
   * method setAllPermissions for contract AccessController
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(AccessControllerClient,_AccessControllerEven);return _createClass(AccessControllerClient,[{key:"setAllPermissions",value:(function(){var _setAllPermissions=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request){var _yield$this$rpcClient,call;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:_context.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setAllPermissions",account:this.wallet.account,args:[request.ipAccount,request.signer,request.permission]});case 2:_yield$this$rpcClient=_context.sent;call=_yield$this$rpcClient.request;_context.next=6;return this.wallet.writeContract(call);case 6:return _context.abrupt("return",_context.sent);case 7:case"end":return _context.stop();}},_callee,this);}));function setAllPermissions(_x){return _setAllPermissions.apply(this,arguments);}return setAllPermissions;}()/**
   * method setAllPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setAllPermissionsEncode",value:function setAllPermissionsEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setAllPermissions",args:[request.ipAccount,request.signer,request.permission]})};}/**
   * method setBatchPermissions for contract AccessController
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setBatchPermissions",value:(function(){var _setBatchPermissions=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request){var _yield$this$rpcClient2,call;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setBatchPermissions",account:this.wallet.account,args:[request.permissions]});case 2:_yield$this$rpcClient2=_context2.sent;call=_yield$this$rpcClient2.request;_context2.next=6;return this.wallet.writeContract(call);case 6:return _context2.abrupt("return",_context2.sent);case 7:case"end":return _context2.stop();}},_callee2,this);}));function setBatchPermissions(_x2){return _setBatchPermissions.apply(this,arguments);}return setBatchPermissions;}()/**
   * method setBatchPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setBatchPermissionsEncode",value:function setBatchPermissionsEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setBatchPermissions",args:[request.permissions]})};}/**
   * method setPermission for contract AccessController
   *
   * @param request AccessControllerSetPermissionRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setPermission",value:(function(){var _setPermission=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request){var _yield$this$rpcClient3,call;return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setPermission",account:this.wallet.account,args:[request.ipAccount,request.signer,request.to,request.func,request.permission]});case 2:_yield$this$rpcClient3=_context3.sent;call=_yield$this$rpcClient3.request;_context3.next=6;return this.wallet.writeContract(call);case 6:return _context3.abrupt("return",_context3.sent);case 7:case"end":return _context3.stop();}},_callee3,this);}));function setPermission(_x3){return _setPermission.apply(this,arguments);}return setPermission;}()/**
   * method setPermission for contract AccessController with only encode
   *
   * @param request AccessControllerSetPermissionRequest
   * @return EncodedTxData
   */)},{key:"setPermissionEncode",value:function setPermissionEncode(request){return {to:this.address,data:encodeFunctionData({abi:accessControllerAbi,functionName:"setPermission",args:[request.ipAccount,request.signer,request.to,request.func,request.permission]})};}}]);}(AccessControllerEventClient);// Contract ArbitrationPolicyUMA =============================================================
/**
 * ArbitrationPolicyUmaDisputeIdToAssertionIdRequest
 *
 * @param disputeId uint256
 *//**
 * ArbitrationPolicyUmaMaxBondsRequest
 *
 * @param token address
 *//**
 * ArbitrationPolicyUmaDisputeAssertionRequest
 *
 * @param assertionId bytes32
 * @param counterEvidenceHash bytes32
 *//**
 * contract ArbitrationPolicyUMA readonly method
 */var ArbitrationPolicyUmaReadOnlyClient=/*#__PURE__*/function(){function ArbitrationPolicyUmaReadOnlyClient(rpcClient,address){var _rpcClient$chain2;_classCallCheck(this,ArbitrationPolicyUmaReadOnlyClient);this.address=address||getAddress(arbitrationPolicyUmaAddress,(_rpcClient$chain2=rpcClient.chain)===null||_rpcClient$chain2===void 0?void 0:_rpcClient$chain2.id);this.rpcClient=rpcClient;}/**
   * method disputeIdToAssertionId for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaDisputeIdToAssertionIdRequest
   * @return Promise<ArbitrationPolicyUmaDisputeIdToAssertionIdResponse>
   */return _createClass(ArbitrationPolicyUmaReadOnlyClient,[{key:"disputeIdToAssertionId",value:(function(){var _disputeIdToAssertionId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request){return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"disputeIdToAssertionId",args:[request.disputeId]});case 2:return _context4.abrupt("return",_context4.sent);case 3:case"end":return _context4.stop();}},_callee4,this);}));function disputeIdToAssertionId(_x4){return _disputeIdToAssertionId.apply(this,arguments);}return disputeIdToAssertionId;}()/**
   * method maxBonds for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxBondsRequest
   * @return Promise<ArbitrationPolicyUmaMaxBondsResponse>
   */)},{key:"maxBonds",value:(function(){var _maxBonds=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request){return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:_context5.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxBonds",args:[request.token]});case 2:return _context5.abrupt("return",_context5.sent);case 3:case"end":return _context5.stop();}},_callee5,this);}));function maxBonds(_x5){return _maxBonds.apply(this,arguments);}return maxBonds;}()/**
   * method maxLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMaxLivenessResponse>
   */)},{key:"maxLiveness",value:(function(){var _maxLiveness=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(){return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:_context6.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxLiveness"});case 2:return _context6.abrupt("return",_context6.sent);case 3:case"end":return _context6.stop();}},_callee6,this);}));function maxLiveness(){return _maxLiveness.apply(this,arguments);}return maxLiveness;}()/**
   * method minLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMinLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMinLivenessResponse>
   */)},{key:"minLiveness",value:(function(){var _minLiveness=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(){return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:_context7.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"minLiveness"});case 2:return _context7.abrupt("return",_context7.sent);case 3:case"end":return _context7.stop();}},_callee7,this);}));function minLiveness(){return _minLiveness.apply(this,arguments);}return minLiveness;}()/**
   * method oov3 for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaOov3Request
   * @return Promise<ArbitrationPolicyUmaOov3Response>
   */)},{key:"oov3",value:(function(){var _oov=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(){return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:_context8.next=2;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"oov3"});case 2:return _context8.abrupt("return",_context8.sent);case 3:case"end":return _context8.stop();}},_callee8,this);}));function oov3(){return _oov.apply(this,arguments);}return oov3;}())}]);}();/**
 * contract ArbitrationPolicyUMA write method
 */var ArbitrationPolicyUmaClient=/*#__PURE__*/function(_ArbitrationPolicyUma){function ArbitrationPolicyUmaClient(rpcClient,wallet,address){var _this2;_classCallCheck(this,ArbitrationPolicyUmaClient);_this2=_callSuper(this,ArbitrationPolicyUmaClient,[rpcClient,address]);_this2.wallet=wallet;return _this2;}/**
   * method disputeAssertion for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaDisputeAssertionRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(ArbitrationPolicyUmaClient,_ArbitrationPolicyUma);return _createClass(ArbitrationPolicyUmaClient,[{key:"disputeAssertion",value:(function(){var _disputeAssertion=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request){var _yield$this$rpcClient4,call;return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1)switch(_context9.prev=_context9.next){case 0:_context9.next=2;return this.rpcClient.simulateContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"disputeAssertion",account:this.wallet.account,args:[request.assertionId,request.counterEvidenceHash]});case 2:_yield$this$rpcClient4=_context9.sent;call=_yield$this$rpcClient4.request;_context9.next=6;return this.wallet.writeContract(call);case 6:return _context9.abrupt("return",_context9.sent);case 7:case"end":return _context9.stop();}},_callee9,this);}));function disputeAssertion(_x6){return _disputeAssertion.apply(this,arguments);}return disputeAssertion;}()/**
   * method disputeAssertion for contract ArbitrationPolicyUMA with only encode
   *
   * @param request ArbitrationPolicyUmaDisputeAssertionRequest
   * @return EncodedTxData
   */)},{key:"disputeAssertionEncode",value:function disputeAssertionEncode(request){return {to:this.address,data:encodeFunctionData({abi:arbitrationPolicyUmaAbi,functionName:"disputeAssertion",args:[request.assertionId,request.counterEvidenceHash]})};}}]);}(ArbitrationPolicyUmaReadOnlyClient);// Contract CoreMetadataModule =============================================================
/**
 * CoreMetadataModuleAuthorityUpdatedEvent
 *
 * @param authority address
 *//**
 * CoreMetadataModuleInitializedEvent
 *
 * @param version uint64
 *//**
 * CoreMetadataModuleMetadataFrozenEvent
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleMetadataUriSetEvent
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 *//**
 * CoreMetadataModuleNftTokenUriSetEvent
 *
 * @param ipId address
 * @param nftTokenURI string
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleUpgradedEvent
 *
 * @param implementation address
 *//**
 * CoreMetadataModuleIsMetadataFrozenRequest
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 *//**
 * CoreMetadataModuleFreezeMetadataRequest
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleInitializeRequest
 *
 * @param accessManager address
 *//**
 * CoreMetadataModuleSetAllRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleSetAuthorityRequest
 *
 * @param newAuthority address
 *//**
 * CoreMetadataModuleSetMetadataUriRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 *//**
 * CoreMetadataModuleUpdateNftTokenUriRequest
 *
 * @param ipId address
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 *//**
 * contract CoreMetadataModule event
 */var CoreMetadataModuleEventClient=/*#__PURE__*/function(){function CoreMetadataModuleEventClient(rpcClient,address){var _rpcClient$chain3;_classCallCheck(this,CoreMetadataModuleEventClient);this.address=address||getAddress(coreMetadataModuleAddress,(_rpcClient$chain3=rpcClient.chain)===null||_rpcClient$chain3===void 0?void 0:_rpcClient$chain3.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract CoreMetadataModule
   */return _createClass(CoreMetadataModuleEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs2){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs2(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract CoreMetadataModule
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator2=_createForOfIteratorHelper(txReceipt.logs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var log=_step2.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return targetLogs;}/**
   * event Initialized for contract CoreMetadataModule
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs3){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs3(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract CoreMetadataModule
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator3=_createForOfIteratorHelper(txReceipt.logs),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var log=_step3.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return targetLogs;}/**
   * event MetadataFrozen for contract CoreMetadataModule
   */},{key:"watchMetadataFrozenEvent",value:function watchMetadataFrozenEvent(_onLogs4){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataFrozen",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs4(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataFrozen for contract CoreMetadataModule
   */},{key:"parseTxMetadataFrozenEvent",value:function parseTxMetadataFrozenEvent(txReceipt){var targetLogs=[];var _iterator4=_createForOfIteratorHelper(txReceipt.logs),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var log=_step4.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataFrozen",data:log.data,topics:log.topics});if(event.eventName==="MetadataFrozen"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return targetLogs;}/**
   * event MetadataURISet for contract CoreMetadataModule
   */},{key:"watchMetadataUriSetEvent",value:function watchMetadataUriSetEvent(_onLogs5){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs5(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataURISet for contract CoreMetadataModule
   */},{key:"parseTxMetadataUriSetEvent",value:function parseTxMetadataUriSetEvent(txReceipt){var targetLogs=[];var _iterator5=_createForOfIteratorHelper(txReceipt.logs),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var log=_step5.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataURISet",data:log.data,topics:log.topics});if(event.eventName==="MetadataURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return targetLogs;}/**
   * event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"watchNftTokenUriSetEvent",value:function watchNftTokenUriSetEvent(_onLogs6){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"NFTTokenURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs6(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"parseTxNftTokenUriSetEvent",value:function parseTxNftTokenUriSetEvent(txReceipt){var targetLogs=[];var _iterator6=_createForOfIteratorHelper(txReceipt.logs),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var log=_step6.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"NFTTokenURISet",data:log.data,topics:log.topics});if(event.eventName==="NFTTokenURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return targetLogs;}/**
   * event Upgraded for contract CoreMetadataModule
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs7){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs7(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract CoreMetadataModule
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator7=_createForOfIteratorHelper(txReceipt.logs),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var log=_step7.value;try{var event=decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return targetLogs;}}]);}();/**
 * contract CoreMetadataModule readonly method
 */var CoreMetadataModuleReadOnlyClient=/*#__PURE__*/function(_CoreMetadataModuleEv){function CoreMetadataModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,CoreMetadataModuleReadOnlyClient);return _callSuper(this,CoreMetadataModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAccessControllerRequest
   * @return Promise<CoreMetadataModuleAccessControllerResponse>
   */_inherits(CoreMetadataModuleReadOnlyClient,_CoreMetadataModuleEv);return _createClass(CoreMetadataModuleReadOnlyClient,[{key:"accessController",value:(function(){var _accessController=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee0(){return _regeneratorRuntime().wrap(function _callee0$(_context0){while(1)switch(_context0.prev=_context0.next){case 0:_context0.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 2:return _context0.abrupt("return",_context0.sent);case 3:case"end":return _context0.stop();}},_callee0,this);}));function accessController(){return _accessController.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIpAssetRegistryRequest
   * @return Promise<CoreMetadataModuleIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee1(){return _regeneratorRuntime().wrap(function _callee1$(_context1){while(1)switch(_context1.prev=_context1.next){case 0:_context1.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 2:return _context1.abrupt("return",_context1.sent);case 3:case"end":return _context1.stop();}},_callee1,this);}));function ipAssetRegistry(){return _ipAssetRegistry.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeInterfaceVersionRequest
   * @return Promise<CoreMetadataModuleUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(){return _regeneratorRuntime().wrap(function _callee10$(_context10){while(1)switch(_context10.prev=_context10.next){case 0:_context10.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context10.abrupt("return",_context10.sent);case 3:case"end":return _context10.stop();}},_callee10,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method authority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAuthorityRequest
   * @return Promise<CoreMetadataModuleAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(){return _regeneratorRuntime().wrap(function _callee11$(_context11){while(1)switch(_context11.prev=_context11.next){case 0:_context11.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"authority"});case 2:return _context11.abrupt("return",_context11.sent);case 3:case"end":return _context11.stop();}},_callee11,this);}));function authority(){return _authority.apply(this,arguments);}return authority;}()/**
   * method isConsumingScheduledOp for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsConsumingScheduledOpRequest
   * @return Promise<CoreMetadataModuleIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(){return _regeneratorRuntime().wrap(function _callee12$(_context12){while(1)switch(_context12.prev=_context12.next){case 0:_context12.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context12.abrupt("return",_context12.sent);case 3:case"end":return _context12.stop();}},_callee12,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isMetadataFrozen for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsMetadataFrozenRequest
   * @return Promise<CoreMetadataModuleIsMetadataFrozenResponse>
   */)},{key:"isMetadataFrozen",value:(function(){var _isMetadataFrozen=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request){return _regeneratorRuntime().wrap(function _callee13$(_context13){while(1)switch(_context13.prev=_context13.next){case 0:_context13.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isMetadataFrozen",args:[request.ipId]});case 2:return _context13.abrupt("return",_context13.sent);case 3:case"end":return _context13.stop();}},_callee13,this);}));function isMetadataFrozen(_x7){return _isMetadataFrozen.apply(this,arguments);}return isMetadataFrozen;}()/**
   * method name for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleNameRequest
   * @return Promise<CoreMetadataModuleNameResponse>
   */)},{key:"name",value:(function(){var _name=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(){return _regeneratorRuntime().wrap(function _callee14$(_context14){while(1)switch(_context14.prev=_context14.next){case 0:_context14.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"name"});case 2:return _context14.abrupt("return",_context14.sent);case 3:case"end":return _context14.stop();}},_callee14,this);}));function name(){return _name.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleProxiableUuidRequest
   * @return Promise<CoreMetadataModuleProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(){return _regeneratorRuntime().wrap(function _callee15$(_context15){while(1)switch(_context15.prev=_context15.next){case 0:_context15.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context15.abrupt("return",_context15.sent);case 3:case"end":return _context15.stop();}},_callee15,this);}));function proxiableUuid(){return _proxiableUuid.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSupportsInterfaceRequest
   * @return Promise<CoreMetadataModuleSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request){return _regeneratorRuntime().wrap(function _callee16$(_context16){while(1)switch(_context16.prev=_context16.next){case 0:_context16.next=2;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context16.abrupt("return",_context16.sent);case 3:case"end":return _context16.stop();}},_callee16,this);}));function supportsInterface(_x8){return _supportsInterface.apply(this,arguments);}return supportsInterface;}())}]);}(CoreMetadataModuleEventClient);/**
 * contract CoreMetadataModule write method
 */var CoreMetadataModuleClient=/*#__PURE__*/function(_CoreMetadataModuleRe){function CoreMetadataModuleClient(rpcClient,wallet,address){var _this3;_classCallCheck(this,CoreMetadataModuleClient);_this3=_callSuper(this,CoreMetadataModuleClient,[rpcClient,address]);_this3.wallet=wallet;return _this3;}/**
   * method freezeMetadata for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(CoreMetadataModuleClient,_CoreMetadataModuleRe);return _createClass(CoreMetadataModuleClient,[{key:"freezeMetadata",value:(function(){var _freezeMetadata=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(request){var _yield$this$rpcClient5,call;return _regeneratorRuntime().wrap(function _callee17$(_context17){while(1)switch(_context17.prev=_context17.next){case 0:_context17.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"freezeMetadata",account:this.wallet.account,args:[request.ipId]});case 2:_yield$this$rpcClient5=_context17.sent;call=_yield$this$rpcClient5.request;_context17.next=6;return this.wallet.writeContract(call);case 6:return _context17.abrupt("return",_context17.sent);case 7:case"end":return _context17.stop();}},_callee17,this);}));function freezeMetadata(_x9){return _freezeMetadata.apply(this,arguments);}return freezeMetadata;}()/**
   * method freezeMetadata for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return EncodedTxData
   */)},{key:"freezeMetadataEncode",value:function freezeMetadataEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"freezeMetadata",args:[request.ipId]})};}/**
   * method initialize for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"initialize",value:(function(){var _initialize=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(request){var _yield$this$rpcClient6,call;return _regeneratorRuntime().wrap(function _callee18$(_context18){while(1)switch(_context18.prev=_context18.next){case 0:_context18.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager]});case 2:_yield$this$rpcClient6=_context18.sent;call=_yield$this$rpcClient6.request;_context18.next=6;return this.wallet.writeContract(call);case 6:return _context18.abrupt("return",_context18.sent);case 7:case"end":return _context18.stop();}},_callee18,this);}));function initialize(_x0){return _initialize.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"initialize",args:[request.accessManager]})};}/**
   * method setAll for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAll",value:(function(){var _setAll=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(request){var _yield$this$rpcClient7,call;return _regeneratorRuntime().wrap(function _callee19$(_context19){while(1)switch(_context19.prev=_context19.next){case 0:_context19.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAll",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]});case 2:_yield$this$rpcClient7=_context19.sent;call=_yield$this$rpcClient7.request;_context19.next=6;return this.wallet.writeContract(call);case 6:return _context19.abrupt("return",_context19.sent);case 7:case"end":return _context19.stop();}},_callee19,this);}));function setAll(_x1){return _setAll.apply(this,arguments);}return setAll;}()/**
   * method setAll for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return EncodedTxData
   */)},{key:"setAllEncode",value:function setAllEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAll",args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]})};}/**
   * method setAuthority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request){var _yield$this$rpcClient8,call;return _regeneratorRuntime().wrap(function _callee20$(_context20){while(1)switch(_context20.prev=_context20.next){case 0:_context20.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 2:_yield$this$rpcClient8=_context20.sent;call=_yield$this$rpcClient8.request;_context20.next=6;return this.wallet.writeContract(call);case 6:return _context20.abrupt("return",_context20.sent);case 7:case"end":return _context20.stop();}},_callee20,this);}));function setAuthority(_x10){return _setAuthority.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method setMetadataURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setMetadataUri",value:(function(){var _setMetadataUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(request){var _yield$this$rpcClient9,call;return _regeneratorRuntime().wrap(function _callee21$(_context21){while(1)switch(_context21.prev=_context21.next){case 0:_context21.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setMetadataURI",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash]});case 2:_yield$this$rpcClient9=_context21.sent;call=_yield$this$rpcClient9.request;_context21.next=6;return this.wallet.writeContract(call);case 6:return _context21.abrupt("return",_context21.sent);case 7:case"end":return _context21.stop();}},_callee21,this);}));function setMetadataUri(_x11){return _setMetadataUri.apply(this,arguments);}return setMetadataUri;}()/**
   * method setMetadataURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return EncodedTxData
   */)},{key:"setMetadataUriEncode",value:function setMetadataUriEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setMetadataURI",args:[request.ipId,request.metadataURI,request.metadataHash]})};}/**
   * method updateNftTokenURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"updateNftTokenUri",value:(function(){var _updateNftTokenUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request){var _yield$this$rpcClient0,call;return _regeneratorRuntime().wrap(function _callee22$(_context22){while(1)switch(_context22.prev=_context22.next){case 0:_context22.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"updateNftTokenURI",account:this.wallet.account,args:[request.ipId,request.nftMetadataHash]});case 2:_yield$this$rpcClient0=_context22.sent;call=_yield$this$rpcClient0.request;_context22.next=6;return this.wallet.writeContract(call);case 6:return _context22.abrupt("return",_context22.sent);case 7:case"end":return _context22.stop();}},_callee22,this);}));function updateNftTokenUri(_x12){return _updateNftTokenUri.apply(this,arguments);}return updateNftTokenUri;}()/**
   * method updateNftTokenURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return EncodedTxData
   */)},{key:"updateNftTokenUriEncode",value:function updateNftTokenUriEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"updateNftTokenURI",args:[request.ipId,request.nftMetadataHash]})};}/**
   * method upgradeToAndCall for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(request){var _yield$this$rpcClient1,call;return _regeneratorRuntime().wrap(function _callee23$(_context23){while(1)switch(_context23.prev=_context23.next){case 0:_context23.next=2;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 2:_yield$this$rpcClient1=_context23.sent;call=_yield$this$rpcClient1.request;_context23.next=6;return this.wallet.writeContract(call);case 6:return _context23.abrupt("return",_context23.sent);case 7:case"end":return _context23.stop();}},_callee23,this);}));function upgradeToAndCall(_x13){return _upgradeToAndCall.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}}]);}(CoreMetadataModuleReadOnlyClient);// Contract DerivativeWorkflows =============================================================
/**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
 *
 * @param spgNftContract address
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 *//**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param spgNftContract address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 *//**
 * DerivativeWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * contract DerivativeWorkflows write method
 */var DerivativeWorkflowsClient=/*#__PURE__*/function(){function DerivativeWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain4;_classCallCheck(this,DerivativeWorkflowsClient);this.address=address||getAddress(derivativeWorkflowsAddress,(_rpcClient$chain4=rpcClient.chain)===null||_rpcClient$chain4===void 0?void 0:_rpcClient$chain4.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(DerivativeWorkflowsClient,[{key:"mintAndRegisterIpAndMakeDerivative",value:(function(){var _mintAndRegisterIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(request){var _yield$this$rpcClient10,call;return _regeneratorRuntime().wrap(function _callee24$(_context24){while(1)switch(_context24.prev=_context24.next){case 0:_context24.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivative",account:this.wallet.account,args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]});case 2:_yield$this$rpcClient10=_context24.sent;call=_yield$this$rpcClient10.request;_context24.next=6;return this.wallet.writeContract(call);case 6:return _context24.abrupt("return",_context24.sent);case 7:case"end":return _context24.stop();}},_callee24,this);}));function mintAndRegisterIpAndMakeDerivative(_x14){return _mintAndRegisterIpAndMakeDerivative.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivative;}()/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeEncode",value:function mintAndRegisterIpAndMakeDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivative",args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(request){var _yield$this$rpcClient11,call;return _regeneratorRuntime().wrap(function _callee25$(_context25){while(1)switch(_context25.prev=_context25.next){case 0:_context25.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]});case 2:_yield$this$rpcClient11=_context25.sent;call=_yield$this$rpcClient11.request;_context25.next=6;return this.wallet.writeContract(call);case 6:return _context25.abrupt("return",_context25.sent);case 7:case"end":return _context25.stop();}},_callee25,this);}));function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x15){return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method multicall for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(request){var _yield$this$rpcClient12,call;return _regeneratorRuntime().wrap(function _callee26$(_context26){while(1)switch(_context26.prev=_context26.next){case 0:_context26.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient12=_context26.sent;call=_yield$this$rpcClient12.request;_context26.next=6;return this.wallet.writeContract(call);case 6:return _context26.abrupt("return",_context26.sent);case 7:case"end":return _context26.stop();}},_callee26,this);}));function multicall(_x16){return _multicall.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivative",value:(function(){var _registerIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(request){var _yield$this$rpcClient13,call;return _regeneratorRuntime().wrap(function _callee27$(_context27){while(1)switch(_context27.prev=_context27.next){case 0:_context27.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivative",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient13=_context27.sent;call=_yield$this$rpcClient13.request;_context27.next=6;return this.wallet.writeContract(call);case 6:return _context27.abrupt("return",_context27.sent);case 7:case"end":return _context27.stop();}},_callee27,this);}));function registerIpAndMakeDerivative(_x17){return _registerIpAndMakeDerivative.apply(this,arguments);}return registerIpAndMakeDerivative;}()/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeEncode",value:function registerIpAndMakeDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivative",args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]})};}/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _registerIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(request){var _yield$this$rpcClient14,call;return _regeneratorRuntime().wrap(function _callee28$(_context28){while(1)switch(_context28.prev=_context28.next){case 0:_context28.next=2;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient14=_context28.sent;call=_yield$this$rpcClient14.request;_context28.next=6;return this.wallet.writeContract(call);case 6:return _context28.abrupt("return",_context28.sent);case 7:case"end":return _context28.stop();}},_callee28,this);}));function registerIpAndMakeDerivativeWithLicenseTokens(_x18){return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return registerIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeWithLicenseTokensEncode",value:function registerIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]})};}}]);}();// Contract DisputeModule =============================================================
/**
 * DisputeModuleDisputeCancelledEvent
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleDisputeRaisedEvent
 *
 * @param disputeId uint256
 * @param targetIpId address
 * @param disputeInitiator address
 * @param disputeTimestamp uint256
 * @param arbitrationPolicy address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 *//**
 * DisputeModuleDisputeResolvedEvent
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleIsWhitelistedDisputeTagRequest
 *
 * @param tag bytes32
 *//**
 * DisputeModuleIsWhitelistedDisputeTagResponse
 *
 * @param allowed bool
 *//**
 * DisputeModuleCancelDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleRaiseDisputeRequest
 *
 * @param targetIpId address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 *//**
 * DisputeModuleResolveDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleTagIfRelatedIpInfringedRequest
 *
 * @param ipIdToTag address
 * @param infringerDisputeId uint256
 *//**
 * contract DisputeModule event
 */var DisputeModuleEventClient=/*#__PURE__*/function(){function DisputeModuleEventClient(rpcClient,address){var _rpcClient$chain5;_classCallCheck(this,DisputeModuleEventClient);this.address=address||getAddress(disputeModuleAddress,(_rpcClient$chain5=rpcClient.chain)===null||_rpcClient$chain5===void 0?void 0:_rpcClient$chain5.id);this.rpcClient=rpcClient;}/**
   * event DisputeCancelled for contract DisputeModule
   */return _createClass(DisputeModuleEventClient,[{key:"watchDisputeCancelledEvent",value:function watchDisputeCancelledEvent(_onLogs8){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeCancelled",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs8(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeCancelled for contract DisputeModule
   */},{key:"parseTxDisputeCancelledEvent",value:function parseTxDisputeCancelledEvent(txReceipt){var targetLogs=[];var _iterator8=_createForOfIteratorHelper(txReceipt.logs),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var log=_step8.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeCancelled",data:log.data,topics:log.topics});if(event.eventName==="DisputeCancelled"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}return targetLogs;}/**
   * event DisputeRaised for contract DisputeModule
   */},{key:"watchDisputeRaisedEvent",value:function watchDisputeRaisedEvent(_onLogs9){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeRaised",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs9(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeRaised for contract DisputeModule
   */},{key:"parseTxDisputeRaisedEvent",value:function parseTxDisputeRaisedEvent(txReceipt){var targetLogs=[];var _iterator9=_createForOfIteratorHelper(txReceipt.logs),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var log=_step9.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeRaised",data:log.data,topics:log.topics});if(event.eventName==="DisputeRaised"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return targetLogs;}/**
   * event DisputeResolved for contract DisputeModule
   */},{key:"watchDisputeResolvedEvent",value:function watchDisputeResolvedEvent(_onLogs0){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeResolved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs0(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeResolved for contract DisputeModule
   */},{key:"parseTxDisputeResolvedEvent",value:function parseTxDisputeResolvedEvent(txReceipt){var targetLogs=[];var _iterator0=_createForOfIteratorHelper(txReceipt.logs),_step0;try{for(_iterator0.s();!(_step0=_iterator0.n()).done;){var log=_step0.value;try{var event=decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeResolved",data:log.data,topics:log.topics});if(event.eventName==="DisputeResolved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator0.e(err);}finally{_iterator0.f();}return targetLogs;}}]);}();/**
 * contract DisputeModule readonly method
 */var DisputeModuleReadOnlyClient=/*#__PURE__*/function(_DisputeModuleEventCl){function DisputeModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,DisputeModuleReadOnlyClient);return _callSuper(this,DisputeModuleReadOnlyClient,[rpcClient,address]);}/**
   * method isWhitelistedDisputeTag for contract DisputeModule
   *
   * @param request DisputeModuleIsWhitelistedDisputeTagRequest
   * @return Promise<DisputeModuleIsWhitelistedDisputeTagResponse>
   */_inherits(DisputeModuleReadOnlyClient,_DisputeModuleEventCl);return _createClass(DisputeModuleReadOnlyClient,[{key:"isWhitelistedDisputeTag",value:(function(){var _isWhitelistedDisputeTag=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(request){var result;return _regeneratorRuntime().wrap(function _callee29$(_context29){while(1)switch(_context29.prev=_context29.next){case 0:_context29.next=2;return this.rpcClient.readContract({abi:disputeModuleAbi,address:this.address,functionName:"isWhitelistedDisputeTag",args:[request.tag]});case 2:result=_context29.sent;return _context29.abrupt("return",{allowed:result});case 4:case"end":return _context29.stop();}},_callee29,this);}));function isWhitelistedDisputeTag(_x19){return _isWhitelistedDisputeTag.apply(this,arguments);}return isWhitelistedDisputeTag;}())}]);}(DisputeModuleEventClient);/**
 * contract DisputeModule write method
 */var DisputeModuleClient=/*#__PURE__*/function(_DisputeModuleReadOnl){function DisputeModuleClient(rpcClient,wallet,address){var _this4;_classCallCheck(this,DisputeModuleClient);_this4=_callSuper(this,DisputeModuleClient,[rpcClient,address]);_this4.wallet=wallet;return _this4;}/**
   * method cancelDispute for contract DisputeModule
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(DisputeModuleClient,_DisputeModuleReadOnl);return _createClass(DisputeModuleClient,[{key:"cancelDispute",value:(function(){var _cancelDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(request){var _yield$this$rpcClient15,call;return _regeneratorRuntime().wrap(function _callee30$(_context30){while(1)switch(_context30.prev=_context30.next){case 0:_context30.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"cancelDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 2:_yield$this$rpcClient15=_context30.sent;call=_yield$this$rpcClient15.request;_context30.next=6;return this.wallet.writeContract(call);case 6:return _context30.abrupt("return",_context30.sent);case 7:case"end":return _context30.stop();}},_callee30,this);}));function cancelDispute(_x20){return _cancelDispute.apply(this,arguments);}return cancelDispute;}()/**
   * method cancelDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return EncodedTxData
   */)},{key:"cancelDisputeEncode",value:function cancelDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"cancelDispute",args:[request.disputeId,request.data]})};}/**
   * method raiseDispute for contract DisputeModule
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"raiseDispute",value:(function(){var _raiseDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(request){var _yield$this$rpcClient16,call;return _regeneratorRuntime().wrap(function _callee31$(_context31){while(1)switch(_context31.prev=_context31.next){case 0:_context31.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"raiseDispute",account:this.wallet.account,args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]});case 2:_yield$this$rpcClient16=_context31.sent;call=_yield$this$rpcClient16.request;_context31.next=6;return this.wallet.writeContract(call);case 6:return _context31.abrupt("return",_context31.sent);case 7:case"end":return _context31.stop();}},_callee31,this);}));function raiseDispute(_x21){return _raiseDispute.apply(this,arguments);}return raiseDispute;}()/**
   * method raiseDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return EncodedTxData
   */)},{key:"raiseDisputeEncode",value:function raiseDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"raiseDispute",args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]})};}/**
   * method resolveDispute for contract DisputeModule
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"resolveDispute",value:(function(){var _resolveDispute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(request){var _yield$this$rpcClient17,call;return _regeneratorRuntime().wrap(function _callee32$(_context32){while(1)switch(_context32.prev=_context32.next){case 0:_context32.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"resolveDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 2:_yield$this$rpcClient17=_context32.sent;call=_yield$this$rpcClient17.request;_context32.next=6;return this.wallet.writeContract(call);case 6:return _context32.abrupt("return",_context32.sent);case 7:case"end":return _context32.stop();}},_callee32,this);}));function resolveDispute(_x22){return _resolveDispute.apply(this,arguments);}return resolveDispute;}()/**
   * method resolveDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return EncodedTxData
   */)},{key:"resolveDisputeEncode",value:function resolveDisputeEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"resolveDispute",args:[request.disputeId,request.data]})};}/**
   * method tagIfRelatedIpInfringed for contract DisputeModule
   *
   * @param request DisputeModuleTagIfRelatedIpInfringedRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"tagIfRelatedIpInfringed",value:(function(){var _tagIfRelatedIpInfringed=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(request){var _yield$this$rpcClient18,call;return _regeneratorRuntime().wrap(function _callee33$(_context33){while(1)switch(_context33.prev=_context33.next){case 0:_context33.next=2;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"tagIfRelatedIpInfringed",account:this.wallet.account,args:[request.ipIdToTag,request.infringerDisputeId]});case 2:_yield$this$rpcClient18=_context33.sent;call=_yield$this$rpcClient18.request;_context33.next=6;return this.wallet.writeContract(call);case 6:return _context33.abrupt("return",_context33.sent);case 7:case"end":return _context33.stop();}},_callee33,this);}));function tagIfRelatedIpInfringed(_x23){return _tagIfRelatedIpInfringed.apply(this,arguments);}return tagIfRelatedIpInfringed;}()/**
   * method tagIfRelatedIpInfringed for contract DisputeModule with only encode
   *
   * @param request DisputeModuleTagIfRelatedIpInfringedRequest
   * @return EncodedTxData
   */)},{key:"tagIfRelatedIpInfringedEncode",value:function tagIfRelatedIpInfringedEncode(request){return {to:this.address,data:encodeFunctionData({abi:disputeModuleAbi,functionName:"tagIfRelatedIpInfringed",args:[request.ipIdToTag,request.infringerDisputeId]})};}}]);}(DisputeModuleReadOnlyClient);// Contract ERC20 =============================================================
/**
 * Erc20AllowanceRequest
 *
 * @param owner address
 * @param spender address
 *//**
 * Erc20BalanceOfRequest
 *
 * @param account address
 *//**
 * Erc20ApproveRequest
 *
 * @param spender address
 * @param value uint256
 *//**
 * Erc20MintRequest
 *
 * @param to address
 * @param amount uint256
 *//**
 * Erc20TransferRequest
 *
 * @param to address
 * @param value uint256
 *//**
 * Erc20TransferFromRequest
 *
 * @param from address
 * @param to address
 * @param value uint256
 *//**
 * contract ERC20 readonly method
 */var Erc20ReadOnlyClient=/*#__PURE__*/function(){function Erc20ReadOnlyClient(rpcClient,address){var _rpcClient$chain6;_classCallCheck(this,Erc20ReadOnlyClient);this.address=address||getAddress(erc20Address,(_rpcClient$chain6=rpcClient.chain)===null||_rpcClient$chain6===void 0?void 0:_rpcClient$chain6.id);this.rpcClient=rpcClient;}/**
   * method allowance for contract ERC20
   *
   * @param request Erc20AllowanceRequest
   * @return Promise<Erc20AllowanceResponse>
   */return _createClass(Erc20ReadOnlyClient,[{key:"allowance",value:(function(){var _allowance=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(request){return _regeneratorRuntime().wrap(function _callee34$(_context34){while(1)switch(_context34.prev=_context34.next){case 0:_context34.next=2;return this.rpcClient.readContract({abi:erc20Abi,address:this.address,functionName:"allowance",args:[request.owner,request.spender]});case 2:return _context34.abrupt("return",_context34.sent);case 3:case"end":return _context34.stop();}},_callee34,this);}));function allowance(_x24){return _allowance.apply(this,arguments);}return allowance;}()/**
   * method balanceOf for contract ERC20
   *
   * @param request Erc20BalanceOfRequest
   * @return Promise<Erc20BalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(request){return _regeneratorRuntime().wrap(function _callee35$(_context35){while(1)switch(_context35.prev=_context35.next){case 0:_context35.next=2;return this.rpcClient.readContract({abi:erc20Abi,address:this.address,functionName:"balanceOf",args:[request.account]});case 2:return _context35.abrupt("return",_context35.sent);case 3:case"end":return _context35.stop();}},_callee35,this);}));function balanceOf(_x25){return _balanceOf.apply(this,arguments);}return balanceOf;}())}]);}();/**
 * contract ERC20 write method
 */var Erc20Client=/*#__PURE__*/function(_Erc20ReadOnlyClient){function Erc20Client(rpcClient,wallet,address){var _this5;_classCallCheck(this,Erc20Client);_this5=_callSuper(this,Erc20Client,[rpcClient,address]);_this5.wallet=wallet;return _this5;}/**
   * method approve for contract ERC20
   *
   * @param request Erc20ApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(Erc20Client,_Erc20ReadOnlyClient);return _createClass(Erc20Client,[{key:"approve",value:(function(){var _approve=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(request){var _yield$this$rpcClient19,call;return _regeneratorRuntime().wrap(function _callee36$(_context36){while(1)switch(_context36.prev=_context36.next){case 0:_context36.next=2;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.spender,request.value]});case 2:_yield$this$rpcClient19=_context36.sent;call=_yield$this$rpcClient19.request;_context36.next=6;return this.wallet.writeContract(call);case 6:return _context36.abrupt("return",_context36.sent);case 7:case"end":return _context36.stop();}},_callee36,this);}));function approve(_x26){return _approve.apply(this,arguments);}return approve;}()/**
   * method approve for contract ERC20 with only encode
   *
   * @param request Erc20ApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:encodeFunctionData({abi:erc20Abi,functionName:"approve",args:[request.spender,request.value]})};}/**
   * method mint for contract ERC20
   *
   * @param request Erc20MintRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mint",value:(function(){var _mint=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37(request){var _yield$this$rpcClient20,call;return _regeneratorRuntime().wrap(function _callee37$(_context37){while(1)switch(_context37.prev=_context37.next){case 0:_context37.next=2;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"mint",account:this.wallet.account,args:[request.to,request.amount]});case 2:_yield$this$rpcClient20=_context37.sent;call=_yield$this$rpcClient20.request;_context37.next=6;return this.wallet.writeContract(call);case 6:return _context37.abrupt("return",_context37.sent);case 7:case"end":return _context37.stop();}},_callee37,this);}));function mint(_x27){return _mint.apply(this,arguments);}return mint;}()/**
   * method mint for contract ERC20 with only encode
   *
   * @param request Erc20MintRequest
   * @return EncodedTxData
   */)},{key:"mintEncode",value:function mintEncode(request){return {to:this.address,data:encodeFunctionData({abi:erc20Abi,functionName:"mint",args:[request.to,request.amount]})};}/**
   * method transfer for contract ERC20
   *
   * @param request Erc20TransferRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transfer",value:(function(){var _transfer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(request){var _yield$this$rpcClient21,call;return _regeneratorRuntime().wrap(function _callee38$(_context38){while(1)switch(_context38.prev=_context38.next){case 0:_context38.next=2;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"transfer",account:this.wallet.account,args:[request.to,request.value]});case 2:_yield$this$rpcClient21=_context38.sent;call=_yield$this$rpcClient21.request;_context38.next=6;return this.wallet.writeContract(call);case 6:return _context38.abrupt("return",_context38.sent);case 7:case"end":return _context38.stop();}},_callee38,this);}));function transfer(_x28){return _transfer.apply(this,arguments);}return transfer;}()/**
   * method transfer for contract ERC20 with only encode
   *
   * @param request Erc20TransferRequest
   * @return EncodedTxData
   */)},{key:"transferEncode",value:function transferEncode(request){return {to:this.address,data:encodeFunctionData({abi:erc20Abi,functionName:"transfer",args:[request.to,request.value]})};}/**
   * method transferFrom for contract ERC20
   *
   * @param request Erc20TransferFromRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transferFrom",value:(function(){var _transferFrom=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(request){var _yield$this$rpcClient22,call;return _regeneratorRuntime().wrap(function _callee39$(_context39){while(1)switch(_context39.prev=_context39.next){case 0:_context39.next=2;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"transferFrom",account:this.wallet.account,args:[request.from,request.to,request.value]});case 2:_yield$this$rpcClient22=_context39.sent;call=_yield$this$rpcClient22.request;_context39.next=6;return this.wallet.writeContract(call);case 6:return _context39.abrupt("return",_context39.sent);case 7:case"end":return _context39.stop();}},_callee39,this);}));function transferFrom(_x29){return _transferFrom.apply(this,arguments);}return transferFrom;}()/**
   * method transferFrom for contract ERC20 with only encode
   *
   * @param request Erc20TransferFromRequest
   * @return EncodedTxData
   */)},{key:"transferFromEncode",value:function transferFromEncode(request){return {to:this.address,data:encodeFunctionData({abi:erc20Abi,functionName:"transferFrom",args:[request.from,request.to,request.value]})};}}]);}(Erc20ReadOnlyClient);// Contract EvenSplitGroupPool =============================================================
/**
 * GroupingModuleClaimedRewardEvent
 *
 * @param groupId address
 * @param token address
 * @param ipId address[]
 * @param amount uint256[]
 *//**
 * GroupingModuleCollectedRoyaltiesToGroupPoolEvent
 *
 * @param groupId address
 * @param token address
 * @param pool address
 * @param amount uint256
 *//**
 * GroupingModuleIpGroupRegisteredEvent
 *
 * @param groupId address
 * @param groupPool address
 *//**
 * GroupingModuleGetClaimableRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 *//**
 * GroupingModuleAddIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 *//**
 * GroupingModuleClaimRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 *//**
 * GroupingModuleCollectRoyaltiesRequest
 *
 * @param groupId address
 * @param token address
 *//**
 * GroupingModuleRegisterGroupRequest
 *
 * @param groupPool address
 *//**
 * GroupingModuleRemoveIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 *//**
 * contract GroupingModule event
 */var GroupingModuleEventClient=/*#__PURE__*/function(){function GroupingModuleEventClient(rpcClient,address){var _rpcClient$chain8;_classCallCheck(this,GroupingModuleEventClient);this.address=address||getAddress(groupingModuleAddress,(_rpcClient$chain8=rpcClient.chain)===null||_rpcClient$chain8===void 0?void 0:_rpcClient$chain8.id);this.rpcClient=rpcClient;}/**
   * event ClaimedReward for contract GroupingModule
   */return _createClass(GroupingModuleEventClient,[{key:"watchClaimedRewardEvent",value:function watchClaimedRewardEvent(_onLogs14){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"ClaimedReward",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs14(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event ClaimedReward for contract GroupingModule
   */},{key:"parseTxClaimedRewardEvent",value:function parseTxClaimedRewardEvent(txReceipt){var targetLogs=[];var _iterator14=_createForOfIteratorHelper(txReceipt.logs),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var log=_step14.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"ClaimedReward",data:log.data,topics:log.topics});if(event.eventName==="ClaimedReward"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}return targetLogs;}/**
   * event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"watchCollectedRoyaltiesToGroupPoolEvent",value:function watchCollectedRoyaltiesToGroupPoolEvent(_onLogs15){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"CollectedRoyaltiesToGroupPool",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs15(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"parseTxCollectedRoyaltiesToGroupPoolEvent",value:function parseTxCollectedRoyaltiesToGroupPoolEvent(txReceipt){var targetLogs=[];var _iterator15=_createForOfIteratorHelper(txReceipt.logs),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var log=_step15.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"CollectedRoyaltiesToGroupPool",data:log.data,topics:log.topics});if(event.eventName==="CollectedRoyaltiesToGroupPool"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}return targetLogs;}/**
   * event IPGroupRegistered for contract GroupingModule
   */},{key:"watchIpGroupRegisteredEvent",value:function watchIpGroupRegisteredEvent(_onLogs16){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"IPGroupRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs16(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPGroupRegistered for contract GroupingModule
   */},{key:"parseTxIpGroupRegisteredEvent",value:function parseTxIpGroupRegisteredEvent(txReceipt){var targetLogs=[];var _iterator16=_createForOfIteratorHelper(txReceipt.logs),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var log=_step16.value;try{var event=decodeEventLog({abi:groupingModuleAbi,eventName:"IPGroupRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPGroupRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}return targetLogs;}}]);}();/**
 * contract GroupingModule readonly method
 */var GroupingModuleReadOnlyClient=/*#__PURE__*/function(_GroupingModuleEventC){function GroupingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,GroupingModuleReadOnlyClient);return _callSuper(this,GroupingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method getClaimableReward for contract GroupingModule
   *
   * @param request GroupingModuleGetClaimableRewardRequest
   * @return Promise<GroupingModuleGetClaimableRewardResponse>
   */_inherits(GroupingModuleReadOnlyClient,_GroupingModuleEventC);return _createClass(GroupingModuleReadOnlyClient,[{key:"getClaimableReward",value:(function(){var _getClaimableReward=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee66(request){return _regeneratorRuntime().wrap(function _callee66$(_context66){while(1)switch(_context66.prev=_context66.next){case 0:_context66.next=2;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"getClaimableReward",args:[request.groupId,request.token,request.ipIds]});case 2:return _context66.abrupt("return",_context66.sent);case 3:case"end":return _context66.stop();}},_callee66,this);}));function getClaimableReward(_x45){return _getClaimableReward.apply(this,arguments);}return getClaimableReward;}())}]);}(GroupingModuleEventClient);/**
 * contract GroupingModule write method
 */var GroupingModuleClient=/*#__PURE__*/function(_GroupingModuleReadOn){function GroupingModuleClient(rpcClient,wallet,address){var _this7;_classCallCheck(this,GroupingModuleClient);_this7=_callSuper(this,GroupingModuleClient,[rpcClient,address]);_this7.wallet=wallet;return _this7;}/**
   * method addIp for contract GroupingModule
   *
   * @param request GroupingModuleAddIpRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(GroupingModuleClient,_GroupingModuleReadOn);return _createClass(GroupingModuleClient,[{key:"addIp",value:(function(){var _addIp2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee67(request){var _yield$this$rpcClient33,call;return _regeneratorRuntime().wrap(function _callee67$(_context67){while(1)switch(_context67.prev=_context67.next){case 0:_context67.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"addIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]});case 2:_yield$this$rpcClient33=_context67.sent;call=_yield$this$rpcClient33.request;_context67.next=6;return this.wallet.writeContract(call);case 6:return _context67.abrupt("return",_context67.sent);case 7:case"end":return _context67.stop();}},_callee67,this);}));function addIp(_x46){return _addIp2.apply(this,arguments);}return addIp;}()/**
   * method addIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleAddIpRequest
   * @return EncodedTxData
   */)},{key:"addIpEncode",value:function addIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"addIp",args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]})};}/**
   * method claimReward for contract GroupingModule
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"claimReward",value:(function(){var _claimReward=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee68(request){var _yield$this$rpcClient34,call;return _regeneratorRuntime().wrap(function _callee68$(_context68){while(1)switch(_context68.prev=_context68.next){case 0:_context68.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"claimReward",account:this.wallet.account,args:[request.groupId,request.token,request.ipIds]});case 2:_yield$this$rpcClient34=_context68.sent;call=_yield$this$rpcClient34.request;_context68.next=6;return this.wallet.writeContract(call);case 6:return _context68.abrupt("return",_context68.sent);case 7:case"end":return _context68.stop();}},_callee68,this);}));function claimReward(_x47){return _claimReward.apply(this,arguments);}return claimReward;}()/**
   * method claimReward for contract GroupingModule with only encode
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return EncodedTxData
   */)},{key:"claimRewardEncode",value:function claimRewardEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"claimReward",args:[request.groupId,request.token,request.ipIds]})};}/**
   * method collectRoyalties for contract GroupingModule
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"collectRoyalties",value:(function(){var _collectRoyalties=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee69(request){var _yield$this$rpcClient35,call;return _regeneratorRuntime().wrap(function _callee69$(_context69){while(1)switch(_context69.prev=_context69.next){case 0:_context69.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"collectRoyalties",account:this.wallet.account,args:[request.groupId,request.token]});case 2:_yield$this$rpcClient35=_context69.sent;call=_yield$this$rpcClient35.request;_context69.next=6;return this.wallet.writeContract(call);case 6:return _context69.abrupt("return",_context69.sent);case 7:case"end":return _context69.stop();}},_callee69,this);}));function collectRoyalties(_x48){return _collectRoyalties.apply(this,arguments);}return collectRoyalties;}()/**
   * method collectRoyalties for contract GroupingModule with only encode
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return EncodedTxData
   */)},{key:"collectRoyaltiesEncode",value:function collectRoyaltiesEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"collectRoyalties",args:[request.groupId,request.token]})};}/**
   * method registerGroup for contract GroupingModule
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroup",value:(function(){var _registerGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee70(request){var _yield$this$rpcClient36,call;return _regeneratorRuntime().wrap(function _callee70$(_context70){while(1)switch(_context70.prev=_context70.next){case 0:_context70.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"registerGroup",account:this.wallet.account,args:[request.groupPool]});case 2:_yield$this$rpcClient36=_context70.sent;call=_yield$this$rpcClient36.request;_context70.next=6;return this.wallet.writeContract(call);case 6:return _context70.abrupt("return",_context70.sent);case 7:case"end":return _context70.stop();}},_callee70,this);}));function registerGroup(_x49){return _registerGroup.apply(this,arguments);}return registerGroup;}()/**
   * method registerGroup for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return EncodedTxData
   */)},{key:"registerGroupEncode",value:function registerGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"registerGroup",args:[request.groupPool]})};}/**
   * method removeIp for contract GroupingModule
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"removeIp",value:(function(){var _removeIp2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee71(request){var _yield$this$rpcClient37,call;return _regeneratorRuntime().wrap(function _callee71$(_context71){while(1)switch(_context71.prev=_context71.next){case 0:_context71.next=2;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"removeIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds]});case 2:_yield$this$rpcClient37=_context71.sent;call=_yield$this$rpcClient37.request;_context71.next=6;return this.wallet.writeContract(call);case 6:return _context71.abrupt("return",_context71.sent);case 7:case"end":return _context71.stop();}},_callee71,this);}));function removeIp(_x50){return _removeIp2.apply(this,arguments);}return removeIp;}()/**
   * method removeIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return EncodedTxData
   */)},{key:"removeIpEncode",value:function removeIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingModuleAbi,functionName:"removeIp",args:[request.groupIpId,request.ipIds]})};}}]);}(GroupingModuleReadOnlyClient);// Contract GroupingWorkflows =============================================================
/**
 * GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
 *
 * @param groupIpId address
 * @param currencyTokens address[]
 * @param memberIpIds address[]
 *//**
 * GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param spgNftContract address
 * @param groupId address
 * @param recipient address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigAddToGroup tuple
 * @param allowDuplicates bool
 *//**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
 *
 * @param groupPool address
 * @param licenseData tuple
 *//**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
 *
 * @param groupPool address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 * @param licenseData tuple
 *//**
 * GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param groupId address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigMetadataAndAttachAndConfig tuple
 * @param sigAddToGroup tuple
 *//**
 * contract GroupingWorkflows write method
 */var GroupingWorkflowsClient=/*#__PURE__*/function(){function GroupingWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain9;_classCallCheck(this,GroupingWorkflowsClient);this.address=address||getAddress(groupingWorkflowsAddress,(_rpcClient$chain9=rpcClient.chain)===null||_rpcClient$chain9===void 0?void 0:_rpcClient$chain9.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method collectRoyaltiesAndClaimReward for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(GroupingWorkflowsClient,[{key:"collectRoyaltiesAndClaimReward",value:(function(){var _collectRoyaltiesAndClaimReward=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee72(request){var _yield$this$rpcClient38,call;return _regeneratorRuntime().wrap(function _callee72$(_context72){while(1)switch(_context72.prev=_context72.next){case 0:_context72.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"collectRoyaltiesAndClaimReward",account:this.wallet.account,args:[request.groupIpId,request.currencyTokens,request.memberIpIds]});case 2:_yield$this$rpcClient38=_context72.sent;call=_yield$this$rpcClient38.request;_context72.next=6;return this.wallet.writeContract(call);case 6:return _context72.abrupt("return",_context72.sent);case 7:case"end":return _context72.stop();}},_callee72,this);}));function collectRoyaltiesAndClaimReward(_x51){return _collectRoyaltiesAndClaimReward.apply(this,arguments);}return collectRoyaltiesAndClaimReward;}()/**
   * method collectRoyaltiesAndClaimReward for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
   * @return EncodedTxData
   */)},{key:"collectRoyaltiesAndClaimRewardEncode",value:function collectRoyaltiesAndClaimRewardEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"collectRoyaltiesAndClaimReward",args:[request.groupIpId,request.currencyTokens,request.memberIpIds]})};}/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",value:(function(){var _mintAndRegisterIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee73(request){var _yield$this$rpcClient39,call;return _regeneratorRuntime().wrap(function _callee73$(_context73){while(1)switch(_context73.prev=_context73.next){case 0:_context73.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]});case 2:_yield$this$rpcClient39=_context73.sent;call=_yield$this$rpcClient39.request;_context73.next=6;return this.wallet.writeContract(call);case 6:return _context73.abrupt("return",_context73.sent);case 7:case"end":return _context73.stop();}},_callee73,this);}));function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x52){return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return mintAndRegisterIpAndAttachLicenseAndAddToGroup;}()/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode",value:function mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]})};}/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicense",value:(function(){var _registerGroupAndAttachLicense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee74(request){var _yield$this$rpcClient40,call;return _regeneratorRuntime().wrap(function _callee74$(_context74){while(1)switch(_context74.prev=_context74.next){case 0:_context74.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicense",account:this.wallet.account,args:[request.groupPool,request.licenseData]});case 2:_yield$this$rpcClient40=_context74.sent;call=_yield$this$rpcClient40.request;_context74.next=6;return this.wallet.writeContract(call);case 6:return _context74.abrupt("return",_context74.sent);case 7:case"end":return _context74.stop();}},_callee74,this);}));function registerGroupAndAttachLicense(_x53){return _registerGroupAndAttachLicense.apply(this,arguments);}return registerGroupAndAttachLicense;}()/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseEncode",value:function registerGroupAndAttachLicenseEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicense",args:[request.groupPool,request.licenseData]})};}/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicenseAndAddIps",value:(function(){var _registerGroupAndAttachLicenseAndAddIps=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee75(request){var _yield$this$rpcClient41,call;return _regeneratorRuntime().wrap(function _callee75$(_context75){while(1)switch(_context75.prev=_context75.next){case 0:_context75.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicenseAndAddIps",account:this.wallet.account,args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]});case 2:_yield$this$rpcClient41=_context75.sent;call=_yield$this$rpcClient41.request;_context75.next=6;return this.wallet.writeContract(call);case 6:return _context75.abrupt("return",_context75.sent);case 7:case"end":return _context75.stop();}},_callee75,this);}));function registerGroupAndAttachLicenseAndAddIps(_x54){return _registerGroupAndAttachLicenseAndAddIps.apply(this,arguments);}return registerGroupAndAttachLicenseAndAddIps;}()/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseAndAddIpsEncode",value:function registerGroupAndAttachLicenseAndAddIpsEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicenseAndAddIps",args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]})};}/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachLicenseAndAddToGroup",value:(function(){var _registerIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee76(request){var _yield$this$rpcClient42,call;return _regeneratorRuntime().wrap(function _callee76$(_context76){while(1)switch(_context76.prev=_context76.next){case 0:_context76.next=2;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]});case 2:_yield$this$rpcClient42=_context76.sent;call=_yield$this$rpcClient42.request;_context76.next=6;return this.wallet.writeContract(call);case 6:return _context76.abrupt("return",_context76.sent);case 7:case"end":return _context76.stop();}},_callee76,this);}));function registerIpAndAttachLicenseAndAddToGroup(_x55){return _registerIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return registerIpAndAttachLicenseAndAddToGroup;}()/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachLicenseAndAddToGroupEncode",value:function registerIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerIpAndAttachLicenseAndAddToGroup",args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]})};}}]);}();// Contract IPAccountImpl =============================================================
/**
 * IpAccountImplStateResponse
 *
 * @param result bytes32
 *//**
 * IpAccountImplTokenResponse
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 uint256
 *//**
 * IpAccountImplExecuteRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param operation uint8
 *//**
 * IpAccountImplExecute2Request
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 *//**
 * IpAccountImplExecuteBatchRequest
 *
 * @param calls tuple[]
 * @param operation uint8
 *//**
 * IpAccountImplExecuteWithSigRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param signer address
 * @param deadline uint256
 * @param signature bytes
 *//**
 * contract IPAccountImpl readonly method
 */var IpAccountImplReadOnlyClient=/*#__PURE__*/function(){function IpAccountImplReadOnlyClient(rpcClient,address){var _rpcClient$chain0;_classCallCheck(this,IpAccountImplReadOnlyClient);this.address=address||getAddress(ipAccountImplAddress,(_rpcClient$chain0=rpcClient.chain)===null||_rpcClient$chain0===void 0?void 0:_rpcClient$chain0.id);this.rpcClient=rpcClient;}/**
   * method owner for contract IPAccountImpl
   *
   * @param request IpAccountImplOwnerRequest
   * @return Promise<IpAccountImplOwnerResponse>
   */return _createClass(IpAccountImplReadOnlyClient,[{key:"owner",value:(function(){var _owner=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee77(){return _regeneratorRuntime().wrap(function _callee77$(_context77){while(1)switch(_context77.prev=_context77.next){case 0:_context77.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"owner"});case 2:return _context77.abrupt("return",_context77.sent);case 3:case"end":return _context77.stop();}},_callee77,this);}));function owner(){return _owner.apply(this,arguments);}return owner;}()/**
   * method state for contract IPAccountImpl
   *
   * @param request IpAccountImplStateRequest
   * @return Promise<IpAccountImplStateResponse>
   */)},{key:"state",value:(function(){var _state=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee78(){var result;return _regeneratorRuntime().wrap(function _callee78$(_context78){while(1)switch(_context78.prev=_context78.next){case 0:_context78.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"state"});case 2:result=_context78.sent;return _context78.abrupt("return",{result:result});case 4:case"end":return _context78.stop();}},_callee78,this);}));function state(){return _state.apply(this,arguments);}return state;}()/**
   * method token for contract IPAccountImpl
   *
   * @param request IpAccountImplTokenRequest
   * @return Promise<IpAccountImplTokenResponse>
   */)},{key:"token",value:(function(){var _token=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee79(){return _regeneratorRuntime().wrap(function _callee79$(_context79){while(1)switch(_context79.prev=_context79.next){case 0:_context79.next=2;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"token"});case 2:return _context79.abrupt("return",_context79.sent);case 3:case"end":return _context79.stop();}},_callee79,this);}));function token(){return _token.apply(this,arguments);}return token;}())}]);}();/**
 * contract IPAccountImpl write method
 */var IpAccountImplClient=/*#__PURE__*/function(_IpAccountImplReadOnl){function IpAccountImplClient(rpcClient,wallet,address){var _this8;_classCallCheck(this,IpAccountImplClient);_this8=_callSuper(this,IpAccountImplClient,[rpcClient,address]);_this8.wallet=wallet;return _this8;}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAccountImplClient,_IpAccountImplReadOnl);return _createClass(IpAccountImplClient,[{key:"execute",value:(function(){var _execute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee80(request){var _yield$this$rpcClient43,call;return _regeneratorRuntime().wrap(function _callee80$(_context80){while(1)switch(_context80.prev=_context80.next){case 0:_context80.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data,request.operation]});case 2:_yield$this$rpcClient43=_context80.sent;call=_yield$this$rpcClient43.request;_context80.next=6;return this.wallet.writeContract(call);case 6:return _context80.abrupt("return",_context80.sent);case 7:case"end":return _context80.stop();}},_callee80,this);}));function execute(_x56){return _execute.apply(this,arguments);}return execute;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteRequest
   * @return EncodedTxData
   */)},{key:"executeEncode",value:function executeEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data,request.operation]})};}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecute2Request
   * @return Promise<WriteContractReturnType>
   */},{key:"execute2",value:(function(){var _execute2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee81(request){var _yield$this$rpcClient44,call;return _regeneratorRuntime().wrap(function _callee81$(_context81){while(1)switch(_context81.prev=_context81.next){case 0:_context81.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data]});case 2:_yield$this$rpcClient44=_context81.sent;call=_yield$this$rpcClient44.request;_context81.next=6;return this.wallet.writeContract(call);case 6:return _context81.abrupt("return",_context81.sent);case 7:case"end":return _context81.stop();}},_callee81,this);}));function execute2(_x57){return _execute2.apply(this,arguments);}return execute2;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecute2Request
   * @return EncodedTxData
   */)},{key:"execute2Encode",value:function execute2Encode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data]})};}/**
   * method executeBatch for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteBatchRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"executeBatch",value:(function(){var _executeBatch=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee82(request){var _yield$this$rpcClient45,call;return _regeneratorRuntime().wrap(function _callee82$(_context82){while(1)switch(_context82.prev=_context82.next){case 0:_context82.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"executeBatch",account:this.wallet.account,args:[request.calls,request.operation]});case 2:_yield$this$rpcClient45=_context82.sent;call=_yield$this$rpcClient45.request;_context82.next=6;return this.wallet.writeContract(call);case 6:return _context82.abrupt("return",_context82.sent);case 7:case"end":return _context82.stop();}},_callee82,this);}));function executeBatch(_x58){return _executeBatch.apply(this,arguments);}return executeBatch;}()/**
   * method executeBatch for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteBatchRequest
   * @return EncodedTxData
   */)},{key:"executeBatchEncode",value:function executeBatchEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"executeBatch",args:[request.calls,request.operation]})};}/**
   * method executeWithSig for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"executeWithSig",value:(function(){var _executeWithSig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee83(request){var _yield$this$rpcClient46,call;return _regeneratorRuntime().wrap(function _callee83$(_context83){while(1)switch(_context83.prev=_context83.next){case 0:_context83.next=2;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"executeWithSig",account:this.wallet.account,args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]});case 2:_yield$this$rpcClient46=_context83.sent;call=_yield$this$rpcClient46.request;_context83.next=6;return this.wallet.writeContract(call);case 6:return _context83.abrupt("return",_context83.sent);case 7:case"end":return _context83.stop();}},_callee83,this);}));function executeWithSig(_x59){return _executeWithSig.apply(this,arguments);}return executeWithSig;}()/**
   * method executeWithSig for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return EncodedTxData
   */)},{key:"executeWithSigEncode",value:function executeWithSigEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAccountImplAbi,functionName:"executeWithSig",args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]})};}}]);}(IpAccountImplReadOnlyClient);// Contract IPAssetRegistry =============================================================
/**
 * IpAssetRegistryIpAccountRegisteredEvent
 *
 * @param account address
 * @param implementation address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * IpAssetRegistryIpRegisteredEvent
 *
 * @param ipId address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 * @param name string
 * @param uri string
 * @param registrationDate uint256
 *//**
 * IpAssetRegistryIpIdRequest
 *
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * IpAssetRegistryIsRegisteredRequest
 *
 * @param id address
 *//**
 * IpAssetRegistryRegisterRequest
 *
 * @param chainid uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * contract IPAssetRegistry event
 */var IpAssetRegistryEventClient=/*#__PURE__*/function(){function IpAssetRegistryEventClient(rpcClient,address){var _rpcClient$chain1;_classCallCheck(this,IpAssetRegistryEventClient);this.address=address||getAddress(ipAssetRegistryAddress,(_rpcClient$chain1=rpcClient.chain)===null||_rpcClient$chain1===void 0?void 0:_rpcClient$chain1.id);this.rpcClient=rpcClient;}/**
   * event IPAccountRegistered for contract IPAssetRegistry
   */return _createClass(IpAssetRegistryEventClient,[{key:"watchIpAccountRegisteredEvent",value:function watchIpAccountRegisteredEvent(_onLogs17){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPAccountRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs17(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPAccountRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpAccountRegisteredEvent",value:function parseTxIpAccountRegisteredEvent(txReceipt){var targetLogs=[];var _iterator17=_createForOfIteratorHelper(txReceipt.logs),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var log=_step17.value;try{var event=decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPAccountRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPAccountRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}return targetLogs;}/**
   * event IPRegistered for contract IPAssetRegistry
   */},{key:"watchIpRegisteredEvent",value:function watchIpRegisteredEvent(_onLogs18){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs18(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpRegisteredEvent",value:function parseTxIpRegisteredEvent(txReceipt){var targetLogs=[];var _iterator18=_createForOfIteratorHelper(txReceipt.logs),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var log=_step18.value;try{var event=decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}return targetLogs;}}]);}();/**
 * contract IPAssetRegistry readonly method
 */var IpAssetRegistryReadOnlyClient=/*#__PURE__*/function(_IpAssetRegistryEvent){function IpAssetRegistryReadOnlyClient(rpcClient,address){_classCallCheck(this,IpAssetRegistryReadOnlyClient);return _callSuper(this,IpAssetRegistryReadOnlyClient,[rpcClient,address]);}/**
   * method ipId for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIpIdRequest
   * @return Promise<IpAssetRegistryIpIdResponse>
   */_inherits(IpAssetRegistryReadOnlyClient,_IpAssetRegistryEvent);return _createClass(IpAssetRegistryReadOnlyClient,[{key:"ipId",value:(function(){var _ipId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee84(request){return _regeneratorRuntime().wrap(function _callee84$(_context84){while(1)switch(_context84.prev=_context84.next){case 0:_context84.next=2;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"ipId",args:[request.chainId,request.tokenContract,request.tokenId]});case 2:return _context84.abrupt("return",_context84.sent);case 3:case"end":return _context84.stop();}},_callee84,this);}));function ipId(_x60){return _ipId.apply(this,arguments);}return ipId;}()/**
   * method isRegistered for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIsRegisteredRequest
   * @return Promise<IpAssetRegistryIsRegisteredResponse>
   */)},{key:"isRegistered",value:(function(){var _isRegistered=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee85(request){return _regeneratorRuntime().wrap(function _callee85$(_context85){while(1)switch(_context85.prev=_context85.next){case 0:_context85.next=2;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.id]});case 2:return _context85.abrupt("return",_context85.sent);case 3:case"end":return _context85.stop();}},_callee85,this);}));function isRegistered(_x61){return _isRegistered.apply(this,arguments);}return isRegistered;}())}]);}(IpAssetRegistryEventClient);/**
 * contract IPAssetRegistry write method
 */var IpAssetRegistryClient=/*#__PURE__*/function(_IpAssetRegistryReadO){function IpAssetRegistryClient(rpcClient,wallet,address){var _this9;_classCallCheck(this,IpAssetRegistryClient);_this9=_callSuper(this,IpAssetRegistryClient,[rpcClient,address]);_this9.wallet=wallet;return _this9;}/**
   * method register for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAssetRegistryClient,_IpAssetRegistryReadO);return _createClass(IpAssetRegistryClient,[{key:"register",value:(function(){var _register=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee86(request){var _yield$this$rpcClient47,call;return _regeneratorRuntime().wrap(function _callee86$(_context86){while(1)switch(_context86.prev=_context86.next){case 0:_context86.next=2;return this.rpcClient.simulateContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"register",account:this.wallet.account,args:[request.chainid,request.tokenContract,request.tokenId]});case 2:_yield$this$rpcClient47=_context86.sent;call=_yield$this$rpcClient47.request;_context86.next=6;return this.wallet.writeContract(call);case 6:return _context86.abrupt("return",_context86.sent);case 7:case"end":return _context86.stop();}},_callee86,this);}));function register(_x62){return _register.apply(this,arguments);}return register;}()/**
   * method register for contract IPAssetRegistry with only encode
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return EncodedTxData
   */)},{key:"registerEncode",value:function registerEncode(request){return {to:this.address,data:encodeFunctionData({abi:ipAssetRegistryAbi,functionName:"register",args:[request.chainid,request.tokenContract,request.tokenId]})};}}]);}(IpAssetRegistryReadOnlyClient);// Contract IpRoyaltyVaultImpl =============================================================
/**
 * IpRoyaltyVaultImplRevenueTokenClaimedEvent
 *
 * @param claimer address
 * @param token address
 * @param amount uint256
 *//**
 * IpRoyaltyVaultImplBalanceOfRequest
 *
 * @param account address
 *//**
 * IpRoyaltyVaultImplClaimableRevenueRequest
 *
 * @param claimer address
 * @param token address
 *//**
 * contract IpRoyaltyVaultImpl event
 */var IpRoyaltyVaultImplEventClient=/*#__PURE__*/function(){function IpRoyaltyVaultImplEventClient(rpcClient,address){var _rpcClient$chain10;_classCallCheck(this,IpRoyaltyVaultImplEventClient);this.address=address||getAddress(ipRoyaltyVaultImplAddress,(_rpcClient$chain10=rpcClient.chain)===null||_rpcClient$chain10===void 0?void 0:_rpcClient$chain10.id);this.rpcClient=rpcClient;}/**
   * event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */return _createClass(IpRoyaltyVaultImplEventClient,[{key:"watchRevenueTokenClaimedEvent",value:function watchRevenueTokenClaimedEvent(_onLogs19){return this.rpcClient.watchContractEvent({abi:ipRoyaltyVaultImplAbi,address:this.address,eventName:"RevenueTokenClaimed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs19(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */},{key:"parseTxRevenueTokenClaimedEvent",value:function parseTxRevenueTokenClaimedEvent(txReceipt){var targetLogs=[];var _iterator19=_createForOfIteratorHelper(txReceipt.logs),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var log=_step19.value;try{var event=decodeEventLog({abi:ipRoyaltyVaultImplAbi,eventName:"RevenueTokenClaimed",data:log.data,topics:log.topics});if(event.eventName==="RevenueTokenClaimed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}return targetLogs;}}]);}();/**
 * contract IpRoyaltyVaultImpl readonly method
 */var IpRoyaltyVaultImplReadOnlyClient=/*#__PURE__*/function(_IpRoyaltyVaultImplEv){function IpRoyaltyVaultImplReadOnlyClient(rpcClient,address){_classCallCheck(this,IpRoyaltyVaultImplReadOnlyClient);return _callSuper(this,IpRoyaltyVaultImplReadOnlyClient,[rpcClient,address]);}/**
   * method balanceOf for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplBalanceOfRequest
   * @return Promise<IpRoyaltyVaultImplBalanceOfResponse>
   */_inherits(IpRoyaltyVaultImplReadOnlyClient,_IpRoyaltyVaultImplEv);return _createClass(IpRoyaltyVaultImplReadOnlyClient,[{key:"balanceOf",value:(function(){var _balanceOf2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee87(request){return _regeneratorRuntime().wrap(function _callee87$(_context87){while(1)switch(_context87.prev=_context87.next){case 0:_context87.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"balanceOf",args:[request.account]});case 2:return _context87.abrupt("return",_context87.sent);case 3:case"end":return _context87.stop();}},_callee87,this);}));function balanceOf(_x63){return _balanceOf2.apply(this,arguments);}return balanceOf;}()/**
   * method claimableRevenue for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimableRevenueRequest
   * @return Promise<IpRoyaltyVaultImplClaimableRevenueResponse>
   */)},{key:"claimableRevenue",value:(function(){var _claimableRevenue=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee88(request){return _regeneratorRuntime().wrap(function _callee88$(_context88){while(1)switch(_context88.prev=_context88.next){case 0:_context88.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"claimableRevenue",args:[request.claimer,request.token]});case 2:return _context88.abrupt("return",_context88.sent);case 3:case"end":return _context88.stop();}},_callee88,this);}));function claimableRevenue(_x64){return _claimableRevenue.apply(this,arguments);}return claimableRevenue;}()/**
   * method ipId for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplIpIdRequest
   * @return Promise<IpRoyaltyVaultImplIpIdResponse>
   */)},{key:"ipId",value:(function(){var _ipId2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee89(){return _regeneratorRuntime().wrap(function _callee89$(_context89){while(1)switch(_context89.prev=_context89.next){case 0:_context89.next=2;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"ipId"});case 2:return _context89.abrupt("return",_context89.sent);case 3:case"end":return _context89.stop();}},_callee89,this);}));function ipId(){return _ipId2.apply(this,arguments);}return ipId;}())}]);}(IpRoyaltyVaultImplEventClient);// Contract LicenseAttachmentWorkflows =============================================================
/**
 * LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param allowDuplicates bool
 *//**
 * LicenseAttachmentWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 *//**
 * LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
 *
 * @param ipId address
 * @param licenseTermsData tuple[]
 * @param sigAttachAndConfig tuple
 *//**
 * contract LicenseAttachmentWorkflows write method
 */var LicenseAttachmentWorkflowsClient=/*#__PURE__*/function(){function LicenseAttachmentWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain11;_classCallCheck(this,LicenseAttachmentWorkflowsClient);this.address=address||getAddress(licenseAttachmentWorkflowsAddress,(_rpcClient$chain11=rpcClient.chain)===null||_rpcClient$chain11===void 0?void 0:_rpcClient$chain11.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(LicenseAttachmentWorkflowsClient,[{key:"mintAndRegisterIpAndAttachPilTerms",value:(function(){var _mintAndRegisterIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee90(request){var _yield$this$rpcClient48,call;return _regeneratorRuntime().wrap(function _callee90$(_context90){while(1)switch(_context90.prev=_context90.next){case 0:_context90.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTerms",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]});case 2:_yield$this$rpcClient48=_context90.sent;call=_yield$this$rpcClient48.request;_context90.next=6;return this.wallet.writeContract(call);case 6:return _context90.abrupt("return",_context90.sent);case 7:case"end":return _context90.stop();}},_callee90,this);}));function mintAndRegisterIpAndAttachPilTerms(_x65){return _mintAndRegisterIpAndAttachPilTerms.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTerms;}()/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsEncode",value:function mintAndRegisterIpAndAttachPilTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTerms",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]})};}/**
   * method multicall for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee91(request){var _yield$this$rpcClient49,call;return _regeneratorRuntime().wrap(function _callee91$(_context91){while(1)switch(_context91.prev=_context91.next){case 0:_context91.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient49=_context91.sent;call=_yield$this$rpcClient49.request;_context91.next=6;return this.wallet.writeContract(call);case 6:return _context91.abrupt("return",_context91.sent);case 7:case"end":return _context91.stop();}},_callee91,this);}));function multicall(_x66){return _multicall2.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTerms",value:(function(){var _registerIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee92(request){var _yield$this$rpcClient50,call;return _regeneratorRuntime().wrap(function _callee92$(_context92){while(1)switch(_context92.prev=_context92.next){case 0:_context92.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTerms",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 2:_yield$this$rpcClient50=_context92.sent;call=_yield$this$rpcClient50.request;_context92.next=6;return this.wallet.writeContract(call);case 6:return _context92.abrupt("return",_context92.sent);case 7:case"end":return _context92.stop();}},_callee92,this);}));function registerIpAndAttachPilTerms(_x67){return _registerIpAndAttachPilTerms.apply(this,arguments);}return registerIpAndAttachPilTerms;}()/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsEncode",value:function registerIpAndAttachPilTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerIpAndAttachPILTerms",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerPilTermsAndAttach",value:(function(){var _registerPilTermsAndAttach=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee93(request){var _yield$this$rpcClient51,call;return _regeneratorRuntime().wrap(function _callee93$(_context93){while(1)switch(_context93.prev=_context93.next){case 0:_context93.next=2;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerPILTermsAndAttach",account:this.wallet.account,args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]});case 2:_yield$this$rpcClient51=_context93.sent;call=_yield$this$rpcClient51.request;_context93.next=6;return this.wallet.writeContract(call);case 6:return _context93.abrupt("return",_context93.sent);case 7:case"end":return _context93.stop();}},_callee93,this);}));function registerPilTermsAndAttach(_x68){return _registerPilTermsAndAttach.apply(this,arguments);}return registerPilTermsAndAttach;}()/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return EncodedTxData
   */)},{key:"registerPilTermsAndAttachEncode",value:function registerPilTermsAndAttachEncode(request){return {to:this.address,data:encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerPILTermsAndAttach",args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]})};}}]);}();// Contract LicenseRegistry =============================================================
/**
 * LicenseRegistryGetDefaultLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetRoyaltyPercentRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetRoyaltyPercentResponse
 *
 * @param royaltyPercent uint32
 *//**
 * LicenseRegistryHasIpAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * contract LicenseRegistry readonly method
 */var LicenseRegistryReadOnlyClient=/*#__PURE__*/function(){function LicenseRegistryReadOnlyClient(rpcClient,address){var _rpcClient$chain12;_classCallCheck(this,LicenseRegistryReadOnlyClient);this.address=address||getAddress(licenseRegistryAddress,(_rpcClient$chain12=rpcClient.chain)===null||_rpcClient$chain12===void 0?void 0:_rpcClient$chain12.id);this.rpcClient=rpcClient;}/**
   * method getDefaultLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetDefaultLicenseTermsRequest
   * @return Promise<LicenseRegistryGetDefaultLicenseTermsResponse>
   */return _createClass(LicenseRegistryReadOnlyClient,[{key:"getDefaultLicenseTerms",value:(function(){var _getDefaultLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee94(){var result;return _regeneratorRuntime().wrap(function _callee94$(_context94){while(1)switch(_context94.prev=_context94.next){case 0:_context94.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getDefaultLicenseTerms"});case 2:result=_context94.sent;return _context94.abrupt("return",{licenseTemplate:result[0],licenseTermsId:result[1]});case 4:case"end":return _context94.stop();}},_callee94,this);}));function getDefaultLicenseTerms(){return _getDefaultLicenseTerms.apply(this,arguments);}return getDefaultLicenseTerms;}()/**
   * method getLicensingConfig for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetLicensingConfigRequest
   * @return Promise<LicenseRegistryGetLicensingConfigResponse>
   */)},{key:"getLicensingConfig",value:(function(){var _getLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee95(request){return _regeneratorRuntime().wrap(function _callee95$(_context95){while(1)switch(_context95.prev=_context95.next){case 0:_context95.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:return _context95.abrupt("return",_context95.sent);case 3:case"end":return _context95.stop();}},_callee95,this);}));function getLicensingConfig(_x69){return _getLicensingConfig.apply(this,arguments);}return getLicensingConfig;}()/**
   * method getRoyaltyPercent for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetRoyaltyPercentRequest
   * @return Promise<LicenseRegistryGetRoyaltyPercentResponse>
   */)},{key:"getRoyaltyPercent",value:(function(){var _getRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee96(request){var result;return _regeneratorRuntime().wrap(function _callee96$(_context96){while(1)switch(_context96.prev=_context96.next){case 0:_context96.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getRoyaltyPercent",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:result=_context96.sent;return _context96.abrupt("return",{royaltyPercent:result});case 4:case"end":return _context96.stop();}},_callee96,this);}));function getRoyaltyPercent(_x70){return _getRoyaltyPercent.apply(this,arguments);}return getRoyaltyPercent;}()/**
   * method hasIpAttachedLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryHasIpAttachedLicenseTermsRequest
   * @return Promise<LicenseRegistryHasIpAttachedLicenseTermsResponse>
   */)},{key:"hasIpAttachedLicenseTerms",value:(function(){var _hasIpAttachedLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee97(request){return _regeneratorRuntime().wrap(function _callee97$(_context97){while(1)switch(_context97.prev=_context97.next){case 0:_context97.next=2;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"hasIpAttachedLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:return _context97.abrupt("return",_context97.sent);case 3:case"end":return _context97.stop();}},_callee97,this);}));function hasIpAttachedLicenseTerms(_x71){return _hasIpAttachedLicenseTerms.apply(this,arguments);}return hasIpAttachedLicenseTerms;}())}]);}();// Contract LicenseToken =============================================================
/**
 * LicenseTokenOwnerOfRequest
 *
 * @param tokenId uint256
 *//**
 * contract LicenseToken readonly method
 */var LicenseTokenReadOnlyClient=/*#__PURE__*/function(){function LicenseTokenReadOnlyClient(rpcClient,address){var _rpcClient$chain13;_classCallCheck(this,LicenseTokenReadOnlyClient);this.address=address||getAddress(licenseTokenAddress,(_rpcClient$chain13=rpcClient.chain)===null||_rpcClient$chain13===void 0?void 0:_rpcClient$chain13.id);this.rpcClient=rpcClient;}/**
   * method ownerOf for contract LicenseToken
   *
   * @param request LicenseTokenOwnerOfRequest
   * @return Promise<LicenseTokenOwnerOfResponse>
   */return _createClass(LicenseTokenReadOnlyClient,[{key:"ownerOf",value:(function(){var _ownerOf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee98(request){return _regeneratorRuntime().wrap(function _callee98$(_context98){while(1)switch(_context98.prev=_context98.next){case 0:_context98.next=2;return this.rpcClient.readContract({abi:licenseTokenAbi,address:this.address,functionName:"ownerOf",args:[request.tokenId]});case 2:return _context98.abrupt("return",_context98.sent);case 3:case"end":return _context98.stop();}},_callee98,this);}));function ownerOf(_x72){return _ownerOf.apply(this,arguments);}return ownerOf;}())}]);}();// Contract LicensingModule =============================================================
/**
 * LicensingModuleLicenseTermsAttachedEvent
 *
 * @param caller address
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicensingModuleLicenseTokensMintedEvent
 *
 * @param caller address
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param startLicenseTokenId uint256
 *//**
 * LicensingModulePredictMintingLicenseFeeRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 *//**
 * LicensingModulePredictMintingLicenseFeeResponse
 *
 * @param currencyToken address
 * @param tokenAmount uint256
 *//**
 * LicensingModuleAttachLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicensingModuleMintLicenseTokensRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRevenueShare uint32
 *//**
 * LicensingModuleRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param licenseTemplate address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRts uint32
 * @param maxRevenueShare uint32
 *//**
 * LicensingModuleRegisterDerivativeWithLicenseTokensRequest
 *
 * @param childIpId address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 *//**
 * LicensingModuleSetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 *//**
 * contract LicensingModule event
 */var LicensingModuleEventClient=/*#__PURE__*/function(){function LicensingModuleEventClient(rpcClient,address){var _rpcClient$chain14;_classCallCheck(this,LicensingModuleEventClient);this.address=address||getAddress(licensingModuleAddress,(_rpcClient$chain14=rpcClient.chain)===null||_rpcClient$chain14===void 0?void 0:_rpcClient$chain14.id);this.rpcClient=rpcClient;}/**
   * event LicenseTermsAttached for contract LicensingModule
   */return _createClass(LicensingModuleEventClient,[{key:"watchLicenseTermsAttachedEvent",value:function watchLicenseTermsAttachedEvent(_onLogs20){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTermsAttached",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs20(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsAttached for contract LicensingModule
   */},{key:"parseTxLicenseTermsAttachedEvent",value:function parseTxLicenseTermsAttachedEvent(txReceipt){var targetLogs=[];var _iterator20=_createForOfIteratorHelper(txReceipt.logs),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var log=_step20.value;try{var event=decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTermsAttached",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsAttached"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}return targetLogs;}/**
   * event LicenseTokensMinted for contract LicensingModule
   */},{key:"watchLicenseTokensMintedEvent",value:function watchLicenseTokensMintedEvent(_onLogs21){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTokensMinted",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs21(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTokensMinted for contract LicensingModule
   */},{key:"parseTxLicenseTokensMintedEvent",value:function parseTxLicenseTokensMintedEvent(txReceipt){var targetLogs=[];var _iterator21=_createForOfIteratorHelper(txReceipt.logs),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var log=_step21.value;try{var event=decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTokensMinted",data:log.data,topics:log.topics});if(event.eventName==="LicenseTokensMinted"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator21.e(err);}finally{_iterator21.f();}return targetLogs;}}]);}();/**
 * contract LicensingModule readonly method
 */var LicensingModuleReadOnlyClient=/*#__PURE__*/function(_LicensingModuleEvent){function LicensingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,LicensingModuleReadOnlyClient);return _callSuper(this,LicensingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method predictMintingLicenseFee for contract LicensingModule
   *
   * @param request LicensingModulePredictMintingLicenseFeeRequest
   * @return Promise<LicensingModulePredictMintingLicenseFeeResponse>
   */_inherits(LicensingModuleReadOnlyClient,_LicensingModuleEvent);return _createClass(LicensingModuleReadOnlyClient,[{key:"predictMintingLicenseFee",value:(function(){var _predictMintingLicenseFee=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee99(request){var result;return _regeneratorRuntime().wrap(function _callee99$(_context99){while(1)switch(_context99.prev=_context99.next){case 0:_context99.next=2;return this.rpcClient.readContract({abi:licensingModuleAbi,address:this.address,functionName:"predictMintingLicenseFee",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext]});case 2:result=_context99.sent;return _context99.abrupt("return",{currencyToken:result[0],tokenAmount:result[1]});case 4:case"end":return _context99.stop();}},_callee99,this);}));function predictMintingLicenseFee(_x73){return _predictMintingLicenseFee.apply(this,arguments);}return predictMintingLicenseFee;}())}]);}(LicensingModuleEventClient);/**
 * contract LicensingModule write method
 */var LicensingModuleClient=/*#__PURE__*/function(_LicensingModuleReadO){function LicensingModuleClient(rpcClient,wallet,address){var _this0;_classCallCheck(this,LicensingModuleClient);_this0=_callSuper(this,LicensingModuleClient,[rpcClient,address]);_this0.wallet=wallet;return _this0;}/**
   * method attachLicenseTerms for contract LicensingModule
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(LicensingModuleClient,_LicensingModuleReadO);return _createClass(LicensingModuleClient,[{key:"attachLicenseTerms",value:(function(){var _attachLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee100(request){var _yield$this$rpcClient52,call;return _regeneratorRuntime().wrap(function _callee100$(_context100){while(1)switch(_context100.prev=_context100.next){case 0:_context100.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"attachLicenseTerms",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 2:_yield$this$rpcClient52=_context100.sent;call=_yield$this$rpcClient52.request;_context100.next=6;return this.wallet.writeContract(call);case 6:return _context100.abrupt("return",_context100.sent);case 7:case"end":return _context100.stop();}},_callee100,this);}));function attachLicenseTerms(_x74){return _attachLicenseTerms.apply(this,arguments);}return attachLicenseTerms;}()/**
   * method attachLicenseTerms for contract LicensingModule with only encode
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"attachLicenseTermsEncode",value:function attachLicenseTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"attachLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]})};}/**
   * method mintLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintLicenseTokens",value:(function(){var _mintLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee101(request){var _yield$this$rpcClient53,call;return _regeneratorRuntime().wrap(function _callee101$(_context101){while(1)switch(_context101.prev=_context101.next){case 0:_context101.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"mintLicenseTokens",account:this.wallet.account,args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]});case 2:_yield$this$rpcClient53=_context101.sent;call=_yield$this$rpcClient53.request;_context101.next=6;return this.wallet.writeContract(call);case 6:return _context101.abrupt("return",_context101.sent);case 7:case"end":return _context101.stop();}},_callee101,this);}));function mintLicenseTokens(_x75){return _mintLicenseTokens.apply(this,arguments);}return mintLicenseTokens;}()/**
   * method mintLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintLicenseTokensEncode",value:function mintLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"mintLicenseTokens",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]})};}/**
   * method registerDerivative for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivative",value:(function(){var _registerDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee102(request){var _yield$this$rpcClient54,call;return _regeneratorRuntime().wrap(function _callee102$(_context102){while(1)switch(_context102.prev=_context102.next){case 0:_context102.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]});case 2:_yield$this$rpcClient54=_context102.sent;call=_yield$this$rpcClient54.request;_context102.next=6;return this.wallet.writeContract(call);case 6:return _context102.abrupt("return",_context102.sent);case 7:case"end":return _context102.stop();}},_callee102,this);}));function registerDerivative(_x76){return _registerDerivative.apply(this,arguments);}return registerDerivative;}()/**
   * method registerDerivative for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeEncode",value:function registerDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivative",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]})};}/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivativeWithLicenseTokens",value:(function(){var _registerDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee103(request){var _yield$this$rpcClient55,call;return _regeneratorRuntime().wrap(function _callee103$(_context103){while(1)switch(_context103.prev=_context103.next){case 0:_context103.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]});case 2:_yield$this$rpcClient55=_context103.sent;call=_yield$this$rpcClient55.request;_context103.next=6;return this.wallet.writeContract(call);case 6:return _context103.abrupt("return",_context103.sent);case 7:case"end":return _context103.stop();}},_callee103,this);}));function registerDerivativeWithLicenseTokens(_x77){return _registerDerivativeWithLicenseTokens.apply(this,arguments);}return registerDerivativeWithLicenseTokens;}()/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeWithLicenseTokensEncode",value:function registerDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivativeWithLicenseTokens",args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]})};}/**
   * method setLicensingConfig for contract LicensingModule
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setLicensingConfig",value:(function(){var _setLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee104(request){var _yield$this$rpcClient56,call;return _regeneratorRuntime().wrap(function _callee104$(_context104){while(1)switch(_context104.prev=_context104.next){case 0:_context104.next=2;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"setLicensingConfig",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]});case 2:_yield$this$rpcClient56=_context104.sent;call=_yield$this$rpcClient56.request;_context104.next=6;return this.wallet.writeContract(call);case 6:return _context104.abrupt("return",_context104.sent);case 7:case"end":return _context104.stop();}},_callee104,this);}));function setLicensingConfig(_x78){return _setLicensingConfig.apply(this,arguments);}return setLicensingConfig;}()/**
   * method setLicensingConfig for contract LicensingModule with only encode
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return EncodedTxData
   */)},{key:"setLicensingConfigEncode",value:function setLicensingConfigEncode(request){return {to:this.address,data:encodeFunctionData({abi:licensingModuleAbi,functionName:"setLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]})};}}]);}(LicensingModuleReadOnlyClient);// Contract ModuleRegistry =============================================================
/**
 * ModuleRegistryIsRegisteredRequest
 *
 * @param moduleAddress address
 *//**
 * contract ModuleRegistry readonly method
 */var ModuleRegistryReadOnlyClient=/*#__PURE__*/function(){function ModuleRegistryReadOnlyClient(rpcClient,address){var _rpcClient$chain15;_classCallCheck(this,ModuleRegistryReadOnlyClient);this.address=address||getAddress(moduleRegistryAddress,(_rpcClient$chain15=rpcClient.chain)===null||_rpcClient$chain15===void 0?void 0:_rpcClient$chain15.id);this.rpcClient=rpcClient;}/**
   * method isRegistered for contract ModuleRegistry
   *
   * @param request ModuleRegistryIsRegisteredRequest
   * @return Promise<ModuleRegistryIsRegisteredResponse>
   */return _createClass(ModuleRegistryReadOnlyClient,[{key:"isRegistered",value:(function(){var _isRegistered2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee105(request){return _regeneratorRuntime().wrap(function _callee105$(_context105){while(1)switch(_context105.prev=_context105.next){case 0:_context105.next=2;return this.rpcClient.readContract({abi:moduleRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.moduleAddress]});case 2:return _context105.abrupt("return",_context105.sent);case 3:case"end":return _context105.stop();}},_callee105,this);}));function isRegistered(_x79){return _isRegistered2.apply(this,arguments);}return isRegistered;}())}]);}();// Contract Multicall3 =============================================================
/**
 * Multicall3Aggregate3Request
 *
 * @param calls tuple[]
 *//**
 * contract Multicall3 write method
 */var Multicall3Client=/*#__PURE__*/function(){function Multicall3Client(rpcClient,wallet,address){var _rpcClient$chain16;_classCallCheck(this,Multicall3Client);this.address=address||getAddress(multicall3Address,(_rpcClient$chain16=rpcClient.chain)===null||_rpcClient$chain16===void 0?void 0:_rpcClient$chain16.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method aggregate3 for contract Multicall3
   *
   * @param request Multicall3Aggregate3Request
   * @return Promise<WriteContractReturnType>
   */return _createClass(Multicall3Client,[{key:"aggregate3",value:(function(){var _aggregate=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee106(request){var _yield$this$rpcClient57,call;return _regeneratorRuntime().wrap(function _callee106$(_context106){while(1)switch(_context106.prev=_context106.next){case 0:_context106.next=2;return this.rpcClient.simulateContract({abi:multicall3Abi,address:this.address,functionName:"aggregate3",account:this.wallet.account,args:[request.calls]});case 2:_yield$this$rpcClient57=_context106.sent;call=_yield$this$rpcClient57.request;_context106.next=6;return this.wallet.writeContract(call);case 6:return _context106.abrupt("return",_context106.sent);case 7:case"end":return _context106.stop();}},_callee106,this);}));function aggregate3(_x80){return _aggregate.apply(this,arguments);}return aggregate3;}()/**
   * method aggregate3 for contract Multicall3 with only encode
   *
   * @param request Multicall3Aggregate3Request
   * @return EncodedTxData
   */)},{key:"aggregate3Encode",value:function aggregate3Encode(request){return {to:this.address,data:encodeFunctionData({abi:multicall3Abi,functionName:"aggregate3",args:[request.calls]})};}}]);}();// Contract PILicenseTemplate =============================================================
/**
 * PiLicenseTemplateAuthorityUpdatedEvent
 *
 * @param authority address
 *//**
 * PiLicenseTemplateDerivativeApprovedEvent
 *
 * @param licenseTermsId uint256
 * @param ipId address
 * @param caller address
 * @param approved bool
 *//**
 * PiLicenseTemplateInitializedEvent
 *
 * @param version uint64
 *//**
 * PiLicenseTemplateLicenseTermsRegisteredEvent
 *
 * @param licenseTermsId uint256
 * @param licenseTemplate address
 * @param licenseTerms bytes
 *//**
 * PiLicenseTemplateUpgradedEvent
 *
 * @param implementation address
 *//**
 * PiLicenseTemplateAllowDerivativeRegistrationRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateCanAttachToGroupIpRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateCanOverrideRoyaltyPercentRequest
 *
 * @param licenseTermsId uint256
 * @param newRoyaltyPercent uint32
 *//**
 * PiLicenseTemplateExistsRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetEarlierExpireTimeRequest
 *
 * @param licenseTermsIds uint256[]
 * @param start uint256
 *//**
 * PiLicenseTemplateGetExpireTimeRequest
 *
 * @param licenseTermsId uint256
 * @param start uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsRequest
 *
 * @param selectedLicenseTermsId uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsResponse
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateGetLicenseTermsIdRequest
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateGetLicenseTermsIdResponse
 *
 * @param selectedLicenseTermsId uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsUriRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetRoyaltyPolicyRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetRoyaltyPolicyResponse
 *
 * @param royaltyPolicy address
 * @param royaltyPercent uint32
 * @param mintingFee uint256
 * @param currency address
 *//**
 * PiLicenseTemplateIsDerivativeApprovedRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 *//**
 * PiLicenseTemplateIsLicenseTransferableRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 *//**
 * PiLicenseTemplateToJsonRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateVerifyCompatibleLicensesRequest
 *
 * @param licenseTermsIds uint256[]
 *//**
 * PiLicenseTemplateInitializeRequest
 *
 * @param accessManager address
 * @param name string
 * @param metadataURI string
 *//**
 * PiLicenseTemplateRegisterLicenseTermsRequest
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateSetApprovalRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 * @param approved bool
 *//**
 * PiLicenseTemplateSetAuthorityRequest
 *
 * @param newAuthority address
 *//**
 * PiLicenseTemplateUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 *//**
 * PiLicenseTemplateVerifyMintLicenseTokenRequest
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 address
 * @param 3 uint256
 *//**
 * PiLicenseTemplateVerifyRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param licensee address
 *//**
 * PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param caller address
 *//**
 * contract PILicenseTemplate event
 */var PiLicenseTemplateEventClient=/*#__PURE__*/function(){function PiLicenseTemplateEventClient(rpcClient,address){var _rpcClient$chain17;_classCallCheck(this,PiLicenseTemplateEventClient);this.address=address||getAddress(piLicenseTemplateAddress,(_rpcClient$chain17=rpcClient.chain)===null||_rpcClient$chain17===void 0?void 0:_rpcClient$chain17.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract PILicenseTemplate
   */return _createClass(PiLicenseTemplateEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs22){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs22(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract PILicenseTemplate
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator22=_createForOfIteratorHelper(txReceipt.logs),_step22;try{for(_iterator22.s();!(_step22=_iterator22.n()).done;){var log=_step22.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}return targetLogs;}/**
   * event DerivativeApproved for contract PILicenseTemplate
   */},{key:"watchDerivativeApprovedEvent",value:function watchDerivativeApprovedEvent(_onLogs23){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"DerivativeApproved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs23(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DerivativeApproved for contract PILicenseTemplate
   */},{key:"parseTxDerivativeApprovedEvent",value:function parseTxDerivativeApprovedEvent(txReceipt){var targetLogs=[];var _iterator23=_createForOfIteratorHelper(txReceipt.logs),_step23;try{for(_iterator23.s();!(_step23=_iterator23.n()).done;){var log=_step23.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"DerivativeApproved",data:log.data,topics:log.topics});if(event.eventName==="DerivativeApproved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}return targetLogs;}/**
   * event Initialized for contract PILicenseTemplate
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs24){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs24(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract PILicenseTemplate
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator24=_createForOfIteratorHelper(txReceipt.logs),_step24;try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){var log=_step24.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}return targetLogs;}/**
   * event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"watchLicenseTermsRegisteredEvent",value:function watchLicenseTermsRegisteredEvent(_onLogs25){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"LicenseTermsRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs25(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"parseTxLicenseTermsRegisteredEvent",value:function parseTxLicenseTermsRegisteredEvent(txReceipt){var targetLogs=[];var _iterator25=_createForOfIteratorHelper(txReceipt.logs),_step25;try{for(_iterator25.s();!(_step25=_iterator25.n()).done;){var log=_step25.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"LicenseTermsRegistered",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator25.e(err);}finally{_iterator25.f();}return targetLogs;}/**
   * event Upgraded for contract PILicenseTemplate
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs26){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs26(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract PILicenseTemplate
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator26=_createForOfIteratorHelper(txReceipt.logs),_step26;try{for(_iterator26.s();!(_step26=_iterator26.n()).done;){var log=_step26.value;try{var event=decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator26.e(err);}finally{_iterator26.f();}return targetLogs;}}]);}();/**
 * contract PILicenseTemplate readonly method
 */var PiLicenseTemplateReadOnlyClient=/*#__PURE__*/function(_PiLicenseTemplateEve){function PiLicenseTemplateReadOnlyClient(rpcClient,address){_classCallCheck(this,PiLicenseTemplateReadOnlyClient);return _callSuper(this,PiLicenseTemplateReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAccessControllerRequest
   * @return Promise<PiLicenseTemplateAccessControllerResponse>
   */_inherits(PiLicenseTemplateReadOnlyClient,_PiLicenseTemplateEve);return _createClass(PiLicenseTemplateReadOnlyClient,[{key:"accessController",value:(function(){var _accessController2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee107(){return _regeneratorRuntime().wrap(function _callee107$(_context107){while(1)switch(_context107.prev=_context107.next){case 0:_context107.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 2:return _context107.abrupt("return",_context107.sent);case 3:case"end":return _context107.stop();}},_callee107,this);}));function accessController(){return _accessController2.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIpAssetRegistryRequest
   * @return Promise<PiLicenseTemplateIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee108(){return _regeneratorRuntime().wrap(function _callee108$(_context108){while(1)switch(_context108.prev=_context108.next){case 0:_context108.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 2:return _context108.abrupt("return",_context108.sent);case 3:case"end":return _context108.stop();}},_callee108,this);}));function ipAssetRegistry(){return _ipAssetRegistry2.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method LICENSE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateLicenseRegistryRequest
   * @return Promise<PiLicenseTemplateLicenseRegistryResponse>
   */)},{key:"licenseRegistry",value:(function(){var _licenseRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee109(){return _regeneratorRuntime().wrap(function _callee109$(_context109){while(1)switch(_context109.prev=_context109.next){case 0:_context109.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"LICENSE_REGISTRY"});case 2:return _context109.abrupt("return",_context109.sent);case 3:case"end":return _context109.stop();}},_callee109,this);}));function licenseRegistry(){return _licenseRegistry.apply(this,arguments);}return licenseRegistry;}()/**
   * method MODULE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateModuleRegistryRequest
   * @return Promise<PiLicenseTemplateModuleRegistryResponse>
   */)},{key:"moduleRegistry",value:(function(){var _moduleRegistry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee110(){return _regeneratorRuntime().wrap(function _callee110$(_context110){while(1)switch(_context110.prev=_context110.next){case 0:_context110.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"MODULE_REGISTRY"});case 2:return _context110.abrupt("return",_context110.sent);case 3:case"end":return _context110.stop();}},_callee110,this);}));function moduleRegistry(){return _moduleRegistry.apply(this,arguments);}return moduleRegistry;}()/**
   * method ROYALTY_MODULE for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRoyaltyModuleRequest
   * @return Promise<PiLicenseTemplateRoyaltyModuleResponse>
   */)},{key:"royaltyModule",value:(function(){var _royaltyModule2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee111(){return _regeneratorRuntime().wrap(function _callee111$(_context111){while(1)switch(_context111.prev=_context111.next){case 0:_context111.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ROYALTY_MODULE"});case 2:return _context111.abrupt("return",_context111.sent);case 3:case"end":return _context111.stop();}},_callee111,this);}));function royaltyModule(){return _royaltyModule2.apply(this,arguments);}return royaltyModule;}()/**
   * method TERMS_RENDERER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTermsRendererRequest
   * @return Promise<PiLicenseTemplateTermsRendererResponse>
   */)},{key:"termsRenderer",value:(function(){var _termsRenderer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee112(){return _regeneratorRuntime().wrap(function _callee112$(_context112){while(1)switch(_context112.prev=_context112.next){case 0:_context112.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"TERMS_RENDERER"});case 2:return _context112.abrupt("return",_context112.sent);case 3:case"end":return _context112.stop();}},_callee112,this);}));function termsRenderer(){return _termsRenderer.apply(this,arguments);}return termsRenderer;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeInterfaceVersionRequest
   * @return Promise<PiLicenseTemplateUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee113(){return _regeneratorRuntime().wrap(function _callee113$(_context113){while(1)switch(_context113.prev=_context113.next){case 0:_context113.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 2:return _context113.abrupt("return",_context113.sent);case 3:case"end":return _context113.stop();}},_callee113,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion3.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method allowDerivativeRegistration for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAllowDerivativeRegistrationRequest
   * @return Promise<PiLicenseTemplateAllowDerivativeRegistrationResponse>
   */)},{key:"allowDerivativeRegistration",value:(function(){var _allowDerivativeRegistration=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee114(request){return _regeneratorRuntime().wrap(function _callee114$(_context114){while(1)switch(_context114.prev=_context114.next){case 0:_context114.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"allowDerivativeRegistration",args:[request.licenseTermsId]});case 2:return _context114.abrupt("return",_context114.sent);case 3:case"end":return _context114.stop();}},_callee114,this);}));function allowDerivativeRegistration(_x81){return _allowDerivativeRegistration.apply(this,arguments);}return allowDerivativeRegistration;}()/**
   * method authority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAuthorityRequest
   * @return Promise<PiLicenseTemplateAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee115(){return _regeneratorRuntime().wrap(function _callee115$(_context115){while(1)switch(_context115.prev=_context115.next){case 0:_context115.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"authority"});case 2:return _context115.abrupt("return",_context115.sent);case 3:case"end":return _context115.stop();}},_callee115,this);}));function authority(){return _authority3.apply(this,arguments);}return authority;}()/**
   * method canAttachToGroupIp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanAttachToGroupIpRequest
   * @return Promise<PiLicenseTemplateCanAttachToGroupIpResponse>
   */)},{key:"canAttachToGroupIp",value:(function(){var _canAttachToGroupIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee116(request){return _regeneratorRuntime().wrap(function _callee116$(_context116){while(1)switch(_context116.prev=_context116.next){case 0:_context116.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canAttachToGroupIp",args:[request.licenseTermsId]});case 2:return _context116.abrupt("return",_context116.sent);case 3:case"end":return _context116.stop();}},_callee116,this);}));function canAttachToGroupIp(_x82){return _canAttachToGroupIp.apply(this,arguments);}return canAttachToGroupIp;}()/**
   * method canOverrideRoyaltyPercent for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanOverrideRoyaltyPercentRequest
   * @return Promise<PiLicenseTemplateCanOverrideRoyaltyPercentResponse>
   */)},{key:"canOverrideRoyaltyPercent",value:(function(){var _canOverrideRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee117(request){return _regeneratorRuntime().wrap(function _callee117$(_context117){while(1)switch(_context117.prev=_context117.next){case 0:_context117.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canOverrideRoyaltyPercent",args:[request.licenseTermsId,request.newRoyaltyPercent]});case 2:return _context117.abrupt("return",_context117.sent);case 3:case"end":return _context117.stop();}},_callee117,this);}));function canOverrideRoyaltyPercent(_x83){return _canOverrideRoyaltyPercent.apply(this,arguments);}return canOverrideRoyaltyPercent;}()/**
   * method exists for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateExistsRequest
   * @return Promise<PiLicenseTemplateExistsResponse>
   */)},{key:"exists",value:(function(){var _exists=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee118(request){return _regeneratorRuntime().wrap(function _callee118$(_context118){while(1)switch(_context118.prev=_context118.next){case 0:_context118.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"exists",args:[request.licenseTermsId]});case 2:return _context118.abrupt("return",_context118.sent);case 3:case"end":return _context118.stop();}},_callee118,this);}));function exists(_x84){return _exists.apply(this,arguments);}return exists;}()/**
   * method getEarlierExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetEarlierExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetEarlierExpireTimeResponse>
   */)},{key:"getEarlierExpireTime",value:(function(){var _getEarlierExpireTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee119(request){return _regeneratorRuntime().wrap(function _callee119$(_context119){while(1)switch(_context119.prev=_context119.next){case 0:_context119.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getEarlierExpireTime",args:[request.licenseTermsIds,request.start]});case 2:return _context119.abrupt("return",_context119.sent);case 3:case"end":return _context119.stop();}},_callee119,this);}));function getEarlierExpireTime(_x85){return _getEarlierExpireTime.apply(this,arguments);}return getEarlierExpireTime;}()/**
   * method getExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetExpireTimeResponse>
   */)},{key:"getExpireTime",value:(function(){var _getExpireTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee120(request){return _regeneratorRuntime().wrap(function _callee120$(_context120){while(1)switch(_context120.prev=_context120.next){case 0:_context120.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getExpireTime",args:[request.licenseTermsId,request.start]});case 2:return _context120.abrupt("return",_context120.sent);case 3:case"end":return _context120.stop();}},_callee120,this);}));function getExpireTime(_x86){return _getExpireTime.apply(this,arguments);}return getExpireTime;}()/**
   * method getLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsResponse>
   */)},{key:"getLicenseTerms",value:(function(){var _getLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee121(request){var result;return _regeneratorRuntime().wrap(function _callee121$(_context121){while(1)switch(_context121.prev=_context121.next){case 0:_context121.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTerms",args:[request.selectedLicenseTermsId]});case 2:result=_context121.sent;return _context121.abrupt("return",{terms:result});case 4:case"end":return _context121.stop();}},_callee121,this);}));function getLicenseTerms(_x87){return _getLicenseTerms.apply(this,arguments);}return getLicenseTerms;}()/**
   * method getLicenseTermsId for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsIdRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsIdResponse>
   */)},{key:"getLicenseTermsId",value:(function(){var _getLicenseTermsId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee122(request){var result;return _regeneratorRuntime().wrap(function _callee122$(_context122){while(1)switch(_context122.prev=_context122.next){case 0:_context122.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsId",args:[request.terms]});case 2:result=_context122.sent;return _context122.abrupt("return",{selectedLicenseTermsId:result});case 4:case"end":return _context122.stop();}},_callee122,this);}));function getLicenseTermsId(_x88){return _getLicenseTermsId.apply(this,arguments);}return getLicenseTermsId;}()/**
   * method getLicenseTermsURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsUriRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsUriResponse>
   */)},{key:"getLicenseTermsUri",value:(function(){var _getLicenseTermsUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee123(request){return _regeneratorRuntime().wrap(function _callee123$(_context123){while(1)switch(_context123.prev=_context123.next){case 0:_context123.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsURI",args:[request.licenseTermsId]});case 2:return _context123.abrupt("return",_context123.sent);case 3:case"end":return _context123.stop();}},_callee123,this);}));function getLicenseTermsUri(_x89){return _getLicenseTermsUri.apply(this,arguments);}return getLicenseTermsUri;}()/**
   * method getMetadataURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetMetadataUriRequest
   * @return Promise<PiLicenseTemplateGetMetadataUriResponse>
   */)},{key:"getMetadataUri",value:(function(){var _getMetadataUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee124(){return _regeneratorRuntime().wrap(function _callee124$(_context124){while(1)switch(_context124.prev=_context124.next){case 0:_context124.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getMetadataURI"});case 2:return _context124.abrupt("return",_context124.sent);case 3:case"end":return _context124.stop();}},_callee124,this);}));function getMetadataUri(){return _getMetadataUri.apply(this,arguments);}return getMetadataUri;}()/**
   * method getRoyaltyPolicy for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetRoyaltyPolicyRequest
   * @return Promise<PiLicenseTemplateGetRoyaltyPolicyResponse>
   */)},{key:"getRoyaltyPolicy",value:(function(){var _getRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee125(request){var result;return _regeneratorRuntime().wrap(function _callee125$(_context125){while(1)switch(_context125.prev=_context125.next){case 0:_context125.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getRoyaltyPolicy",args:[request.licenseTermsId]});case 2:result=_context125.sent;return _context125.abrupt("return",{royaltyPolicy:result[0],royaltyPercent:result[1],mintingFee:result[2],currency:result[3]});case 4:case"end":return _context125.stop();}},_callee125,this);}));function getRoyaltyPolicy(_x90){return _getRoyaltyPolicy.apply(this,arguments);}return getRoyaltyPolicy;}()/**
   * method isConsumingScheduledOp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsConsumingScheduledOpRequest
   * @return Promise<PiLicenseTemplateIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee126(){return _regeneratorRuntime().wrap(function _callee126$(_context126){while(1)switch(_context126.prev=_context126.next){case 0:_context126.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 2:return _context126.abrupt("return",_context126.sent);case 3:case"end":return _context126.stop();}},_callee126,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp3.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isDerivativeApproved for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsDerivativeApprovedRequest
   * @return Promise<PiLicenseTemplateIsDerivativeApprovedResponse>
   */)},{key:"isDerivativeApproved",value:(function(){var _isDerivativeApproved=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee127(request){return _regeneratorRuntime().wrap(function _callee127$(_context127){while(1)switch(_context127.prev=_context127.next){case 0:_context127.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isDerivativeApproved",args:[request.parentIpId,request.licenseTermsId,request.childIpId]});case 2:return _context127.abrupt("return",_context127.sent);case 3:case"end":return _context127.stop();}},_callee127,this);}));function isDerivativeApproved(_x91){return _isDerivativeApproved.apply(this,arguments);}return isDerivativeApproved;}()/**
   * method isLicenseTransferable for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsLicenseTransferableRequest
   * @return Promise<PiLicenseTemplateIsLicenseTransferableResponse>
   */)},{key:"isLicenseTransferable",value:(function(){var _isLicenseTransferable=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee128(request){return _regeneratorRuntime().wrap(function _callee128$(_context128){while(1)switch(_context128.prev=_context128.next){case 0:_context128.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isLicenseTransferable",args:[request.licenseTermsId]});case 2:return _context128.abrupt("return",_context128.sent);case 3:case"end":return _context128.stop();}},_callee128,this);}));function isLicenseTransferable(_x92){return _isLicenseTransferable.apply(this,arguments);}return isLicenseTransferable;}()/**
   * method name for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateNameRequest
   * @return Promise<PiLicenseTemplateNameResponse>
   */)},{key:"name",value:(function(){var _name2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee129(){return _regeneratorRuntime().wrap(function _callee129$(_context129){while(1)switch(_context129.prev=_context129.next){case 0:_context129.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"name"});case 2:return _context129.abrupt("return",_context129.sent);case 3:case"end":return _context129.stop();}},_callee129,this);}));function name(){return _name2.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateProxiableUuidRequest
   * @return Promise<PiLicenseTemplateProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee130(){return _regeneratorRuntime().wrap(function _callee130$(_context130){while(1)switch(_context130.prev=_context130.next){case 0:_context130.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"proxiableUUID"});case 2:return _context130.abrupt("return",_context130.sent);case 3:case"end":return _context130.stop();}},_callee130,this);}));function proxiableUuid(){return _proxiableUuid3.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSupportsInterfaceRequest
   * @return Promise<PiLicenseTemplateSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee131(request){return _regeneratorRuntime().wrap(function _callee131$(_context131){while(1)switch(_context131.prev=_context131.next){case 0:_context131.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 2:return _context131.abrupt("return",_context131.sent);case 3:case"end":return _context131.stop();}},_callee131,this);}));function supportsInterface(_x93){return _supportsInterface2.apply(this,arguments);}return supportsInterface;}()/**
   * method toJson for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateToJsonRequest
   * @return Promise<PiLicenseTemplateToJsonResponse>
   */)},{key:"toJson",value:(function(){var _toJson=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee132(request){return _regeneratorRuntime().wrap(function _callee132$(_context132){while(1)switch(_context132.prev=_context132.next){case 0:_context132.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"toJson",args:[request.licenseTermsId]});case 2:return _context132.abrupt("return",_context132.sent);case 3:case"end":return _context132.stop();}},_callee132,this);}));function toJson(_x94){return _toJson.apply(this,arguments);}return toJson;}()/**
   * method totalRegisteredLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTotalRegisteredLicenseTermsRequest
   * @return Promise<PiLicenseTemplateTotalRegisteredLicenseTermsResponse>
   */)},{key:"totalRegisteredLicenseTerms",value:(function(){var _totalRegisteredLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee133(){return _regeneratorRuntime().wrap(function _callee133$(_context133){while(1)switch(_context133.prev=_context133.next){case 0:_context133.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"totalRegisteredLicenseTerms"});case 2:return _context133.abrupt("return",_context133.sent);case 3:case"end":return _context133.stop();}},_callee133,this);}));function totalRegisteredLicenseTerms(){return _totalRegisteredLicenseTerms.apply(this,arguments);}return totalRegisteredLicenseTerms;}()/**
   * method verifyCompatibleLicenses for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyCompatibleLicensesRequest
   * @return Promise<PiLicenseTemplateVerifyCompatibleLicensesResponse>
   */)},{key:"verifyCompatibleLicenses",value:(function(){var _verifyCompatibleLicenses=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee134(request){return _regeneratorRuntime().wrap(function _callee134$(_context134){while(1)switch(_context134.prev=_context134.next){case 0:_context134.next=2;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyCompatibleLicenses",args:[request.licenseTermsIds]});case 2:return _context134.abrupt("return",_context134.sent);case 3:case"end":return _context134.stop();}},_callee134,this);}));function verifyCompatibleLicenses(_x95){return _verifyCompatibleLicenses.apply(this,arguments);}return verifyCompatibleLicenses;}())}]);}(PiLicenseTemplateEventClient);/**
 * contract PILicenseTemplate write method
 */var PiLicenseTemplateClient=/*#__PURE__*/function(_PiLicenseTemplateRea){function PiLicenseTemplateClient(rpcClient,wallet,address){var _this1;_classCallCheck(this,PiLicenseTemplateClient);_this1=_callSuper(this,PiLicenseTemplateClient,[rpcClient,address]);_this1.wallet=wallet;return _this1;}/**
   * method initialize for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(PiLicenseTemplateClient,_PiLicenseTemplateRea);return _createClass(PiLicenseTemplateClient,[{key:"initialize",value:(function(){var _initialize3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee135(request){var _yield$this$rpcClient58,call;return _regeneratorRuntime().wrap(function _callee135$(_context135){while(1)switch(_context135.prev=_context135.next){case 0:_context135.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager,request.name,request.metadataURI]});case 2:_yield$this$rpcClient58=_context135.sent;call=_yield$this$rpcClient58.request;_context135.next=6;return this.wallet.writeContract(call);case 6:return _context135.abrupt("return",_context135.sent);case 7:case"end":return _context135.stop();}},_callee135,this);}));function initialize(_x96){return _initialize3.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"initialize",args:[request.accessManager,request.name,request.metadataURI]})};}/**
   * method registerLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerLicenseTerms",value:(function(){var _registerLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee136(request){var _yield$this$rpcClient59,call;return _regeneratorRuntime().wrap(function _callee136$(_context136){while(1)switch(_context136.prev=_context136.next){case 0:_context136.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"registerLicenseTerms",account:this.wallet.account,args:[request.terms]});case 2:_yield$this$rpcClient59=_context136.sent;call=_yield$this$rpcClient59.request;_context136.next=6;return this.wallet.writeContract(call);case 6:return _context136.abrupt("return",_context136.sent);case 7:case"end":return _context136.stop();}},_callee136,this);}));function registerLicenseTerms(_x97){return _registerLicenseTerms.apply(this,arguments);}return registerLicenseTerms;}()/**
   * method registerLicenseTerms for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"registerLicenseTermsEncode",value:function registerLicenseTermsEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"registerLicenseTerms",args:[request.terms]})};}/**
   * method setApproval for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setApproval",value:(function(){var _setApproval=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee137(request){var _yield$this$rpcClient60,call;return _regeneratorRuntime().wrap(function _callee137$(_context137){while(1)switch(_context137.prev=_context137.next){case 0:_context137.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setApproval",account:this.wallet.account,args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]});case 2:_yield$this$rpcClient60=_context137.sent;call=_yield$this$rpcClient60.request;_context137.next=6;return this.wallet.writeContract(call);case 6:return _context137.abrupt("return",_context137.sent);case 7:case"end":return _context137.stop();}},_callee137,this);}));function setApproval(_x98){return _setApproval.apply(this,arguments);}return setApproval;}()/**
   * method setApproval for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return EncodedTxData
   */)},{key:"setApprovalEncode",value:function setApprovalEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setApproval",args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]})};}/**
   * method setAuthority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee138(request){var _yield$this$rpcClient61,call;return _regeneratorRuntime().wrap(function _callee138$(_context138){while(1)switch(_context138.prev=_context138.next){case 0:_context138.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 2:_yield$this$rpcClient61=_context138.sent;call=_yield$this$rpcClient61.request;_context138.next=6;return this.wallet.writeContract(call);case 6:return _context138.abrupt("return",_context138.sent);case 7:case"end":return _context138.stop();}},_callee138,this);}));function setAuthority(_x99){return _setAuthority3.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method upgradeToAndCall for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee139(request){var _yield$this$rpcClient62,call;return _regeneratorRuntime().wrap(function _callee139$(_context139){while(1)switch(_context139.prev=_context139.next){case 0:_context139.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 2:_yield$this$rpcClient62=_context139.sent;call=_yield$this$rpcClient62.request;_context139.next=6;return this.wallet.writeContract(call);case 6:return _context139.abrupt("return",_context139.sent);case 7:case"end":return _context139.stop();}},_callee139,this);}));function upgradeToAndCall(_x100){return _upgradeToAndCall3.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}/**
   * method verifyMintLicenseToken for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyMintLicenseToken",value:(function(){var _verifyMintLicenseToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee140(request){var _yield$this$rpcClient63,call;return _regeneratorRuntime().wrap(function _callee140$(_context140){while(1)switch(_context140.prev=_context140.next){case 0:_context140.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyMintLicenseToken",account:this.wallet.account,args:[request[0],request[1],request[2],request[3]]});case 2:_yield$this$rpcClient63=_context140.sent;call=_yield$this$rpcClient63.request;_context140.next=6;return this.wallet.writeContract(call);case 6:return _context140.abrupt("return",_context140.sent);case 7:case"end":return _context140.stop();}},_callee140,this);}));function verifyMintLicenseToken(_x101){return _verifyMintLicenseToken.apply(this,arguments);}return verifyMintLicenseToken;}()/**
   * method verifyMintLicenseToken for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return EncodedTxData
   */)},{key:"verifyMintLicenseTokenEncode",value:function verifyMintLicenseTokenEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyMintLicenseToken",args:[request[0],request[1],request[2],request[3]]})};}/**
   * method verifyRegisterDerivative for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivative",value:(function(){var _verifyRegisterDerivative=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee141(request){var _yield$this$rpcClient64,call;return _regeneratorRuntime().wrap(function _callee141$(_context141){while(1)switch(_context141.prev=_context141.next){case 0:_context141.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]});case 2:_yield$this$rpcClient64=_context141.sent;call=_yield$this$rpcClient64.request;_context141.next=6;return this.wallet.writeContract(call);case 6:return _context141.abrupt("return",_context141.sent);case 7:case"end":return _context141.stop();}},_callee141,this);}));function verifyRegisterDerivative(_x102){return _verifyRegisterDerivative.apply(this,arguments);}return verifyRegisterDerivative;}()/**
   * method verifyRegisterDerivative for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeEncode",value:function verifyRegisterDerivativeEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivative",args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]})};}/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivativeForAllParents",value:(function(){var _verifyRegisterDerivativeForAllParents=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee142(request){var _yield$this$rpcClient65,call;return _regeneratorRuntime().wrap(function _callee142$(_context142){while(1)switch(_context142.prev=_context142.next){case 0:_context142.next=2;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivativeForAllParents",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]});case 2:_yield$this$rpcClient65=_context142.sent;call=_yield$this$rpcClient65.request;_context142.next=6;return this.wallet.writeContract(call);case 6:return _context142.abrupt("return",_context142.sent);case 7:case"end":return _context142.stop();}},_callee142,this);}));function verifyRegisterDerivativeForAllParents(_x103){return _verifyRegisterDerivativeForAllParents.apply(this,arguments);}return verifyRegisterDerivativeForAllParents;}()/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeForAllParentsEncode",value:function verifyRegisterDerivativeForAllParentsEncode(request){return {to:this.address,data:encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivativeForAllParents",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]})};}}]);}(PiLicenseTemplateReadOnlyClient);// Contract RegistrationWorkflows =============================================================
/**
 * RegistrationWorkflowsCollectionCreatedEvent
 *
 * @param spgNftContract address
 *//**
 * RegistrationWorkflowsCreateCollectionRequest
 *
 * @param spgNftInitParams tuple
 *//**
 * RegistrationWorkflowsMintAndRegisterIpRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param allowDuplicates bool
 *//**
 * RegistrationWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * RegistrationWorkflowsRegisterIpRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 *//**
 * contract RegistrationWorkflows event
 */var RegistrationWorkflowsEventClient=/*#__PURE__*/function(){function RegistrationWorkflowsEventClient(rpcClient,address){var _rpcClient$chain18;_classCallCheck(this,RegistrationWorkflowsEventClient);this.address=address||getAddress(registrationWorkflowsAddress,(_rpcClient$chain18=rpcClient.chain)===null||_rpcClient$chain18===void 0?void 0:_rpcClient$chain18.id);this.rpcClient=rpcClient;}/**
   * event CollectionCreated for contract RegistrationWorkflows
   */return _createClass(RegistrationWorkflowsEventClient,[{key:"watchCollectionCreatedEvent",value:function watchCollectionCreatedEvent(_onLogs27){return this.rpcClient.watchContractEvent({abi:registrationWorkflowsAbi,address:this.address,eventName:"CollectionCreated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs27(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectionCreated for contract RegistrationWorkflows
   */},{key:"parseTxCollectionCreatedEvent",value:function parseTxCollectionCreatedEvent(txReceipt){var targetLogs=[];var _iterator27=_createForOfIteratorHelper(txReceipt.logs),_step27;try{for(_iterator27.s();!(_step27=_iterator27.n()).done;){var log=_step27.value;try{var event=decodeEventLog({abi:registrationWorkflowsAbi,eventName:"CollectionCreated",data:log.data,topics:log.topics});if(event.eventName==="CollectionCreated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator27.e(err);}finally{_iterator27.f();}return targetLogs;}}]);}();/**
 * contract RegistrationWorkflows write method
 */var RegistrationWorkflowsClient=/*#__PURE__*/function(_RegistrationWorkflow){function RegistrationWorkflowsClient(rpcClient,wallet,address){var _this10;_classCallCheck(this,RegistrationWorkflowsClient);_this10=_callSuper(this,RegistrationWorkflowsClient,[rpcClient,address]);_this10.wallet=wallet;return _this10;}/**
   * method createCollection for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RegistrationWorkflowsClient,_RegistrationWorkflow);return _createClass(RegistrationWorkflowsClient,[{key:"createCollection",value:(function(){var _createCollection=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee143(request){var _yield$this$rpcClient66,call;return _regeneratorRuntime().wrap(function _callee143$(_context143){while(1)switch(_context143.prev=_context143.next){case 0:_context143.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"createCollection",account:this.wallet.account,args:[request.spgNftInitParams]});case 2:_yield$this$rpcClient66=_context143.sent;call=_yield$this$rpcClient66.request;_context143.next=6;return this.wallet.writeContract(call);case 6:return _context143.abrupt("return",_context143.sent);case 7:case"end":return _context143.stop();}},_callee143,this);}));function createCollection(_x104){return _createCollection.apply(this,arguments);}return createCollection;}()/**
   * method createCollection for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return EncodedTxData
   */)},{key:"createCollectionEncode",value:function createCollectionEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"createCollection",args:[request.spgNftInitParams]})};}/**
   * method mintAndRegisterIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIp",value:(function(){var _mintAndRegisterIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee144(request){var _yield$this$rpcClient67,call;return _regeneratorRuntime().wrap(function _callee144$(_context144){while(1)switch(_context144.prev=_context144.next){case 0:_context144.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIp",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]});case 2:_yield$this$rpcClient67=_context144.sent;call=_yield$this$rpcClient67.request;_context144.next=6;return this.wallet.writeContract(call);case 6:return _context144.abrupt("return",_context144.sent);case 7:case"end":return _context144.stop();}},_callee144,this);}));function mintAndRegisterIp(_x105){return _mintAndRegisterIp.apply(this,arguments);}return mintAndRegisterIp;}()/**
   * method mintAndRegisterIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpEncode",value:function mintAndRegisterIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"mintAndRegisterIp",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]})};}/**
   * method multicall for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee145(request){var _yield$this$rpcClient68,call;return _regeneratorRuntime().wrap(function _callee145$(_context145){while(1)switch(_context145.prev=_context145.next){case 0:_context145.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient68=_context145.sent;call=_yield$this$rpcClient68.request;_context145.next=6;return this.wallet.writeContract(call);case 6:return _context145.abrupt("return",_context145.sent);case 7:case"end":return _context145.stop();}},_callee145,this);}));function multicall(_x106){return _multicall3.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIp",value:(function(){var _registerIp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee146(request){var _yield$this$rpcClient69,call;return _regeneratorRuntime().wrap(function _callee146$(_context146){while(1)switch(_context146.prev=_context146.next){case 0:_context146.next=2;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"registerIp",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]});case 2:_yield$this$rpcClient69=_context146.sent;call=_yield$this$rpcClient69.request;_context146.next=6;return this.wallet.writeContract(call);case 6:return _context146.abrupt("return",_context146.sent);case 7:case"end":return _context146.stop();}},_callee146,this);}));function registerIp(_x107){return _registerIp.apply(this,arguments);}return registerIp;}()/**
   * method registerIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"registerIpEncode",value:function registerIpEncode(request){return {to:this.address,data:encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"registerIp",args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]})};}}]);}(RegistrationWorkflowsEventClient);// Contract RoyaltyModule =============================================================
/**
 * RoyaltyModuleIpRoyaltyVaultDeployedEvent
 *
 * @param ipId address
 * @param ipRoyaltyVault address
 *//**
 * RoyaltyModuleRoyaltyPaidEvent
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param sender address
 * @param token address
 * @param amount uint256
 * @param amountAfterFee uint256
 *//**
 * RoyaltyModuleIpRoyaltyVaultsRequest
 *
 * @param ipId address
 *//**
 * RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
 *
 * @param royaltyPolicy address
 *//**
 * RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
 *
 * @param token address
 *//**
 * RoyaltyModulePayRoyaltyOnBehalfRequest
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param token address
 * @param amount uint256
 *//**
 * contract RoyaltyModule event
 */var RoyaltyModuleEventClient=/*#__PURE__*/function(){function RoyaltyModuleEventClient(rpcClient,address){var _rpcClient$chain19;_classCallCheck(this,RoyaltyModuleEventClient);this.address=address||getAddress(royaltyModuleAddress,(_rpcClient$chain19=rpcClient.chain)===null||_rpcClient$chain19===void 0?void 0:_rpcClient$chain19.id);this.rpcClient=rpcClient;}/**
   * event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */return _createClass(RoyaltyModuleEventClient,[{key:"watchIpRoyaltyVaultDeployedEvent",value:function watchIpRoyaltyVaultDeployedEvent(_onLogs28){return this.rpcClient.watchContractEvent({abi:royaltyModuleAbi,address:this.address,eventName:"IpRoyaltyVaultDeployed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs28(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */},{key:"parseTxIpRoyaltyVaultDeployedEvent",value:function parseTxIpRoyaltyVaultDeployedEvent(txReceipt){var targetLogs=[];var _iterator28=_createForOfIteratorHelper(txReceipt.logs),_step28;try{for(_iterator28.s();!(_step28=_iterator28.n()).done;){var log=_step28.value;try{var event=decodeEventLog({abi:royaltyModuleAbi,eventName:"IpRoyaltyVaultDeployed",data:log.data,topics:log.topics});if(event.eventName==="IpRoyaltyVaultDeployed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator28.e(err);}finally{_iterator28.f();}return targetLogs;}/**
   * event RoyaltyPaid for contract RoyaltyModule
   */},{key:"watchRoyaltyPaidEvent",value:function watchRoyaltyPaidEvent(_onLogs29){return this.rpcClient.watchContractEvent({abi:royaltyModuleAbi,address:this.address,eventName:"RoyaltyPaid",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs29(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RoyaltyPaid for contract RoyaltyModule
   */},{key:"parseTxRoyaltyPaidEvent",value:function parseTxRoyaltyPaidEvent(txReceipt){var targetLogs=[];var _iterator29=_createForOfIteratorHelper(txReceipt.logs),_step29;try{for(_iterator29.s();!(_step29=_iterator29.n()).done;){var log=_step29.value;try{var event=decodeEventLog({abi:royaltyModuleAbi,eventName:"RoyaltyPaid",data:log.data,topics:log.topics});if(event.eventName==="RoyaltyPaid"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator29.e(err);}finally{_iterator29.f();}return targetLogs;}}]);}();/**
 * contract RoyaltyModule readonly method
 */var RoyaltyModuleReadOnlyClient=/*#__PURE__*/function(_RoyaltyModuleEventCl){function RoyaltyModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,RoyaltyModuleReadOnlyClient);return _callSuper(this,RoyaltyModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ipRoyaltyVaults for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIpRoyaltyVaultsRequest
   * @return Promise<RoyaltyModuleIpRoyaltyVaultsResponse>
   */_inherits(RoyaltyModuleReadOnlyClient,_RoyaltyModuleEventCl);return _createClass(RoyaltyModuleReadOnlyClient,[{key:"ipRoyaltyVaults",value:(function(){var _ipRoyaltyVaults=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee147(request){return _regeneratorRuntime().wrap(function _callee147$(_context147){while(1)switch(_context147.prev=_context147.next){case 0:_context147.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"ipRoyaltyVaults",args:[request.ipId]});case 2:return _context147.abrupt("return",_context147.sent);case 3:case"end":return _context147.stop();}},_callee147,this);}));function ipRoyaltyVaults(_x108){return _ipRoyaltyVaults.apply(this,arguments);}return ipRoyaltyVaults;}()/**
   * method isWhitelistedRoyaltyPolicy for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyPolicyResponse>
   */)},{key:"isWhitelistedRoyaltyPolicy",value:(function(){var _isWhitelistedRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee148(request){return _regeneratorRuntime().wrap(function _callee148$(_context148){while(1)switch(_context148.prev=_context148.next){case 0:_context148.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyPolicy",args:[request.royaltyPolicy]});case 2:return _context148.abrupt("return",_context148.sent);case 3:case"end":return _context148.stop();}},_callee148,this);}));function isWhitelistedRoyaltyPolicy(_x109){return _isWhitelistedRoyaltyPolicy.apply(this,arguments);}return isWhitelistedRoyaltyPolicy;}()/**
   * method isWhitelistedRoyaltyToken for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyTokenResponse>
   */)},{key:"isWhitelistedRoyaltyToken",value:(function(){var _isWhitelistedRoyaltyToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee149(request){return _regeneratorRuntime().wrap(function _callee149$(_context149){while(1)switch(_context149.prev=_context149.next){case 0:_context149.next=2;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyToken",args:[request.token]});case 2:return _context149.abrupt("return",_context149.sent);case 3:case"end":return _context149.stop();}},_callee149,this);}));function isWhitelistedRoyaltyToken(_x110){return _isWhitelistedRoyaltyToken.apply(this,arguments);}return isWhitelistedRoyaltyToken;}())}]);}(RoyaltyModuleEventClient);/**
 * contract RoyaltyModule write method
 */var RoyaltyModuleClient=/*#__PURE__*/function(_RoyaltyModuleReadOnl){function RoyaltyModuleClient(rpcClient,wallet,address){var _this11;_classCallCheck(this,RoyaltyModuleClient);_this11=_callSuper(this,RoyaltyModuleClient,[rpcClient,address]);_this11.wallet=wallet;return _this11;}/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RoyaltyModuleClient,_RoyaltyModuleReadOnl);return _createClass(RoyaltyModuleClient,[{key:"payRoyaltyOnBehalf",value:(function(){var _payRoyaltyOnBehalf=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee150(request){var _yield$this$rpcClient70,call;return _regeneratorRuntime().wrap(function _callee150$(_context150){while(1)switch(_context150.prev=_context150.next){case 0:_context150.next=2;return this.rpcClient.simulateContract({abi:royaltyModuleAbi,address:this.address,functionName:"payRoyaltyOnBehalf",account:this.wallet.account,args:[request.receiverIpId,request.payerIpId,request.token,request.amount]});case 2:_yield$this$rpcClient70=_context150.sent;call=_yield$this$rpcClient70.request;_context150.next=6;return this.wallet.writeContract(call);case 6:return _context150.abrupt("return",_context150.sent);case 7:case"end":return _context150.stop();}},_callee150,this);}));function payRoyaltyOnBehalf(_x111){return _payRoyaltyOnBehalf.apply(this,arguments);}return payRoyaltyOnBehalf;}()/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule with only encode
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return EncodedTxData
   */)},{key:"payRoyaltyOnBehalfEncode",value:function payRoyaltyOnBehalfEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyModuleAbi,functionName:"payRoyaltyOnBehalf",args:[request.receiverIpId,request.payerIpId,request.token,request.amount]})};}}]);}(RoyaltyModuleReadOnlyClient);// Contract RoyaltyPolicyLAP =============================================================
/**
 * RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
 *
 * @param ipId address
 * @param royaltyShares tuple[]
 * @param sigApproveRoyaltyTokens tuple
 *//**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 *//**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 *//**
 * RoyaltyTokenDistributionWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 *//**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * contract RoyaltyTokenDistributionWorkflows write method
 */var RoyaltyTokenDistributionWorkflowsClient=/*#__PURE__*/function(){function RoyaltyTokenDistributionWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain21;_classCallCheck(this,RoyaltyTokenDistributionWorkflowsClient);this.address=address||getAddress(royaltyTokenDistributionWorkflowsAddress,(_rpcClient$chain21=rpcClient.chain)===null||_rpcClient$chain21===void 0?void 0:_rpcClient$chain21.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(RoyaltyTokenDistributionWorkflowsClient,[{key:"distributeRoyaltyTokens",value:(function(){var _distributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee174(request){var _yield$this$rpcClient81,call;return _regeneratorRuntime().wrap(function _callee174$(_context174){while(1)switch(_context174.prev=_context174.next){case 0:_context174.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"distributeRoyaltyTokens",account:this.wallet.account,args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]});case 2:_yield$this$rpcClient81=_context174.sent;call=_yield$this$rpcClient81.request;_context174.next=6;return this.wallet.writeContract(call);case 6:return _context174.abrupt("return",_context174.sent);case 7:case"end":return _context174.stop();}},_callee174,this);}));function distributeRoyaltyTokens(_x123){return _distributeRoyaltyTokens.apply(this,arguments);}return distributeRoyaltyTokens;}()/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"distributeRoyaltyTokensEncode",value:function distributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"distributeRoyaltyTokens",args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]})};}/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee175(request){var _yield$this$rpcClient82,call;return _regeneratorRuntime().wrap(function _callee175$(_context175){while(1)switch(_context175.prev=_context175.next){case 0:_context175.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]});case 2:_yield$this$rpcClient82=_context175.sent;call=_yield$this$rpcClient82.request;_context175.next=6;return this.wallet.writeContract(call);case 6:return _context175.abrupt("return",_context175.sent);case 7:case"end":return _context175.stop();}},_callee175,this);}));function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x124){return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee176(request){var _yield$this$rpcClient83,call;return _regeneratorRuntime().wrap(function _callee176$(_context176){while(1)switch(_context176.prev=_context176.next){case 0:_context176.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]});case 2:_yield$this$rpcClient83=_context176.sent;call=_yield$this$rpcClient83.request;_context176.next=6;return this.wallet.writeContract(call);case 6:return _context176.abrupt("return",_context176.sent);case 7:case"end":return _context176.stop();}},_callee176,this);}));function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x125){return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method multicall for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee177(request){var _yield$this$rpcClient84,call;return _regeneratorRuntime().wrap(function _callee177$(_context177){while(1)switch(_context177.prev=_context177.next){case 0:_context177.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient84=_context177.sent;call=_yield$this$rpcClient84.request;_context177.next=6;return this.wallet.writeContract(call);case 6:return _context177.abrupt("return",_context177.sent);case 7:case"end":return _context177.stop();}},_callee177,this);}));function multicall(_x126){return _multicall4.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVault",value:(function(){var _registerIpAndAttachPilTermsAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee178(request){var _yield$this$rpcClient85,call;return _regeneratorRuntime().wrap(function _callee178$(_context178){while(1)switch(_context178.prev=_context178.next){case 0:_context178.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 2:_yield$this$rpcClient85=_context178.sent;call=_yield$this$rpcClient85.request;_context178.next=6;return this.wallet.writeContract(call);case 6:return _context178.abrupt("return",_context178.sent);case 7:case"end":return _context178.stop();}},_callee178,this);}));function registerIpAndAttachPilTermsAndDeployRoyaltyVault(_x127){return _registerIpAndAttachPilTermsAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndAttachPilTermsAndDeployRoyaltyVault;}()/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode",value:function registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",value:(function(){var _registerIpAndMakeDerivativeAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee179(request){var _yield$this$rpcClient86,call;return _regeneratorRuntime().wrap(function _callee179$(_context179){while(1)switch(_context179.prev=_context179.next){case 0:_context179.next=2;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]});case 2:_yield$this$rpcClient86=_context179.sent;call=_yield$this$rpcClient86.request;_context179.next=6;return this.wallet.writeContract(call);case 6:return _context179.abrupt("return",_context179.sent);case 7:case"end":return _context179.stop();}},_callee179,this);}));function registerIpAndMakeDerivativeAndDeployRoyaltyVault(_x128){return _registerIpAndMakeDerivativeAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndMakeDerivativeAndDeployRoyaltyVault;}()/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode",value:function registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]})};}}]);}();// Contract RoyaltyWorkflows =============================================================
/**
 * RoyaltyWorkflowsClaimAllRevenueRequest
 *
 * @param ancestorIpId address
 * @param claimer address
 * @param childIpIds address[]
 * @param royaltyPolicies address[]
 * @param currencyTokens address[]
 *//**
 * RoyaltyWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * contract RoyaltyWorkflows write method
 */var RoyaltyWorkflowsClient=/*#__PURE__*/function(){function RoyaltyWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain22;_classCallCheck(this,RoyaltyWorkflowsClient);this.address=address||getAddress(royaltyWorkflowsAddress,(_rpcClient$chain22=rpcClient.chain)===null||_rpcClient$chain22===void 0?void 0:_rpcClient$chain22.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method claimAllRevenue for contract RoyaltyWorkflows
   *
   * @param request RoyaltyWorkflowsClaimAllRevenueRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(RoyaltyWorkflowsClient,[{key:"claimAllRevenue",value:(function(){var _claimAllRevenue=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee180(request){var _yield$this$rpcClient87,call;return _regeneratorRuntime().wrap(function _callee180$(_context180){while(1)switch(_context180.prev=_context180.next){case 0:_context180.next=2;return this.rpcClient.simulateContract({abi:royaltyWorkflowsAbi,address:this.address,functionName:"claimAllRevenue",account:this.wallet.account,args:[request.ancestorIpId,request.claimer,request.childIpIds,request.royaltyPolicies,request.currencyTokens]});case 2:_yield$this$rpcClient87=_context180.sent;call=_yield$this$rpcClient87.request;_context180.next=6;return this.wallet.writeContract(call);case 6:return _context180.abrupt("return",_context180.sent);case 7:case"end":return _context180.stop();}},_callee180,this);}));function claimAllRevenue(_x129){return _claimAllRevenue.apply(this,arguments);}return claimAllRevenue;}()/**
   * method claimAllRevenue for contract RoyaltyWorkflows with only encode
   *
   * @param request RoyaltyWorkflowsClaimAllRevenueRequest
   * @return EncodedTxData
   */)},{key:"claimAllRevenueEncode",value:function claimAllRevenueEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyWorkflowsAbi,functionName:"claimAllRevenue",args:[request.ancestorIpId,request.claimer,request.childIpIds,request.royaltyPolicies,request.currencyTokens]})};}/**
   * method multicall for contract RoyaltyWorkflows
   *
   * @param request RoyaltyWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee181(request){var _yield$this$rpcClient88,call;return _regeneratorRuntime().wrap(function _callee181$(_context181){while(1)switch(_context181.prev=_context181.next){case 0:_context181.next=2;return this.rpcClient.simulateContract({abi:royaltyWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 2:_yield$this$rpcClient88=_context181.sent;call=_yield$this$rpcClient88.request;_context181.next=6;return this.wallet.writeContract(call);case 6:return _context181.abrupt("return",_context181.sent);case 7:case"end":return _context181.stop();}},_callee181,this);}));function multicall(_x130){return _multicall5.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RoyaltyWorkflows with only encode
   *
   * @param request RoyaltyWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:encodeFunctionData({abi:royaltyWorkflowsAbi,functionName:"multicall",args:[request.data]})};}}]);}();// Contract SPGNFTBeacon =============================================================
/**
 * SpgnftImplTransferEvent
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 *//**
 * SpgnftImplTokenUriRequest
 *
 * @param tokenId uint256
 *//**
 * SpgnftImplSetTokenUriRequest
 *
 * @param tokenId uint256
 * @param tokenUri string
 *//**
 * contract SPGNFTImpl event
 */var SpgnftImplEventClient=/*#__PURE__*/function(){function SpgnftImplEventClient(rpcClient,address){var _rpcClient$chain24;_classCallCheck(this,SpgnftImplEventClient);this.address=address||getAddress(spgnftImplAddress,(_rpcClient$chain24=rpcClient.chain)===null||_rpcClient$chain24===void 0?void 0:_rpcClient$chain24.id);this.rpcClient=rpcClient;}/**
   * event Transfer for contract SPGNFTImpl
   */return _createClass(SpgnftImplEventClient,[{key:"watchTransferEvent",value:function watchTransferEvent(_onLogs38){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"Transfer",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs38(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Transfer for contract SPGNFTImpl
   */},{key:"parseTxTransferEvent",value:function parseTxTransferEvent(txReceipt){var targetLogs=[];var _iterator38=_createForOfIteratorHelper(txReceipt.logs),_step38;try{for(_iterator38.s();!(_step38=_iterator38.n()).done;){var log=_step38.value;try{var event=decodeEventLog({abi:spgnftImplAbi,eventName:"Transfer",data:log.data,topics:log.topics});if(event.eventName==="Transfer"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator38.e(err);}finally{_iterator38.f();}return targetLogs;}}]);}();/**
 * contract SPGNFTImpl readonly method
 */var SpgnftImplReadOnlyClient=/*#__PURE__*/function(_SpgnftImplEventClien){function SpgnftImplReadOnlyClient(rpcClient,address){_classCallCheck(this,SpgnftImplReadOnlyClient);return _callSuper(this,SpgnftImplReadOnlyClient,[rpcClient,address]);}/**
   * method mintFee for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeRequest
   * @return Promise<SpgnftImplMintFeeResponse>
   */_inherits(SpgnftImplReadOnlyClient,_SpgnftImplEventClien);return _createClass(SpgnftImplReadOnlyClient,[{key:"mintFee",value:(function(){var _mintFee=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee187(){return _regeneratorRuntime().wrap(function _callee187$(_context187){while(1)switch(_context187.prev=_context187.next){case 0:_context187.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFee"});case 2:return _context187.abrupt("return",_context187.sent);case 3:case"end":return _context187.stop();}},_callee187,this);}));function mintFee(){return _mintFee.apply(this,arguments);}return mintFee;}()/**
   * method mintFeeToken for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeTokenRequest
   * @return Promise<SpgnftImplMintFeeTokenResponse>
   */)},{key:"mintFeeToken",value:(function(){var _mintFeeToken=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee188(){return _regeneratorRuntime().wrap(function _callee188$(_context188){while(1)switch(_context188.prev=_context188.next){case 0:_context188.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFeeToken"});case 2:return _context188.abrupt("return",_context188.sent);case 3:case"end":return _context188.stop();}},_callee188,this);}));function mintFeeToken(){return _mintFeeToken.apply(this,arguments);}return mintFeeToken;}()/**
   * method publicMinting for contract SPGNFTImpl
   *
   * @param request SpgnftImplPublicMintingRequest
   * @return Promise<SpgnftImplPublicMintingResponse>
   */)},{key:"publicMinting",value:(function(){var _publicMinting=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee189(){return _regeneratorRuntime().wrap(function _callee189$(_context189){while(1)switch(_context189.prev=_context189.next){case 0:_context189.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"publicMinting"});case 2:return _context189.abrupt("return",_context189.sent);case 3:case"end":return _context189.stop();}},_callee189,this);}));function publicMinting(){return _publicMinting.apply(this,arguments);}return publicMinting;}()/**
   * method tokenURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplTokenUriRequest
   * @return Promise<SpgnftImplTokenUriResponse>
   */)},{key:"tokenUri",value:(function(){var _tokenUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee190(request){return _regeneratorRuntime().wrap(function _callee190$(_context190){while(1)switch(_context190.prev=_context190.next){case 0:_context190.next=2;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"tokenURI",args:[request.tokenId]});case 2:return _context190.abrupt("return",_context190.sent);case 3:case"end":return _context190.stop();}},_callee190,this);}));function tokenUri(_x133){return _tokenUri.apply(this,arguments);}return tokenUri;}())}]);}(SpgnftImplEventClient);/**
 * contract SPGNFTImpl write method
 */var SpgnftImplClient=/*#__PURE__*/function(_SpgnftImplReadOnlyCl){function SpgnftImplClient(rpcClient,wallet,address){var _this14;_classCallCheck(this,SpgnftImplClient);_this14=_callSuper(this,SpgnftImplClient,[rpcClient,address]);_this14.wallet=wallet;return _this14;}/**
   * method setTokenURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplSetTokenUriRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(SpgnftImplClient,_SpgnftImplReadOnlyCl);return _createClass(SpgnftImplClient,[{key:"setTokenUri",value:(function(){var _setTokenUri=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee191(request){var _yield$this$rpcClient92,call;return _regeneratorRuntime().wrap(function _callee191$(_context191){while(1)switch(_context191.prev=_context191.next){case 0:_context191.next=2;return this.rpcClient.simulateContract({abi:spgnftImplAbi,address:this.address,functionName:"setTokenURI",account:this.wallet.account,args:[request.tokenId,request.tokenUri]});case 2:_yield$this$rpcClient92=_context191.sent;call=_yield$this$rpcClient92.request;_context191.next=6;return this.wallet.writeContract(call);case 6:return _context191.abrupt("return",_context191.sent);case 7:case"end":return _context191.stop();}},_callee191,this);}));function setTokenUri(_x134){return _setTokenUri.apply(this,arguments);}return setTokenUri;}()/**
   * method setTokenURI for contract SPGNFTImpl with only encode
   *
   * @param request SpgnftImplSetTokenUriRequest
   * @return EncodedTxData
   */)},{key:"setTokenUriEncode",value:function setTokenUriEncode(request){return {to:this.address,data:encodeFunctionData({abi:spgnftImplAbi,functionName:"setTokenURI",args:[request.tokenId,request.tokenUri]})};}}]);}(SpgnftImplReadOnlyClient);// Contract WrappedIP =============================================================
/**
 * WrappedIpAllowanceRequest
 *
 * @param owner address
 * @param spender address
 *//**
 * WrappedIpAllowanceResponse
 *
 * @param result uint256
 *//**
 * WrappedIpBalanceOfRequest
 *
 * @param owner address
 *//**
 * WrappedIpBalanceOfResponse
 *
 * @param result uint256
 *//**
 * WrappedIpApproveRequest
 *
 * @param spender address
 * @param amount uint256
 *//**
 * WrappedIpTransferRequest
 *
 * @param to address
 * @param amount uint256
 *//**
 * WrappedIpTransferFromRequest
 *
 * @param from address
 * @param to address
 * @param amount uint256
 *//**
 * WrappedIpWithdrawRequest
 *
 * @param value uint256
 *//**
 * contract WrappedIP readonly method
 */var WrappedIpReadOnlyClient=/*#__PURE__*/function(){function WrappedIpReadOnlyClient(rpcClient,address){var _rpcClient$chain25;_classCallCheck(this,WrappedIpReadOnlyClient);this.address=address||getAddress(wrappedIpAddress,(_rpcClient$chain25=rpcClient.chain)===null||_rpcClient$chain25===void 0?void 0:_rpcClient$chain25.id);this.rpcClient=rpcClient;}/**
   * method allowance for contract WrappedIP
   *
   * @param request WrappedIpAllowanceRequest
   * @return Promise<WrappedIpAllowanceResponse>
   */return _createClass(WrappedIpReadOnlyClient,[{key:"allowance",value:(function(){var _allowance2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee192(request){var result;return _regeneratorRuntime().wrap(function _callee192$(_context192){while(1)switch(_context192.prev=_context192.next){case 0:_context192.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"allowance",args:[request.owner,request.spender]});case 2:result=_context192.sent;return _context192.abrupt("return",{result:result});case 4:case"end":return _context192.stop();}},_callee192,this);}));function allowance(_x135){return _allowance2.apply(this,arguments);}return allowance;}()/**
   * method balanceOf for contract WrappedIP
   *
   * @param request WrappedIpBalanceOfRequest
   * @return Promise<WrappedIpBalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee193(request){var result;return _regeneratorRuntime().wrap(function _callee193$(_context193){while(1)switch(_context193.prev=_context193.next){case 0:_context193.next=2;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"balanceOf",args:[request.owner]});case 2:result=_context193.sent;return _context193.abrupt("return",{result:result});case 4:case"end":return _context193.stop();}},_callee193,this);}));function balanceOf(_x136){return _balanceOf3.apply(this,arguments);}return balanceOf;}())}]);}();/**
 * contract WrappedIP write method
 */var WrappedIpClient=/*#__PURE__*/function(_WrappedIpReadOnlyCli){function WrappedIpClient(rpcClient,wallet,address){var _this15;_classCallCheck(this,WrappedIpClient);_this15=_callSuper(this,WrappedIpClient,[rpcClient,address]);_this15.wallet=wallet;return _this15;}/**
   * method approve for contract WrappedIP
   *
   * @param request WrappedIpApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(WrappedIpClient,_WrappedIpReadOnlyCli);return _createClass(WrappedIpClient,[{key:"approve",value:(function(){var _approve2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee194(request){var _yield$this$rpcClient93,call;return _regeneratorRuntime().wrap(function _callee194$(_context194){while(1)switch(_context194.prev=_context194.next){case 0:_context194.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.spender,request.amount]});case 2:_yield$this$rpcClient93=_context194.sent;call=_yield$this$rpcClient93.request;_context194.next=6;return this.wallet.writeContract(call);case 6:return _context194.abrupt("return",_context194.sent);case 7:case"end":return _context194.stop();}},_callee194,this);}));function approve(_x137){return _approve2.apply(this,arguments);}return approve;}()/**
   * method approve for contract WrappedIP with only encode
   *
   * @param request WrappedIpApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"approve",args:[request.spender,request.amount]})};}/**
   * method deposit for contract WrappedIP
   *
   * @param request WrappedIpDepositRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"deposit",value:(function(){var _deposit=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee195(){var _yield$this$rpcClient94,call;return _regeneratorRuntime().wrap(function _callee195$(_context195){while(1)switch(_context195.prev=_context195.next){case 0:_context195.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"deposit",account:this.wallet.account});case 2:_yield$this$rpcClient94=_context195.sent;call=_yield$this$rpcClient94.request;_context195.next=6;return this.wallet.writeContract(call);case 6:return _context195.abrupt("return",_context195.sent);case 7:case"end":return _context195.stop();}},_callee195,this);}));function deposit(){return _deposit.apply(this,arguments);}return deposit;}()/**
   * method deposit for contract WrappedIP with only encode
   *
   * @param request WrappedIpDepositRequest
   * @return EncodedTxData
   */)},{key:"depositEncode",value:function depositEncode(){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"deposit"})};}/**
   * method transfer for contract WrappedIP
   *
   * @param request WrappedIpTransferRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transfer",value:(function(){var _transfer2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee196(request){var _yield$this$rpcClient95,call;return _regeneratorRuntime().wrap(function _callee196$(_context196){while(1)switch(_context196.prev=_context196.next){case 0:_context196.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transfer",account:this.wallet.account,args:[request.to,request.amount]});case 2:_yield$this$rpcClient95=_context196.sent;call=_yield$this$rpcClient95.request;_context196.next=6;return this.wallet.writeContract(call);case 6:return _context196.abrupt("return",_context196.sent);case 7:case"end":return _context196.stop();}},_callee196,this);}));function transfer(_x138){return _transfer2.apply(this,arguments);}return transfer;}()/**
   * method transfer for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferRequest
   * @return EncodedTxData
   */)},{key:"transferEncode",value:function transferEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"transfer",args:[request.to,request.amount]})};}/**
   * method transferFrom for contract WrappedIP
   *
   * @param request WrappedIpTransferFromRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transferFrom",value:(function(){var _transferFrom2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee197(request){var _yield$this$rpcClient96,call;return _regeneratorRuntime().wrap(function _callee197$(_context197){while(1)switch(_context197.prev=_context197.next){case 0:_context197.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transferFrom",account:this.wallet.account,args:[request.from,request.to,request.amount]});case 2:_yield$this$rpcClient96=_context197.sent;call=_yield$this$rpcClient96.request;_context197.next=6;return this.wallet.writeContract(call);case 6:return _context197.abrupt("return",_context197.sent);case 7:case"end":return _context197.stop();}},_callee197,this);}));function transferFrom(_x139){return _transferFrom2.apply(this,arguments);}return transferFrom;}()/**
   * method transferFrom for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferFromRequest
   * @return EncodedTxData
   */)},{key:"transferFromEncode",value:function transferFromEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"transferFrom",args:[request.from,request.to,request.amount]})};}/**
   * method withdraw for contract WrappedIP
   *
   * @param request WrappedIpWithdrawRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"withdraw",value:(function(){var _withdraw=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee198(request){var _yield$this$rpcClient97,call;return _regeneratorRuntime().wrap(function _callee198$(_context198){while(1)switch(_context198.prev=_context198.next){case 0:_context198.next=2;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"withdraw",account:this.wallet.account,args:[request.value]});case 2:_yield$this$rpcClient97=_context198.sent;call=_yield$this$rpcClient97.request;_context198.next=6;return this.wallet.writeContract(call);case 6:return _context198.abrupt("return",_context198.sent);case 7:case"end":return _context198.stop();}},_callee198,this);}));function withdraw(_x140){return _withdraw.apply(this,arguments);}return withdraw;}()/**
   * method withdraw for contract WrappedIP with only encode
   *
   * @param request WrappedIpWithdrawRequest
   * @return EncodedTxData
   */)},{key:"withdrawEncode",value:function withdrawEncode(request){return {to:this.address,data:encodeFunctionData({abi:wrappedIpAbi,functionName:"withdraw",args:[request.value]})};}}]);}(WrappedIpReadOnlyClient);

/**
 * This structure defines the terms for a Programmable IP License (PIL).
 * These terms can be attached to IP Assets.
 **/

var PIL_TYPE = /*#__PURE__*/function (PIL_TYPE) {
  PIL_TYPE[PIL_TYPE["NON_COMMERCIAL_REMIX"] = 0] = "NON_COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_USE"] = 1] = "COMMERCIAL_USE";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_REMIX"] = 2] = "COMMERCIAL_REMIX";
  return PIL_TYPE;
}({});

var defaultFunctionSelector = "0x00000000";
var royaltySharesTotalSupply = 100000000;
var MAX_ROYALTY_TOKEN = 100000000;
var WIP_TOKEN_ADDRESS = wrappedIpAddress[mainnet.id];

/**
 * This data used IP owners to define the configuration
 * when others are minting license tokens of their IP through the LicensingModule.
 * Contract reference: @see {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/lib/Licensing.sol#L27 | Licensing.sol}
 * For detailed documentation on licensing configuration, visit {@link https://docs.story.foundation/concepts/licensing-module/license-config}
 */

/**
 * Input for token amount, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * The type of revenue share.
 * It is used to determine the type of revenue share to be used in the revenue share calculation and throw error when the revenue share is not valid.
 */
var RevShareType = /*#__PURE__*/function (RevShareType) {
  RevShareType["COMMERCIAL_REVENUE_SHARE"] = "CommercialRevShare";
  RevShareType["MAX_REVENUE_SHARE"] = "MaxRevenueShare";
  RevShareType["MAX_ALLOWED_REWARD_SHARE"] = "MaxAllowedRewardShare";
  return RevShareType;
}({});

function getLicenseTermByType(type, term) {
  var licenseTerms = {
    transferable: true,
    royaltyPolicy: zeroAddress,
    defaultMintingFee: BigInt(0),
    expiration: BigInt(0),
    commercialUse: false,
    commercialAttribution: false,
    commercializerChecker: zeroAddress,
    commercializerCheckerData: zeroAddress,
    commercialRevShare: 0,
    commercialRevCeiling: BigInt(0),
    derivativesAllowed: true,
    derivativesAttribution: true,
    derivativesApproval: false,
    derivativesReciprocal: true,
    derivativeRevCeiling: BigInt(0),
    currency: zeroAddress,
    uri: ""
  };
  if (type === PIL_TYPE.NON_COMMERCIAL_REMIX) {
    licenseTerms.commercializerCheckerData = "0x";
    licenseTerms.uri = "https://github.com/piplabs/pil-document/blob/998c13e6ee1d04eb817aefd1fe16dfe8be3cd7a2/off-chain-terms/NCSR.json";
    return licenseTerms;
  } else if (type === PIL_TYPE.COMMERCIAL_USE) {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined) {
      throw new Error("DefaultMintingFee, currency are required for commercial use PIL.");
    }
    licenseTerms.royaltyPolicy = validateAddress(term.royaltyPolicyAddress);
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.derivativesReciprocal = false;
    licenseTerms.currency = validateAddress(term.currency);
    licenseTerms.uri = "https://github.com/piplabs/pil-document/blob/9a1f803fcf8101a8a78f1dcc929e6014e144ab56/off-chain-terms/CommercialUse.json";
    licenseTerms.derivativesAllowed = false;
    licenseTerms.derivativesAttribution = false;
    return licenseTerms;
  } else {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined || term.commercialRevShare === undefined) {
      throw new Error("DefaultMintingFee, currency and commercialRevShare are required for commercial remix PIL.");
    }
    licenseTerms.royaltyPolicy = validateAddress(term.royaltyPolicyAddress);
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.uri = "https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json";
    licenseTerms.commercialRevShare = getRevenueShare(term.commercialRevShare);
    licenseTerms.derivativesReciprocal = true;
    licenseTerms.currency = validateAddress(term.currency);
    return licenseTerms;
  }
}
function validateLicenseTerms(_x, _x2) {
  return _validateLicenseTerms.apply(this, arguments);
}
function _validateLicenseTerms() {
  _validateLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params, rpcClient) {
    var royaltyPolicy, currency, royaltyModuleReadOnlyClient, isWhitelistedArbitrationPolicy, isWhitelistedRoyaltyToken, object;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          royaltyPolicy = params.royaltyPolicy, currency = params.currency;
          royaltyModuleReadOnlyClient = new RoyaltyModuleReadOnlyClient(rpcClient);
          if (!(validateAddress(royaltyPolicy) !== zeroAddress)) {
            _context.next = 8;
            break;
          }
          _context.next = 5;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyPolicy({
            royaltyPolicy: royaltyPolicy
          });
        case 5:
          isWhitelistedArbitrationPolicy = _context.sent;
          if (isWhitelistedArbitrationPolicy) {
            _context.next = 8;
            break;
          }
          throw new Error("The royalty policy is not whitelisted.");
        case 8:
          if (!(validateAddress(currency) !== zeroAddress)) {
            _context.next = 14;
            break;
          }
          _context.next = 11;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyToken({
            token: currency
          });
        case 11:
          isWhitelistedRoyaltyToken = _context.sent;
          if (isWhitelistedRoyaltyToken) {
            _context.next = 14;
            break;
          }
          throw new Error("The currency token is not whitelisted.");
        case 14:
          if (!(royaltyPolicy !== zeroAddress && currency === zeroAddress)) {
            _context.next = 16;
            break;
          }
          throw new Error("Royalty policy requires currency token.");
        case 16:
          object = _objectSpread2(_objectSpread2({}, params), {}, {
            defaultMintingFee: BigInt(params.defaultMintingFee),
            expiration: BigInt(params.expiration),
            commercialRevCeiling: BigInt(params.commercialRevCeiling),
            derivativeRevCeiling: BigInt(params.derivativeRevCeiling)
          });
          if (!(object.defaultMintingFee < 0)) {
            _context.next = 19;
            break;
          }
          throw new Error("DefaultMintingFee should be greater than or equal to 0.");
        case 19:
          if (!(object.defaultMintingFee > 0 && object.royaltyPolicy === zeroAddress)) {
            _context.next = 21;
            break;
          }
          throw new Error("Royalty policy is required when defaultMintingFee is greater than 0.");
        case 21:
          verifyCommercialUse(object);
          verifyDerivatives(object);
          if (!(object.commercialRevShare < 0 || object.commercialRevShare > 100)) {
            _context.next = 27;
            break;
          }
          throw new Error("CommercialRevShare should be between 0 and 100.");
        case 27:
          object.commercialRevShare = object.commercialRevShare / 100 * 100000000;
        case 28:
          return _context.abrupt("return", object);
        case 29:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _validateLicenseTerms.apply(this, arguments);
}
var verifyCommercialUse = function verifyCommercialUse(terms) {
  if (!terms.commercialUse) {
    if (terms.commercialAttribution) {
      throw new Error("Cannot add commercial attribution when commercial use is disabled.");
    }
    if (terms.commercializerChecker !== zeroAddress) {
      throw new Error("Cannot add commercializerChecker when commercial use is disabled.");
    }
    if (terms.commercialRevShare > 0) {
      throw new Error("Cannot add commercial revenue share when commercial use is disabled.");
    }
    if (terms.commercialRevCeiling > 0) {
      throw new Error("Cannot add commercial revenue ceiling when commercial use is disabled.");
    }
    if (terms.derivativeRevCeiling > 0) {
      throw new Error("Cannot add derivative revenue ceiling share when commercial use is disabled.");
    }
    if (terms.royaltyPolicy !== zeroAddress) {
      throw new Error("Cannot add commercial royalty policy when commercial use is disabled.");
    }
  } else {
    if (terms.royaltyPolicy === zeroAddress) {
      throw new Error("Royalty policy is required when commercial use is enabled.");
    }
  }
};
var verifyDerivatives = function verifyDerivatives(terms) {
  if (!terms.derivativesAllowed) {
    if (terms.derivativesAttribution) {
      throw new Error("Cannot add derivative attribution when derivative use is disabled.");
    }
    if (terms.derivativesApproval) {
      throw new Error("Cannot add derivative approval when derivative use is disabled.");
    }
    if (terms.derivativesReciprocal) {
      throw new Error("Cannot add derivative reciprocal when derivative use is disabled.");
    }
    if (terms.derivativeRevCeiling > 0) {
      throw new Error("Cannot add derivative revenue ceiling when derivative use is disabled.");
    }
  }
};
var getRevenueShare = function getRevenueShare(revShare) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RevShareType.COMMERCIAL_REVENUE_SHARE;
  var revShareNumber = Number(revShare);
  if (isNaN(revShareNumber)) {
    throw new Error("".concat(type, " must be a valid number."));
  }
  if (revShareNumber < 0 || revShareNumber > 100) {
    throw new Error("".concat(type, " must be between 0 and 100."));
  }
  return revShareNumber / 100 * MAX_ROYALTY_TOKEN;
};

var getIpMetadataForWorkflow = function getIpMetadataForWorkflow(ipMetadata) {
  return {
    ipMetadataURI: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.ipMetadataURI) || "",
    ipMetadataHash: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.ipMetadataHash) || zeroHash,
    nftMetadataURI: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.nftMetadataURI) || "",
    nftMetadataHash: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.nftMetadataHash) || zeroHash
  };
};

function simulateAndWriteContract(_x) {
  return _simulateAndWriteContract.apply(this, arguments);
}
function _simulateAndWriteContract() {
  _simulateAndWriteContract = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var rpcClient, wallet, waitForTransaction, data, _yield$rpcClient$simu, request, txHash, receipt;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          rpcClient = _ref.rpcClient, wallet = _ref.wallet, waitForTransaction = _ref.waitForTransaction, data = _ref.data;
          _context.next = 3;
          return rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, data), {}, {
            account: wallet.account
          }));
        case 3:
          _yield$rpcClient$simu = _context.sent;
          request = _yield$rpcClient$simu.request;
          _context.next = 7;
          return wallet.writeContract(request);
        case 7:
          txHash = _context.sent;
          if (!(waitForTransaction !== false)) {
            _context.next = 13;
            break;
          }
          _context.next = 11;
          return rpcClient.waitForTransactionReceipt({
            hash: txHash
          });
        case 11:
          receipt = _context.sent;
          return _context.abrupt("return", {
            txHash: txHash,
            receipt: receipt
          });
        case 13:
          return _context.abrupt("return", {
            txHash: txHash
          });
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _simulateAndWriteContract.apply(this, arguments);
}

function waitForTxReceipt(_x) {
  return _waitForTxReceipt.apply(this, arguments);
}
function _waitForTxReceipt() {
  _waitForTxReceipt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var txOptions, rpcClient, txHash, receipt;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          txOptions = _ref.txOptions, rpcClient = _ref.rpcClient, txHash = _ref.txHash;
          if (!(!txOptions || !txOptions.waitForTransaction)) {
            _context.next = 3;
            break;
          }
          return _context.abrupt("return", {
            txHash: txHash
          });
        case 3:
          _context.next = 5;
          return rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
            hash: txHash
          }));
        case 5:
          receipt = _context.sent;
          return _context.abrupt("return", {
            txHash: txHash,
            receipt: receipt
          });
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _waitForTxReceipt.apply(this, arguments);
}
function waitForTxReceipts(_x2) {
  return _waitForTxReceipts.apply(this, arguments);
}
function _waitForTxReceipts() {
  _waitForTxReceipts = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
    var txOptions, rpcClient, txHashes, receipts;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          txOptions = _ref2.txOptions, rpcClient = _ref2.rpcClient, txHashes = _ref2.txHashes;
          if (!(!txOptions || !txOptions.waitForTransaction)) {
            _context2.next = 3;
            break;
          }
          return _context2.abrupt("return", txHashes.map(function (hash) {
            return {
              txHash: hash
            };
          }));
        case 3:
          _context2.next = 5;
          return Promise.all(txHashes.map(function (hash) {
            return rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
              hash: hash
            }));
          }));
        case 5:
          receipts = _context2.sent;
          return _context2.abrupt("return", receipts.map(function (receipt) {
            return {
              txHash: receipt.transactionHash,
              receipt: receipt
            };
          }));
        case 7:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _waitForTxReceipts.apply(this, arguments);
}

var ERC20Client = /*#__PURE__*/function () {
  function ERC20Client(rpcClient, wallet, address) {
    _classCallCheck(this, ERC20Client);
    this.ercClient = new Erc20Client(rpcClient, wallet, address);
  }
  return _createClass(ERC20Client, [{
    key: "balanceOf",
    value: function () {
      var _balanceOf = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(account) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.ercClient.balanceOf({
                account: account
              });
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function balanceOf(_x) {
        return _balanceOf.apply(this, arguments);
      }
      return balanceOf;
    }()
  }, {
    key: "allowance",
    value: function () {
      var _allowance = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(owner, spender) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.ercClient.allowance({
                owner: owner,
                spender: spender
              });
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function allowance(_x2, _x3) {
        return _allowance.apply(this, arguments);
      }
      return allowance;
    }()
  }, {
    key: "approve",
    value: function () {
      var _approve = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(spender, value) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.ercClient.approve({
                spender: spender,
                value: value
              });
            case 2:
              return _context3.abrupt("return", _context3.sent);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function approve(_x4, _x5) {
        return _approve.apply(this, arguments);
      }
      return approve;
    }()
  }, {
    key: "approveEncode",
    value: function approveEncode(spender, value) {
      return this.ercClient.approveEncode({
        spender: spender,
        value: value
      });
    }
    // The method only will work in test environment
  }, {
    key: "mint",
    value: function () {
      var _mint = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(to, amount) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.ercClient.mint({
                to: to,
                amount: amount
              });
            case 2:
              return _context4.abrupt("return", _context4.sent);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function mint(_x6, _x7) {
        return _mint.apply(this, arguments);
      }
      return mint;
    }()
  }]);
}();
var WipTokenClient = /*#__PURE__*/function () {
  function WipTokenClient(rpcClient, wallet) {
    _classCallCheck(this, WipTokenClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
  }
  return _createClass(WipTokenClient, [{
    key: "balanceOf",
    value: function () {
      var _balanceOf2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account) {
        var _yield$this$wipClient, balance;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.wipClient.balanceOf({
                owner: account
              });
            case 2:
              _yield$this$wipClient = _context5.sent;
              balance = _yield$this$wipClient.result;
              return _context5.abrupt("return", balance);
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function balanceOf(_x8) {
        return _balanceOf2.apply(this, arguments);
      }
      return balanceOf;
    }()
  }, {
    key: "allowance",
    value: function () {
      var _allowance2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(owner, spender) {
        var _yield$this$wipClient2, allowance;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.wipClient.allowance({
                owner: owner,
                spender: spender
              });
            case 2:
              _yield$this$wipClient2 = _context6.sent;
              allowance = _yield$this$wipClient2.result;
              return _context6.abrupt("return", allowance);
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function allowance(_x9, _x0) {
        return _allowance2.apply(this, arguments);
      }
      return allowance;
    }()
  }, {
    key: "approve",
    value: function () {
      var _approve2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(spender, value) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.wipClient.approve({
                spender: spender,
                amount: value
              });
            case 2:
              return _context7.abrupt("return", _context7.sent);
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function approve(_x1, _x10) {
        return _approve2.apply(this, arguments);
      }
      return approve;
    }()
  }, {
    key: "approveEncode",
    value: function approveEncode(spender, value) {
      return this.wipClient.approveEncode({
        spender: spender,
        amount: value
      });
    }
  }, {
    key: "depositEncode",
    value: function depositEncode() {
      return this.wipClient.depositEncode();
    }
  }, {
    key: "address",
    get: function get() {
      return this.wipClient.address;
    }
  }]);
}();

/**
 * check the allowance of all spenders and call approval if any spender
 * allowance is lower than the amount they are expected to spend.
 * Supports using multicall to return all approve calls in a multicall array.
 */
var approvalAllSpenders = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
    var spenders, client, owner, useMultiCall, rpcClient, multicallAddress, approvals, allCalls, _iterator, _step, approval, hash;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          spenders = _ref.spenders, client = _ref.client, owner = _ref.owner, useMultiCall = _ref.useMultiCall, rpcClient = _ref.rpcClient, multicallAddress = _ref.multicallAddress;
          _context2.next = 3;
          return Promise.all(spenders.map(/*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(spender) {
              var spenderAmount, allowance;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(spender.address === multicallAddress)) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    spenderAmount = spender.amount || maxUint256;
                    _context.next = 5;
                    return client.allowance(owner, spender.address);
                  case 5:
                    allowance = _context.sent;
                    if (!(allowance < spenderAmount)) {
                      _context.next = 8;
                      break;
                    }
                    return _context.abrupt("return", {
                      spender: spender.address,
                      value: maxUint256 // approve max amount to avoid approvals in the future
                    });
                  case 8:
                    return _context.abrupt("return");
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x2) {
              return _ref3.apply(this, arguments);
            };
          }()));
        case 3:
          approvals = _context2.sent;
          if (!useMultiCall) {
            _context2.next = 8;
            break;
          }
          allCalls = [];
          approvals.forEach(function (approval) {
            if (!approval) {
              return;
            }
            var encodedData = client.approveEncode(approval.spender, approval.value);
            allCalls.push({
              target: encodedData.to,
              allowFailure: false,
              value: 0n,
              callData: encodedData.data
            });
          });
          return _context2.abrupt("return", allCalls);
        case 8:
          // make approval calls sequentially
          _iterator = _createForOfIteratorHelper(approvals);
          _context2.prev = 9;
          _iterator.s();
        case 11:
          if ((_step = _iterator.n()).done) {
            _context2.next = 22;
            break;
          }
          approval = _step.value;
          if (approval) {
            _context2.next = 15;
            break;
          }
          return _context2.abrupt("continue", 20);
        case 15:
          _context2.next = 17;
          return client.approve(approval.spender, approval.value);
        case 17:
          hash = _context2.sent;
          _context2.next = 20;
          return rpcClient.waitForTransactionReceipt({
            hash: hash
          });
        case 20:
          _context2.next = 11;
          break;
        case 22:
          _context2.next = 27;
          break;
        case 24:
          _context2.prev = 24;
          _context2.t0 = _context2["catch"](9);
          _iterator.e(_context2.t0);
        case 27:
          _context2.prev = 27;
          _iterator.f();
          return _context2.finish(27);
        case 30:
          return _context2.abrupt("return", []);
        case 31:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[9, 24, 27, 30]]);
  }));
  return function approvalAllSpenders(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var multiCallWrapIp = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref4) {
    var ipAmountToWrap, wipClient, multicall3Address, wipSpenders, calls, rpcClient, wallet, contractCall, wipOptions, multiCalls, useMultiCall, deposit, autoApprove, approvalCalls, txHash;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          ipAmountToWrap = _ref4.ipAmountToWrap, wipClient = _ref4.wipClient, multicall3Address = _ref4.multicall3Address, wipSpenders = _ref4.wipSpenders, calls = _ref4.calls, rpcClient = _ref4.rpcClient, wallet = _ref4.wallet, contractCall = _ref4.contractCall, wipOptions = _ref4.wipOptions;
          if (!(ipAmountToWrap === 0n)) {
            _context3.next = 3;
            break;
          }
          throw new Error("ipAmountToWrap should be greater than 0");
        case 3:
          multiCalls = [];
          useMultiCall = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) !== false;
          if (!useMultiCall) {
            _context3.next = 10;
            break;
          }
          deposit = wipClient.depositEncode();
          multiCalls.push({
            target: deposit.to,
            allowFailure: false,
            value: ipAmountToWrap,
            callData: deposit.data
          });
          _context3.next = 12;
          break;
        case 10:
          _context3.next = 12;
          return simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: wrappedIpAbi,
              address: wipClient.address,
              functionName: "deposit",
              value: ipAmountToWrap
            },
            waitForTransaction: true
          });
        case 12:
          autoApprove = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.enableAutoApprove) !== false;
          if (!autoApprove) {
            _context3.next = 18;
            break;
          }
          _context3.next = 16;
          return approvalAllSpenders({
            spenders: wipSpenders,
            client: wipClient,
            multicallAddress: multicall3Address,
            owner: useMultiCall ? multicall3Address : wallet.account.address,
            rpcClient: rpcClient,
            useMultiCall: useMultiCall
          });
        case 16:
          approvalCalls = _context3.sent;
          if (approvalCalls.length > 0 && useMultiCall) {
            multiCalls.push.apply(multiCalls, _toConsumableArray(approvalCalls));
          }
        case 18:
          multiCalls.push.apply(multiCalls, _toConsumableArray(calls));
          if (useMultiCall) {
            _context3.next = 24;
            break;
          }
          _context3.next = 22;
          return contractCall();
        case 22:
          txHash = _context3.sent;
          return _context3.abrupt("return", {
            txHash: txHash
          });
        case 24:
          return _context3.abrupt("return", simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: multicall3Abi,
              address: multicall3Address,
              functionName: "aggregate3Value",
              args: [multiCalls],
              value: ipAmountToWrap
            },
            // caller should handle waiting for transaction if needed
            waitForTransaction: false
          }));
        case 25:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function multiCallWrapIp(_x3) {
    return _ref5.apply(this, arguments);
  };
}();

/**
 * Handle contract calls that require token fees. For fees in WIP, it automatically wraps IP to WIP when insufficient WIP balance.
 * For all other ERC20 tokens, it handles approvals if insufficient allowance.
 *
 * @remarks
 * This function will automatically handle the following:
 *
 * If token is wip and the user does not have enough WIP, it will wrap IP to WIP, unless
 * disabled via `disableAutoWrappingIp`.
 *
 * If the user have enough token, it will check for if approvals are needed
 * for each spender address and approve it, unless disabled via `disableAutoApprove`.
 */
var contractCallWithFees = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref6) {
    var _options$wipOptions;
    var totalFees, options, multicall3Address, wallet, tokenSpenders, contractCall, sender, txOptions, encodedTxs, rpcClient, token, wipTokenClient, isWip, selectedOptions, tokenClient, _txHash, balance, autoApprove, _txHash2, autoWrapIp, startingBalance, calls, _yield$multiCallWrapI, txHash;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          totalFees = _ref6.totalFees, options = _ref6.options, multicall3Address = _ref6.multicall3Address, wallet = _ref6.wallet, tokenSpenders = _ref6.tokenSpenders, contractCall = _ref6.contractCall, sender = _ref6.sender, txOptions = _ref6.txOptions, encodedTxs = _ref6.encodedTxs, rpcClient = _ref6.rpcClient, token = _ref6.token;
          wipTokenClient = new WipTokenClient(rpcClient, wallet);
          isWip = token === wipTokenClient.address || token === undefined;
          selectedOptions = isWip ? options === null || options === void 0 ? void 0 : options.wipOptions : options.erc20Options;
          tokenClient = isWip ? wipTokenClient : new ERC20Client(rpcClient, wallet, token); // if no fees, skip all logic
          if (!(totalFees === 0n)) {
            _context4.next = 10;
            break;
          }
          _context4.next = 8;
          return contractCall();
        case 8:
          _txHash = _context4.sent;
          return _context4.abrupt("return", handleTransactionResponse(_txHash, rpcClient, txOptions));
        case 10:
          _context4.next = 12;
          return tokenClient.balanceOf(sender);
        case 12:
          balance = _context4.sent;
          autoApprove = (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.enableAutoApprove) !== false; // handle when there's enough token to cover all fees
          if (!(balance >= totalFees)) {
            _context4.next = 22;
            break;
          }
          if (!autoApprove) {
            _context4.next = 18;
            break;
          }
          _context4.next = 18;
          return approvalAllSpenders({
            spenders: tokenSpenders,
            client: tokenClient,
            owner: sender,
            // sender owns the wip
            multicallAddress: multicall3Address,
            rpcClient: rpcClient,
            // since sender has all token, if using multicall, we cannot approve transfer token into multicall by multicall.
            //  So in this case, we don't use multicall here and instead just wait for each approval to be finished.
            useMultiCall: false
          });
        case 18:
          _context4.next = 20;
          return contractCall();
        case 20:
          _txHash2 = _context4.sent;
          return _context4.abrupt("return", handleTransactionResponse(_txHash2, rpcClient, txOptions));
        case 22:
          if (isWip) {
            _context4.next = 24;
            break;
          }
          throw new Error("Wallet does not have enough erc20 token to pay for fees. Total fees:  ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(balance), "."));
        case 24:
          autoWrapIp = (options === null || options === void 0 || (_options$wipOptions = options.wipOptions) === null || _options$wipOptions === void 0 ? void 0 : _options$wipOptions.enableAutoWrapIp) !== false;
          _context4.next = 27;
          return rpcClient.getBalance({
            address: sender
          });
        case 27:
          startingBalance = _context4.sent;
          if (!(startingBalance < totalFees)) {
            _context4.next = 30;
            break;
          }
          throw new Error("Wallet does not have enough IP to wrap to WIP and pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(startingBalance), "."));
        case 30:
          if (autoWrapIp) {
            _context4.next = 32;
            break;
          }
          throw new Error("Wallet does not have enough WIP to pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(balance, "WIP"), "."));
        case 32:
          calls = encodedTxs === null || encodedTxs === void 0 ? void 0 : encodedTxs.map(function (data) {
            return {
              target: data.to,
              allowFailure: false,
              value: 0n,
              callData: data.data
            };
          });
          _context4.next = 35;
          return multiCallWrapIp({
            ipAmountToWrap: totalFees,
            multicall3Address: multicall3Address,
            wipClient: wipTokenClient,
            wipOptions: options === null || options === void 0 ? void 0 : options.wipOptions,
            contractCall: contractCall,
            wipSpenders: tokenSpenders,
            rpcClient: rpcClient,
            wallet: wallet,
            calls: calls
          });
        case 35:
          _yield$multiCallWrapI = _context4.sent;
          txHash = _yield$multiCallWrapI.txHash;
          return _context4.abrupt("return", handleTransactionResponse(txHash, rpcClient, txOptions));
        case 38:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function contractCallWithFees(_x4) {
    return _ref7.apply(this, arguments);
  };
}();
var handleTransactionResponse = function handleTransactionResponse(txHash, rpcClient, txOptions) {
  if (Array.isArray(txHash)) {
    return waitForTxReceipts({
      rpcClient: rpcClient,
      txOptions: txOptions,
      txHashes: txHash
    });
  }
  return waitForTxReceipt({
    rpcClient: rpcClient,
    txOptions: txOptions,
    txHash: txHash
  });
};

/**
 * Predict the minting license fee.
 *
 * @remarks
 * The method passes `walletAddress` to the `readContract` function so the smart contract can verify
 * if the wallet is the owner of the IP ID. The wallet address is required when using the default license terms ID.
 */
var predictMintingLicenseFee = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var predictMintingFeeRequest, rpcClient, chainId, walletAddress, result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          predictMintingFeeRequest = _ref.predictMintingFeeRequest, rpcClient = _ref.rpcClient, chainId = _ref.chainId, walletAddress = _ref.walletAddress;
          _context.next = 3;
          return rpcClient.readContract({
            abi: licensingModuleAbi,
            address: licensingModuleAddress[chainId],
            functionName: "predictMintingLicenseFee",
            args: [predictMintingFeeRequest.licensorIpId, predictMintingFeeRequest.licenseTemplate, predictMintingFeeRequest.licenseTermsId, predictMintingFeeRequest.amount, predictMintingFeeRequest.receiver, predictMintingFeeRequest.royaltyContext],
            account: walletAddress
          });
        case 3:
          result = _context.sent;
          return _context.abrupt("return", {
            currencyToken: result[0],
            tokenAmount: result[1]
          });
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function predictMintingLicenseFee(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var calculateDerivativeMintingFee = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
    var derivData, rpcClient, chainId, wallet, sender, walletAddress, totalDerivativeMintingFee, i, derivativeMintingFee;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          derivData = _ref3.derivData, rpcClient = _ref3.rpcClient, chainId = _ref3.chainId, wallet = _ref3.wallet, sender = _ref3.sender;
          walletAddress = sender || wallet.account.address;
          totalDerivativeMintingFee = 0n;
          i = 0;
        case 4:
          if (!(i < derivData.parentIpIds.length)) {
            _context2.next = 12;
            break;
          }
          _context2.next = 7;
          return calculateLicenseWipMintFee({
            predictMintingFeeRequest: {
              licensorIpId: derivData.parentIpIds[i],
              licenseTemplate: derivData.licenseTemplate,
              licenseTermsId: derivData.licenseTermsIds[i],
              receiver: walletAddress,
              amount: 1n,
              royaltyContext: zeroAddress
            },
            rpcClient: rpcClient,
            chainId: chainId,
            walletAddress: walletAddress
          });
        case 7:
          derivativeMintingFee = _context2.sent;
          totalDerivativeMintingFee += derivativeMintingFee;
        case 9:
          i++;
          _context2.next = 4;
          break;
        case 12:
          return _context2.abrupt("return", totalDerivativeMintingFee);
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function calculateDerivativeMintingFee(_x2) {
    return _ref4.apply(this, arguments);
  };
}();
var calculateLicenseWipMintFee = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {
    var predictMintingFeeRequest, rpcClient, chainId, walletAddress, fee;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          predictMintingFeeRequest = _ref5.predictMintingFeeRequest, rpcClient = _ref5.rpcClient, chainId = _ref5.chainId, walletAddress = _ref5.walletAddress;
          _context3.next = 3;
          return predictMintingLicenseFee({
            predictMintingFeeRequest: predictMintingFeeRequest,
            rpcClient: rpcClient,
            chainId: chainId,
            walletAddress: walletAddress
          });
        case 3:
          fee = _context3.sent;
          if (!(fee.currencyToken !== WIP_TOKEN_ADDRESS)) {
            _context3.next = 6;
            break;
          }
          return _context3.abrupt("return", 0n);
        case 6:
          return _context3.abrupt("return", fee.tokenAmount);
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function calculateLicenseWipMintFee(_x3) {
    return _ref6.apply(this, arguments);
  };
}();
var calculateSPGWipMintFee = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(spgNftClient) {
    var token;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return spgNftClient.mintFeeToken();
        case 2:
          token = _context4.sent;
          if (!(token !== WIP_TOKEN_ADDRESS)) {
            _context4.next = 5;
            break;
          }
          return _context4.abrupt("return", 0n);
        case 5:
          _context4.next = 7;
          return spgNftClient.mintFee();
        case 7:
          return _context4.abrupt("return", _context4.sent);
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function calculateSPGWipMintFee(_x4) {
    return _ref7.apply(this, arguments);
  };
}();

var validateLicenseConfig = function validateLicenseConfig(licensingConfig) {
  if (!licensingConfig) {
    return {
      isSet: false,
      mintingFee: 0n,
      licensingHook: zeroAddress,
      hookData: zeroHash,
      commercialRevShare: 0,
      disabled: false,
      expectMinimumGroupRewardShare: 0,
      expectGroupRewardPool: zeroAddress
    };
  }
  var licenseConfig = {
    expectMinimumGroupRewardShare: Number(licensingConfig.expectMinimumGroupRewardShare),
    commercialRevShare: getRevenueShare(licensingConfig.commercialRevShare),
    mintingFee: BigInt(licensingConfig.mintingFee),
    expectGroupRewardPool: validateAddress(licensingConfig.expectGroupRewardPool),
    licensingHook: validateAddress(licensingConfig.licensingHook),
    hookData: licensingConfig.hookData,
    isSet: licensingConfig.isSet,
    disabled: licensingConfig.disabled
  };
  if (isNaN(licenseConfig.expectMinimumGroupRewardShare)) {
    throw new Error("The expectMinimumGroupRewardShare must be a valid number.");
  }
  if (licenseConfig.expectMinimumGroupRewardShare < 0 || licenseConfig.expectMinimumGroupRewardShare > 100) {
    throw new Error("The expectMinimumGroupRewardShare must be greater than 0 and less than 100.");
  }
  if (licenseConfig.mintingFee < 0) {
    throw new Error("The mintingFee must be greater than 0.");
  }
  return licenseConfig;
};

/**
 * Get the signature for setting permissions.
 */
var getPermissionSignature = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(param) {
    var ipId, deadline, state, wallet, chainId, permissions, accessAddress, isBatchPermissionFunction, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          ipId = param.ipId, deadline = param.deadline, state = param.state, wallet = param.wallet, chainId = param.chainId, permissions = param.permissions;
          accessAddress = accessControllerAddress[Number(chainId)];
          isBatchPermissionFunction = permissions.length >= 2;
          data = encodeFunctionData({
            abi: accessControllerAbi,
            functionName: isBatchPermissionFunction ? "setBatchTransientPermissions" : "setTransientPermission",
            args: isBatchPermissionFunction ? [permissions.map(function (item) {
              return {
                ipAccount: validateAddress(item.ipId),
                signer: validateAddress(item.signer),
                to: validateAddress(item.to),
                func: item.func ? toFunctionSelector(item.func) : defaultFunctionSelector,
                permission: item.permission
              };
            })] : [validateAddress(permissions[0].ipId), validateAddress(permissions[0].signer), validateAddress(permissions[0].to), permissions[0].func ? toFunctionSelector(permissions[0].func) : defaultFunctionSelector, permissions[0].permission]
          });
          _context.next = 6;
          return getSignature({
            state: state,
            to: accessAddress,
            encodeData: data,
            wallet: wallet,
            verifyingContract: ipId,
            deadline: deadline,
            chainId: chainId
          });
        case 6:
          return _context.abrupt("return", _context.sent);
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getPermissionSignature(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getDeadline = function getDeadline(unixTimestamp, deadline) {
  if (deadline && (isNaN(Number(deadline)) || BigInt(deadline) < 0n)) {
    throw new Error("Invalid deadline value.");
  }
  return deadline ? unixTimestamp + BigInt(deadline) : unixTimestamp + 1000n;
};

/**
 * Get the signature.
 */
var getSignature = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
    var state, to, encodeData, wallet, verifyingContract, deadline, chainId, nonce, signature;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          state = _ref2.state, to = _ref2.to, encodeData = _ref2.encodeData, wallet = _ref2.wallet, verifyingContract = _ref2.verifyingContract, deadline = _ref2.deadline, chainId = _ref2.chainId;
          if (wallet.signTypedData) {
            _context2.next = 3;
            break;
          }
          throw new Error("The wallet client does not support signTypedData, please try again.");
        case 3:
          if (wallet.account) {
            _context2.next = 5;
            break;
          }
          throw new Error("The wallet client does not have an account, please try again.");
        case 5:
          nonce = keccak256(encodeAbiParameters([{
            name: "",
            type: "bytes32"
          }, {
            name: "",
            type: "bytes"
          }], [state, encodeFunctionData({
            abi: ipAccountImplAbi,
            functionName: "execute",
            args: [to, 0n, encodeData]
          })]));
          _context2.next = 8;
          return wallet.signTypedData({
            account: wallet.account,
            domain: {
              name: "Story Protocol IP Account",
              version: "1",
              chainId: Number(chainId),
              verifyingContract: verifyingContract
            },
            types: {
              Execute: [{
                name: "to",
                type: "address"
              }, {
                name: "value",
                type: "uint256"
              }, {
                name: "data",
                type: "bytes"
              }, {
                name: "nonce",
                type: "bytes32"
              }, {
                name: "deadline",
                type: "uint256"
              }]
            },
            primaryType: "Execute",
            message: {
              to: to,
              value: BigInt(0),
              data: encodeData,
              nonce: nonce,
              deadline: BigInt(deadline)
            }
          });
        case 8:
          signature = _context2.sent;
          return _context2.abrupt("return", {
            signature: signature,
            nonce: nonce
          });
        case 10:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getSignature(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

var getPublicMinting = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(spgNftContract, rpcClient) {
    var spgNftContractImpl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          spgNftContractImpl = new SpgnftImplReadOnlyClient(rpcClient, spgNftContract);
          _context.next = 3;
          return spgNftContractImpl.publicMinting();
        case 3:
          return _context.abrupt("return", _context.sent);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getPublicMinting(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var validateLicenseTermsData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(licenseTermsData, rpcClient) {
    var licenseTerms, processedLicenseTermsData, i, licenseTerm, licensingConfig;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          licenseTerms = [];
          processedLicenseTermsData = [];
          i = 0;
        case 3:
          if (!(i < licenseTermsData.length)) {
            _context2.next = 15;
            break;
          }
          _context2.next = 6;
          return validateLicenseTerms(licenseTermsData[i].terms, rpcClient);
        case 6:
          licenseTerm = _context2.sent;
          licensingConfig = validateLicenseConfig(licenseTermsData[i].licensingConfig);
          if (!(licensingConfig.mintingFee > 0 && licenseTerm.royaltyPolicy === zeroAddress)) {
            _context2.next = 10;
            break;
          }
          throw new Error("A royalty policy must be provided when the minting fee is greater than 0.");
        case 10:
          licenseTerms.push(licenseTerm);
          processedLicenseTermsData.push({
            terms: licenseTerm,
            licensingConfig: licensingConfig
          });
        case 12:
          i++;
          _context2.next = 3;
          break;
        case 15:
          return _context2.abrupt("return", {
            licenseTerms: licenseTerms,
            licenseTermsData: processedLicenseTermsData
          });
        case 16:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function validateLicenseTermsData(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
var getRoyaltyShares = function getRoyaltyShares(royaltyShares) {
  var actualTotal = 0;
  var sum = 0;
  var shares = royaltyShares.map(function (share) {
    if (share.percentage <= 0) {
      throw new Error("The percentage of the royalty shares must be greater than 0.");
    }
    if (share.percentage > 100) {
      throw new Error("The percentage of the royalty shares must be less than or equal to 100.");
    }
    sum += share.percentage;
    if (sum > 100) {
      throw new Error("The sum of the royalty shares cannot exceeds 100.");
    }
    var value = share.percentage / 100 * royaltySharesTotalSupply;
    actualTotal += value;
    return _objectSpread2(_objectSpread2({}, share), {}, {
      percentage: value
    });
  });
  return {
    royaltyShares: shares,
    totalAmount: actualTotal
  };
};
var validateDerivativeData = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3) {
    var derivativeDataInput, rpcClient, wallet, chainId, licenseTemplateAddress, ipAssetRegistryClient, licenseRegistryReadOnlyClient, derivativeData, i, parentId, isParentIpRegistered, isAttachedLicenseTerms, _yield$licenseRegistr, royaltyPercent;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          derivativeDataInput = _ref3.derivativeDataInput, rpcClient = _ref3.rpcClient, wallet = _ref3.wallet, chainId = _ref3.chainId;
          licenseTemplateAddress = piLicenseTemplateAddress[chainId];
          ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
          licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
          derivativeData = {
            parentIpIds: derivativeDataInput.parentIpIds,
            licenseTermsIds: derivativeDataInput.licenseTermsIds.map(function (id) {
              return BigInt(id);
            }),
            licenseTemplate: validateAddress(derivativeDataInput.licenseTemplate || licenseTemplateAddress),
            royaltyContext: zeroAddress,
            maxMintingFee: BigInt(derivativeDataInput.maxMintingFee || 0),
            maxRts: Number(derivativeDataInput.maxRts || MAX_ROYALTY_TOKEN),
            maxRevenueShare: getRevenueShare(derivativeDataInput.maxRevenueShare || 100, RevShareType.MAX_REVENUE_SHARE)
          };
          if (!(derivativeData.parentIpIds.length === 0)) {
            _context3.next = 7;
            break;
          }
          throw new Error("The parent IP IDs must be provided.");
        case 7:
          if (!(derivativeData.licenseTermsIds.length === 0)) {
            _context3.next = 9;
            break;
          }
          throw new Error("The license terms IDs must be provided.");
        case 9:
          if (!(derivativeData.parentIpIds.length !== derivativeData.licenseTermsIds.length)) {
            _context3.next = 11;
            break;
          }
          throw new Error("The number of parent IP IDs must match the number of license terms IDs.");
        case 11:
          if (!(derivativeData.maxMintingFee < 0)) {
            _context3.next = 13;
            break;
          }
          throw new Error("The maxMintingFee must be greater than 0.");
        case 13:
          validateMaxRts(derivativeData.maxRts);
          i = 0;
        case 15:
          if (!(i < derivativeData.parentIpIds.length)) {
            _context3.next = 36;
            break;
          }
          parentId = derivativeData.parentIpIds[i];
          _context3.next = 19;
          return ipAssetRegistryClient.isRegistered({
            id: validateAddress(parentId)
          });
        case 19:
          isParentIpRegistered = _context3.sent;
          if (isParentIpRegistered) {
            _context3.next = 22;
            break;
          }
          throw new Error("The parent IP with id ".concat(parentId, " is not registered."));
        case 22:
          _context3.next = 24;
          return licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
            ipId: parentId,
            licenseTemplate: derivativeData.licenseTemplate,
            licenseTermsId: derivativeData.licenseTermsIds[i]
          });
        case 24:
          isAttachedLicenseTerms = _context3.sent;
          if (isAttachedLicenseTerms) {
            _context3.next = 27;
            break;
          }
          throw new Error("License terms id ".concat(derivativeData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(derivativeData.parentIpIds[i], " before registering derivative."));
        case 27:
          _context3.next = 29;
          return licenseRegistryReadOnlyClient.getRoyaltyPercent({
            ipId: parentId,
            licenseTemplate: derivativeData.licenseTemplate,
            licenseTermsId: derivativeData.licenseTermsIds[i]
          });
        case 29:
          _yield$licenseRegistr = _context3.sent;
          royaltyPercent = _yield$licenseRegistr.royaltyPercent;
          if (!(derivativeData.maxRevenueShare !== 0 && royaltyPercent > derivativeData.maxRevenueShare)) {
            _context3.next = 33;
            break;
          }
          throw new Error("The royalty percent for the parent IP with id ".concat(parentId, " is greater than the maximum revenue share ").concat(derivativeData.maxRevenueShare, "."));
        case 33:
          i++;
          _context3.next = 15;
          break;
        case 36:
          return _context3.abrupt("return", derivativeData);
        case 37:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function validateDerivativeData(_x5) {
    return _ref4.apply(this, arguments);
  };
}();
var validateMaxRts = function validateMaxRts(maxRts) {
  if (isNaN(maxRts)) {
    throw new Error("The maxRts must be a number.");
  }
  if (maxRts < 0 || maxRts > MAX_ROYALTY_TOKEN) {
    throw new Error("The maxRts must be greater than 0 and less than ".concat(MAX_ROYALTY_TOKEN, "."));
  }
};
var getIpIdAddress = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref5) {
    var nftContract, tokenId, rpcClient, wallet, chainId, ipAssetRegistryClient, ipId;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          nftContract = _ref5.nftContract, tokenId = _ref5.tokenId, rpcClient = _ref5.rpcClient, wallet = _ref5.wallet, chainId = _ref5.chainId;
          ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
          _context4.next = 4;
          return ipAssetRegistryClient.ipId({
            chainId: BigInt(chain[chainId]),
            tokenContract: validateAddress(nftContract),
            tokenId: BigInt(tokenId)
          });
        case 4:
          ipId = _context4.sent;
          return _context4.abrupt("return", ipId);
        case 6:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function getIpIdAddress(_x6) {
    return _ref6.apply(this, arguments);
  };
}();
var getCalculatedDeadline = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(rpcClient, requestDeadline) {
    var blockTimestamp;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return rpcClient.getBlock();
        case 2:
          blockTimestamp = _context5.sent.timestamp;
          return _context5.abrupt("return", getDeadline(blockTimestamp, requestDeadline));
        case 4:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return function getCalculatedDeadline(_x7, _x8) {
    return _ref7.apply(this, arguments);
  };
}();
var mergeSpenders = function mergeSpenders(previousSpenders, newSpenders) {
  if (!newSpenders || newSpenders.length === 0) {
    return previousSpenders;
  }
  return newSpenders.reduce(function (acc, spender) {
    if (!spender || !spender.address) {
      return acc;
    }
    var existingSpender = acc.find(function (s) {
      return s.address === spender.address;
    });
    if (!existingSpender) {
      acc.push(_objectSpread2(_objectSpread2({}, spender), {}, {
        amount: spender.amount || 0n
      }));
    } else {
      existingSpender.amount = (existingSpender.amount || 0n) + (spender.amount || 0n);
    }
    return acc;
  }, _toConsumableArray(previousSpenders));
};

/**
 * Aggregates the registration requests for the given workflow responses.
 *
 * This function combines multiple workflow responses into a consolidated request structure,
 * aggregating:
 * - Token spenders and their allowances
 * - Total fees required for all operations
 * - Encoded transaction data
 * - Contract calls to be executed
 *
 * @remarks
 * The function handles two execution modes:
 * 1. If `disableMulticallWhenPossible` is true or a workflow response supports multicall3
 *    (indicated by `isUseMulticall3`), individual contract calls are added to the `contractCall` array.
 * 2. Otherwise, it concatenates all `encodedTxData` and passes them as parameters to the
 *    workflowClient's `multicall` method, optimizing gas usage by batching transactions.
 *
 * This approach allows for flexible transaction handling based on contract capabilities
 * and user preferences.
 */
var aggregateTransformIpRegistrationWorkflow = function aggregateTransformIpRegistrationWorkflow(transferWorkflowResponses, multicall3Address, disableMulticallWhenPossible) {
  var aggregateRegistrationRequest = {};
  var _iterator = _createForOfIteratorHelper(transferWorkflowResponses),
    _step;
  try {
    var _loop = function _loop() {
      var res = _step.value;
      var spenders = res.spenders,
        totalFees = res.totalFees,
        encodedTxData = res.encodedTxData,
        workflowClient = res.workflowClient,
        isUseMulticall3 = res.isUseMulticall3;
      var shouldUseMulticall = isUseMulticall3;
      if (disableMulticallWhenPossible) {
        shouldUseMulticall = false;
      }

      // const shouldUseMulticall = !disableMulticallWhenPossible && isUseMulticall3;
      var targetAddress = shouldUseMulticall ? multicall3Address : workflowClient.address;
      if (!aggregateRegistrationRequest[targetAddress]) {
        aggregateRegistrationRequest[targetAddress] = {
          spenders: [],
          totalFees: 0n,
          encodedTxData: [],
          contractCall: []
        };
      }
      var currentRequest = aggregateRegistrationRequest[targetAddress];
      currentRequest.spenders = mergeSpenders(currentRequest.spenders, spenders || []);
      currentRequest.totalFees += totalFees || 0n;
      currentRequest.encodedTxData = currentRequest.encodedTxData.concat(encodedTxData);
      if (isUseMulticall3 || disableMulticallWhenPossible) {
        currentRequest.contractCall = currentRequest.contractCall.concat(res.contractCall);
      } else {
        currentRequest.contractCall = [function () {
          return workflowClient.multicall({
            data: currentRequest.encodedTxData.map(function (tx) {
              return tx.data;
            })
          });
        }];
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return aggregateRegistrationRequest;
};
var handleMulticall = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
    var transferWorkflowResponses, multicall3Address, wipOptions, rpcClient, wallet, walletAddress, aggregateRegistrationRequest, txResponses, _loop2, key;
    return _regeneratorRuntime().wrap(function _callee2$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          transferWorkflowResponses = _ref.transferWorkflowResponses, multicall3Address = _ref.multicall3Address, wipOptions = _ref.wipOptions, rpcClient = _ref.rpcClient, wallet = _ref.wallet, walletAddress = _ref.walletAddress;
          aggregateRegistrationRequest = aggregateTransformIpRegistrationWorkflow(transferWorkflowResponses, multicall3Address, (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) === false);
          txResponses = [];
          _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
            var _aggregateRegistratio, spenders, totalFees, encodedTxData, contractCall, contractCalls, useMulticallWhenPossible, txResponse;
            return _regeneratorRuntime().wrap(function _loop2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  _aggregateRegistratio = aggregateRegistrationRequest[key], spenders = _aggregateRegistratio.spenders, totalFees = _aggregateRegistratio.totalFees, encodedTxData = _aggregateRegistratio.encodedTxData, contractCall = _aggregateRegistratio.contractCall;
                  contractCalls = /*#__PURE__*/function () {
                    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                      var txHashes, _iterator2, _step2, call, txHash;
                      return _regeneratorRuntime().wrap(function _callee$(_context) {
                        while (1) switch (_context.prev = _context.next) {
                          case 0:
                            txHashes = [];
                            _iterator2 = _createForOfIteratorHelper(contractCall);
                            _context.prev = 2;
                            _iterator2.s();
                          case 4:
                            if ((_step2 = _iterator2.n()).done) {
                              _context.next = 12;
                              break;
                            }
                            call = _step2.value;
                            _context.next = 8;
                            return call();
                          case 8:
                            txHash = _context.sent;
                            txHashes.push(txHash);
                          case 10:
                            _context.next = 4;
                            break;
                          case 12:
                            _context.next = 17;
                            break;
                          case 14:
                            _context.prev = 14;
                            _context.t0 = _context["catch"](2);
                            _iterator2.e(_context.t0);
                          case 17:
                            _context.prev = 17;
                            _iterator2.f();
                            return _context.finish(17);
                          case 20:
                            return _context.abrupt("return", txHashes);
                          case 21:
                          case "end":
                            return _context.stop();
                        }
                      }, _callee, null, [[2, 14, 17, 20]]);
                    }));
                    return function contractCalls() {
                      return _ref3.apply(this, arguments);
                    };
                  }();
                  useMulticallWhenPossible = key === multicall3Address ? true : false;
                  _context2.next = 5;
                  return contractCallWithFees({
                    totalFees: totalFees,
                    options: {
                      wipOptions: _objectSpread2(_objectSpread2({}, wipOptions), {}, {
                        useMulticallWhenPossible: useMulticallWhenPossible
                      })
                    },
                    multicall3Address: multicall3Address,
                    rpcClient: rpcClient,
                    tokenSpenders: spenders,
                    contractCall: contractCalls,
                    sender: walletAddress,
                    wallet: wallet,
                    encodedTxs: encodedTxData,
                    txOptions: {
                      waitForTransaction: true
                    }
                  });
                case 5:
                  txResponse = _context2.sent;
                  txResponses.push.apply(txResponses, _toConsumableArray(Array.isArray(txResponse) ? txResponse : [txResponse]));
                case 7:
                case "end":
                  return _context2.stop();
              }
            }, _loop2);
          });
          _context3.t0 = _regeneratorRuntime().keys(aggregateRegistrationRequest);
        case 5:
          if ((_context3.t1 = _context3.t0()).done) {
            _context3.next = 10;
            break;
          }
          key = _context3.t1.value;
          return _context3.delegateYield(_loop2(), "t2", 8);
        case 8:
          _context3.next = 5;
          break;
        case 10:
          return _context3.abrupt("return", txResponses);
        case 11:
        case "end":
          return _context3.stop();
      }
    }, _callee2);
  }));
  return function handleMulticall(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var SignatureMethodType = /*#__PURE__*/function (SignatureMethodType) {
  SignatureMethodType["REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT"] = "registerIpAndMakeDerivativeAndDeployRoyaltyVault";
  SignatureMethodType["DISTRIBUTE_ROYALTY_TOKENS"] = "distributeRoyaltyTokens";
  SignatureMethodType["REGISTER_DERIVATIVE_IP"] = "registerDerivativeIp";
  SignatureMethodType["REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT"] = "registerIpAndAttachPilTermsAndDeployRoyaltyVault";
  SignatureMethodType["REGISTER_IP_AND_ATTACH_PIL_TERMS"] = "registerIpAndAttachPilTerms";
  SignatureMethodType["REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS"] = "registerIpAndMakeDerivativeWithLicenseTokens";
  SignatureMethodType["REGISTER_PIL_TERMS_AND_ATTACH"] = "registerPilTermsAndAttach";
  SignatureMethodType["REGISTER"] = "register";
  SignatureMethodType["BATCH_REGISTER_DERIVATIVE"] = "batchRegisterDerivative";
  return SignatureMethodType;
}({});

/**
 * Permission level
 */
var AccessPermission = /*#__PURE__*/function (AccessPermission) {
  /**
   * ABSTAIN means having not enough information to make decision at
   * current level, deferred decision to up.
   */
  AccessPermission[AccessPermission["ABSTAIN"] = 0] = "ABSTAIN";
  /** ALLOW means the permission is granted to transaction signer to call the function. */
  AccessPermission[AccessPermission["ALLOW"] = 1] = "ALLOW";
  /** DENY means the permission is denied to transaction signer to call the function. */
  AccessPermission[AccessPermission["DENY"] = 2] = "DENY";
  return AccessPermission;
}({});

/**
 * Gets the function signature from an ABI for a given method name
 * @param abi - The contract ABI
 * @param methodName - The name of the method to get the signature for
 * @param overloadIndex - Optional index for overloaded functions (0-based)
 * @returns The function signature in standard format (e.g. "methodName(uint256,address)")
 * @throws Error if method not found or if overloadIndex is required but not provided
 */
function getFunctionSignature(abi, methodName, overloadIndex) {
  var functions = abi.filter(function (x) {
    return x.type === "function" && x.name === methodName;
  });
  if (functions.length === 0) {
    throw new Error("Method ".concat(methodName, " not found in ABI."));
  }
  if (functions.length > 1 && overloadIndex === undefined) {
    throw new Error("Method ".concat(methodName, " has ").concat(functions.length, " overloads. Please specify overloadIndex (0-").concat(functions.length - 1, ")."));
  }
  var func = functions[overloadIndex || 0];
  var _getTypeString = function getTypeString(input) {
    if (input.type.startsWith("tuple")) {
      var _input$components;
      var components = (_input$components = input.components) === null || _input$components === void 0 ? void 0 : _input$components.map(function (comp) {
        return _getTypeString(comp);
      }).join(",");
      return "(".concat(components, ")");
    }
    return input.type;
  };
  var inputs = func.inputs.map(function (input) {
    return _getTypeString(input);
  }).join(",");
  return "".concat(methodName, "(").concat(inputs, ")");
}

var generateOperationSignature = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var deadline, ipIdAddress, methodType, ipRoyaltyVault, totalAmount, state, encodeData, wallet, chainId, baseConfig, royaltyTokenDistributionWorkflowsAddr, coreMetadataModuleAddr, licensingModuleAddr, derivativeWorkflowsAddr, licenseAttachmentWorkflowsAddr, registrationWorkflowsAddr, signatureConfigs, signatureRequest, _yield$getSignature, signature, _yield$getPermissionS, _signature;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          deadline = _ref.deadline, ipIdAddress = _ref.ipIdAddress, methodType = _ref.methodType, ipRoyaltyVault = _ref.ipRoyaltyVault, totalAmount = _ref.totalAmount, state = _ref.state, encodeData = _ref.encodeData, wallet = _ref.wallet, chainId = _ref.chainId;
          baseConfig = {
            ipId: ipIdAddress,
            deadline: deadline,
            state: toHex(0, {
              size: 32
            }),
            wallet: wallet,
            chainId: chain[chainId]
          }; // Validate required parameters based on method type
          if (!(methodType === SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS && (!ipRoyaltyVault || !state || !totalAmount || !encodeData))) {
            _context.next = 6;
            break;
          }
          throw new Error("ipRoyaltyVault, state, totalAmount, and encodeData are required for distributing royalty tokens.");
        case 6:
          if (!(methodType === SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH && !state)) {
            _context.next = 10;
            break;
          }
          throw new Error("State is required for registering PIL terms and attaching.");
        case 10:
          if (!(methodType === SignatureMethodType.BATCH_REGISTER_DERIVATIVE && (!state || !encodeData))) {
            _context.next = 12;
            break;
          }
          throw new Error("State and encodeData are required for batch registering derivative.");
        case 12:
          // Get contract addresses for the current chain
          royaltyTokenDistributionWorkflowsAddr = royaltyTokenDistributionWorkflowsAddress[chainId];
          coreMetadataModuleAddr = coreMetadataModuleAddress[chainId];
          licensingModuleAddr = licensingModuleAddress[chainId];
          derivativeWorkflowsAddr = derivativeWorkflowsAddress[chainId];
          licenseAttachmentWorkflowsAddr = licenseAttachmentWorkflowsAddress[chainId];
          registrationWorkflowsAddr = registrationWorkflowsAddress[chainId]; // Define signature configurations for each method type
          signatureConfigs = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
            }]
          })), SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            verifyingContract: ipIdAddress,
            deadline: deadline,
            state: state,
            to: ipRoyaltyVault,
            encodeData: encodeData
          })), SignatureMethodType.REGISTER_DERIVATIVE_IP, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivativeWithLicenseTokens")
            }]
          })), SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            state: state,
            permissions: [{
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: registrationWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }]
          })), SignatureMethodType.BATCH_REGISTER_DERIVATIVE, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            state: state,
            to: licensingModuleAddr,
            encodeData: encodeData,
            verifyingContract: ipIdAddress
          })); // Get the appropriate signature configuration for the requested method type
          signatureRequest = signatureConfigs[methodType]; // Generate the appropriate signature type based on the method
          if (!((methodType === SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS || methodType === SignatureMethodType.BATCH_REGISTER_DERIVATIVE) && signatureRequest)) {
            _context.next = 28;
            break;
          }
          _context.next = 23;
          return getSignature(signatureRequest);
        case 23:
          _yield$getSignature = _context.sent;
          signature = _yield$getSignature.signature;
          return _context.abrupt("return", signature);
        case 28:
          _context.next = 30;
          return getPermissionSignature(signatureRequest);
        case 30:
          _yield$getPermissionS = _context.sent;
          _signature = _yield$getPermissionS.signature;
          return _context.abrupt("return", _signature);
        case 33:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function generateOperationSignature(_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Transforms the registration request to the appropriate format based on workflow type.
 *
 * @remarks
 * This utility function serves as the entry point for processing both `register*` and
 * `mintAndRegister*` workflows. It analyzes the request structure and routes it to the
 * appropriate handler:
 *
 * - For minting + registration workflows (containing `spgNftContract`): Routes to `handleMintAndRegisterRequest`
 * - For registration-only workflows (containing `nftContract` and `tokenId`): Routes to `handleRegisterRequest`
 *
 * Each handler then applies the necessary transformations, validates inputs, calculates fees,
 * generates required signatures, and prepares the transaction data for submission.
 *
 * @throws Error if the request doesn't match any supported workflow pattern
 */

var transformRegistrationRequest = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var request, rpcClient, wallet, chainId;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          request = _ref.request, rpcClient = _ref.rpcClient, wallet = _ref.wallet, chainId = _ref.chainId;
          if (!("spgNftContract" in request)) {
            _context.next = 5;
            break;
          }
          return _context.abrupt("return", handleMintAndRegisterRequest({
            request: request,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          }));
        case 5:
          if (!("nftContract" in request && "tokenId" in request)) {
            _context.next = 7;
            break;
          }
          return _context.abrupt("return", handleRegisterRequest({
            request: request,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          }));
        case 7:
          throw new Error("Invalid registration request type");
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function transformRegistrationRequest(_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Handles a request for the `register*` contract methods.
 *
 * @remarks
 * This method processes various IP registration workflows including:
 *
 * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Registers derivative IP with license terms and royalty distribution
 * - {@link registerIpAndAttachPilTerms} - Registers IP and attaches PIL (Programmable IP License) terms
 * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Registers IP with license terms and royalty distribution
 * - {@link registerDerivativeIp} - Registers a derivative work based on existing IP
 * - {@link registerIpAndMakeDerivativeAndDeployRoyaltyVault} - Registers IP, creates derivative, and deploys royalty vault
 *
 * Key features:
 * - Automatically calculates all required license fees
 * - Generates appropriate operation signatures based on workflow type using EIP-712
 * - Does not support `multicall3` integration because the signature signer must be the transaction caller
 * - Uses SPG's native transaction handling for multicall
 * - Validates all input parameters
 */
var handleRegisterRequest = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
    var request, rpcClient, wallet, chainId, ipIdAddress, baseRequest, calculatedDeadline, royaltyTokenDistributionWorkflowsClient, licenseAttachmentWorkflowsClient, derivativeWorkflowsClient, _yield$validateLicens, licenseTermsData, requestWithTerms, derivData, totalFees;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          request = _ref3.request, rpcClient = _ref3.rpcClient, wallet = _ref3.wallet, chainId = _ref3.chainId;
          _context2.next = 3;
          return getIpIdAddress({
            nftContract: validateAddress(request.nftContract),
            tokenId: BigInt(request.tokenId),
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          });
        case 3:
          ipIdAddress = _context2.sent;
          baseRequest = {
            nftContract: validateAddress(request.nftContract),
            tokenId: BigInt(request.tokenId),
            ipMetadata: getIpMetadataForWorkflow(request.ipMetadata)
          };
          _context2.next = 7;
          return getCalculatedDeadline(rpcClient, request.deadline);
        case 7:
          calculatedDeadline = _context2.sent;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
          derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
          if (!("licenseTermsData" in request)) {
            _context2.next = 24;
            break;
          }
          _context2.next = 14;
          return validateLicenseTermsData(request.licenseTermsData, rpcClient);
        case 14:
          _yield$validateLicens = _context2.sent;
          licenseTermsData = _yield$validateLicens.licenseTermsData;
          requestWithTerms = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            licenseTermsData: licenseTermsData
          });
          if (!("royaltyShares" in request)) {
            _context2.next = 21;
            break;
          }
          _context2.next = 20;
          return transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest({
            request: requestWithTerms,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            chainId: chainId,
            wallet: wallet,
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            royaltyShares: request.royaltyShares
          });
        case 20:
          return _context2.abrupt("return", _context2.sent);
        case 21:
          _context2.next = 23;
          return transferRegisterIpAndAttachPilTermsRequest({
            request: requestWithTerms,
            licenseAttachmentWorkflowsClient: licenseAttachmentWorkflowsClient,
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId
          });
        case 23:
          return _context2.abrupt("return", _context2.sent);
        case 24:
          if (!("derivData" in request)) {
            _context2.next = 38;
            break;
          }
          _context2.next = 27;
          return validateDerivativeData({
            derivativeDataInput: request.derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 27:
          derivData = _context2.sent;
          _context2.next = 30;
          return calculateDerivativeMintingFee({
            derivData: derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 30:
          totalFees = _context2.sent;
          if (!("royaltyShares" in request)) {
            _context2.next = 35;
            break;
          }
          _context2.next = 34;
          return transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest({
            request: _objectSpread2(_objectSpread2({}, baseRequest), {}, {
              derivData: derivData
            }),
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            totalFees: totalFees,
            royaltyShares: request.royaltyShares
          });
        case 34:
          return _context2.abrupt("return", _context2.sent);
        case 35:
          _context2.next = 37;
          return transferRegisterDerivativeIpRequest({
            request: _objectSpread2(_objectSpread2({}, baseRequest), {}, {
              derivData: derivData
            }),
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId,
            derivativeWorkflowsClient: derivativeWorkflowsClient,
            totalFees: totalFees
          });
        case 37:
          return _context2.abrupt("return", _context2.sent);
        case 38:
          throw new Error("Invalid register request type");
        case 39:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function handleRegisterRequest(_x2) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Transforms a request for the `registerDerivativeIp` contract method.
 */
var transferRegisterDerivativeIpRequest = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {
    var request, calculatedDeadline, ipIdAddress, wallet, chainId, derivativeWorkflowsClient, totalFees, signature, transformRequest;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          request = _ref5.request, calculatedDeadline = _ref5.calculatedDeadline, ipIdAddress = _ref5.ipIdAddress, wallet = _ref5.wallet, chainId = _ref5.chainId, derivativeWorkflowsClient = _ref5.derivativeWorkflowsClient, totalFees = _ref5.totalFees;
          _context3.next = 3;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_DERIVATIVE_IP,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 3:
          signature = _context3.sent;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndRegister: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context3.abrupt("return", {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            spenders: [{
              address: derivativeWorkflowsClient.address,
              amount: totalFees
            }],
            totalFees: totalFees,
            contractCall: function contractCall() {
              return derivativeWorkflowsClient.registerIpAndMakeDerivative(transformRequest);
            },
            workflowClient: derivativeWorkflowsClient,
            encodedTxData: {
              to: derivativeWorkflowsClient.address,
              data: encodeFunctionData({
                abi: derivativeWorkflowsAbi,
                functionName: "registerIpAndMakeDerivative",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.derivData, transformRequest.ipMetadata, transformRequest.sigMetadataAndRegister]
              })
            }
          });
        case 6:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function transferRegisterDerivativeIpRequest(_x3) {
    return _ref6.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerIpAndAttachPilTermsAndDeployRoyaltyVault` contract method.
 */
var transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref7) {
    var request, royaltyTokenDistributionWorkflowsClient, chainId, wallet, calculatedDeadline, ipIdAddress, royaltyShares, signature, transformRequest;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          request = _ref7.request, royaltyTokenDistributionWorkflowsClient = _ref7.royaltyTokenDistributionWorkflowsClient, chainId = _ref7.chainId, wallet = _ref7.wallet, calculatedDeadline = _ref7.calculatedDeadline, ipIdAddress = _ref7.ipIdAddress, royaltyShares = _ref7.royaltyShares;
          _context4.next = 3;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 3:
          signature = _context4.sent;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndAttachAndConfig: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context4.abrupt("return", {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.registerIpAndAttachPilTermsAndDeployRoyaltyVault(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsClient.address,
              data: encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "registerIpAndAttachPILTermsAndDeployRoyaltyVault",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.sigMetadataAndAttachAndConfig]
              })
            },
            extraData: {
              royaltyShares: royaltyShares,
              deadline: calculatedDeadline
            }
          });
        case 6:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest(_x4) {
    return _ref8.apply(this, arguments);
  };
}();
/**
 * Transforms a request for the `registerIpAndAttachPilTerms` contract method.
 */
var transferRegisterIpAndAttachPilTermsRequest = /*#__PURE__*/function () {
  var _ref0 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref9) {
    var request, licenseAttachmentWorkflowsClient, calculatedDeadline, ipIdAddress, wallet, chainId, signature, transformRequest;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          request = _ref9.request, licenseAttachmentWorkflowsClient = _ref9.licenseAttachmentWorkflowsClient, calculatedDeadline = _ref9.calculatedDeadline, ipIdAddress = _ref9.ipIdAddress, wallet = _ref9.wallet, chainId = _ref9.chainId;
          _context5.next = 3;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 3:
          signature = _context5.sent;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndAttachAndConfig: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context5.abrupt("return", {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return licenseAttachmentWorkflowsClient.registerIpAndAttachPilTerms(transformRequest);
            },
            workflowClient: licenseAttachmentWorkflowsClient,
            encodedTxData: {
              to: licenseAttachmentWorkflowsClient.address,
              data: encodeFunctionData({
                abi: licenseAttachmentWorkflowsAbi,
                functionName: "registerIpAndAttachPILTerms",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.sigMetadataAndAttachAndConfig]
              })
            }
          });
        case 6:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return function transferRegisterIpAndAttachPilTermsRequest(_x5) {
    return _ref0.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerIpAndMakeDerivativeAndDeployRoyaltyVault` contract method.
 */
var transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest = /*#__PURE__*/function () {
  var _ref10 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref1) {
    var request, calculatedDeadline, ipIdAddress, wallet, chainId, royaltyTokenDistributionWorkflowsClient, totalFees, royaltyShares, signature, transformRequest;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          request = _ref1.request, calculatedDeadline = _ref1.calculatedDeadline, ipIdAddress = _ref1.ipIdAddress, wallet = _ref1.wallet, chainId = _ref1.chainId, royaltyTokenDistributionWorkflowsClient = _ref1.royaltyTokenDistributionWorkflowsClient, totalFees = _ref1.totalFees, royaltyShares = _ref1.royaltyShares;
          _context6.next = 3;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 3:
          signature = _context6.sent;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndRegister: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context6.abrupt("return", {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            spenders: [{
              address: royaltyTokenDistributionWorkflowsClient.address,
              amount: totalFees
            }],
            totalFees: totalFees,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVault(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsClient.address,
              data: encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "registerIpAndMakeDerivativeAndDeployRoyaltyVault",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.derivData, transformRequest.sigMetadataAndRegister]
              })
            },
            extraData: {
              royaltyShares: royaltyShares,
              deadline: calculatedDeadline
            }
          });
        case 6:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return function transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest(_x6) {
    return _ref10.apply(this, arguments);
  };
}();
/**
 * Handles a request for the `mintAndRegister*` contract methods.
 *
 * @remarks
 * This method processes various mint and register workflows including:
 *
 * - {@link mintAndRegisterIpAndMakeDerivative} - Mints NFT and registers IP with derivative creation
 * - {@link mintAndRegisterIpAssetWithPilTerms} - Mints NFT and registers IP with PIL terms
 * - {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} - Mints, registers, attaches terms and distributes royalties
 * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens} - Mints, registers with derivative and distributes royalties
 *
 * Key features and optimizations:
 * - Automatically calculates all required fees (SPG mint fees and license mint fees)
 * - Transaction batching strategy varies by contract type:
 *   - Public minting contracts: Uses `multicall3` for gas-efficient batching
 *   - Private minting contracts: Uses SPG's native `multicall` implementation
 *   - Special case: {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} always
 *     uses SPG's native multicall due to specific signature requirements
 */
var handleMintAndRegisterRequest = /*#__PURE__*/function () {
  var _ref12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref11) {
    var _request$allowDuplica;
    var request, rpcClient, wallet, chainId, royaltyTokenDistributionWorkflowsClient, licenseAttachmentWorkflowsClient, derivativeWorkflowsClient, isPublicMinting, nftMintFee, baseRequest, _yield$validateLicens2, licenseTermsData, requestWithTerms, derivData, totalDerivativeMintingFee, requestWithDeriv;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          request = _ref11.request, rpcClient = _ref11.rpcClient, wallet = _ref11.wallet, chainId = _ref11.chainId;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
          derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
          _context7.next = 6;
          return getPublicMinting(request.spgNftContract, rpcClient);
        case 6:
          isPublicMinting = _context7.sent;
          _context7.next = 9;
          return calculateSPGWipMintFee(new SpgnftImplReadOnlyClient(rpcClient, request.spgNftContract));
        case 9:
          nftMintFee = _context7.sent;
          baseRequest = {
            spgNftContract: validateAddress(request.spgNftContract),
            recipient: validateAddress(request.recipient || wallet.account.address),
            ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
            allowDuplicates: (_request$allowDuplica = request.allowDuplicates) !== null && _request$allowDuplica !== void 0 ? _request$allowDuplica : true
          };
          if (!("licenseTermsData" in request)) {
            _context7.next = 20;
            break;
          }
          _context7.next = 14;
          return validateLicenseTermsData(request.licenseTermsData, rpcClient);
        case 14:
          _yield$validateLicens2 = _context7.sent;
          licenseTermsData = _yield$validateLicens2.licenseTermsData;
          requestWithTerms = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            licenseTermsData: licenseTermsData
          });
          if (!("royaltyShares" in request)) {
            _context7.next = 19;
            break;
          }
          return _context7.abrupt("return", transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithTerms), {}, {
              royaltyShares: request.royaltyShares
            }),
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            nftMintFee: nftMintFee
          }));
        case 19:
          return _context7.abrupt("return", transferMintAndRegisterIpAssetWithPilTermsRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithTerms), {}, {
              licenseTermsData: licenseTermsData
            }),
            licenseAttachmentWorkflowsClient: licenseAttachmentWorkflowsClient,
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting
          }));
        case 20:
          if (!("derivData" in request)) {
            _context7.next = 31;
            break;
          }
          _context7.next = 23;
          return validateDerivativeData({
            derivativeDataInput: request.derivData,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          });
        case 23:
          derivData = _context7.sent;
          _context7.next = 26;
          return calculateDerivativeMintingFee({
            derivData: derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 26:
          totalDerivativeMintingFee = _context7.sent;
          requestWithDeriv = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            derivData: derivData
          });
          if (!("royaltyShares" in request)) {
            _context7.next = 30;
            break;
          }
          return _context7.abrupt("return", transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithDeriv), {}, {
              royaltyShares: request.royaltyShares
            }),
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting,
            totalDerivativeMintingFee: totalDerivativeMintingFee,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient
          }));
        case 30:
          return _context7.abrupt("return", transferMintAndRegisterIpAndMakeDerivativeRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithDeriv), {}, {
              derivData: derivData
            }),
            derivativeWorkflowsClient: derivativeWorkflowsClient,
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting,
            totalDerivativeMintingFee: totalDerivativeMintingFee
          }));
        case 31:
          throw new Error("Invalid mint and register request type");
        case 32:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return function handleMintAndRegisterRequest(_x7) {
    return _ref12.apply(this, arguments);
  };
}();
/**
 * Transforms a request for the `mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens` contract method.
 */
var transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest = function transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest(_ref13) {
  var request = _ref13.request,
    royaltyTokenDistributionWorkflowsClient = _ref13.royaltyTokenDistributionWorkflowsClient,
    nftMintFee = _ref13.nftMintFee;
  var _getRoyaltyShares = getRoyaltyShares(request.royaltyShares),
    royaltyShares = _getRoyaltyShares.royaltyShares;
  var transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
    royaltyShares: royaltyShares
  });
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: transformRequest,
    // Because mint tokens is given `msg.sender` as the recipient, so we need to set `useMulticall3` to false.
    isUseMulticall3: false,
    contractCall: function contractCall() {
      return royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(transformRequest);
    },
    spenders: [{
      address: transformRequest.spgNftContract,
      amount: nftMintFee
    }],
    totalFees: nftMintFee,
    encodedTxData: {
      to: royaltyTokenDistributionWorkflowsClient.address,
      data: encodeFunctionData({
        abi: royaltyTokenDistributionWorkflowsAbi,
        functionName: "mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",
        args: [transformRequest.spgNftContract, transformRequest.recipient, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.royaltyShares, transformRequest.allowDuplicates]
      })
    },
    workflowClient: royaltyTokenDistributionWorkflowsClient
  };
};
/**
 * Transforms a request for the `mintAndRegisterIpAssetWithPilTerms` contract method.
 */
var transferMintAndRegisterIpAssetWithPilTermsRequest = function transferMintAndRegisterIpAssetWithPilTermsRequest(_ref14) {
  var request = _ref14.request,
    licenseAttachmentWorkflowsClient = _ref14.licenseAttachmentWorkflowsClient,
    nftMintFee = _ref14.nftMintFee,
    isPublicMinting = _ref14.isPublicMinting;
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: request,
    isUseMulticall3: isPublicMinting,
    spenders: [{
      address: request.spgNftContract,
      amount: nftMintFee
    }],
    totalFees: nftMintFee,
    encodedTxData: {
      to: licenseAttachmentWorkflowsClient.address,
      data: encodeFunctionData({
        abi: licenseAttachmentWorkflowsAbi,
        functionName: "mintAndRegisterIpAndAttachPILTerms",
        args: [request.spgNftContract, request.recipient, request.ipMetadata, request.licenseTermsData, request.allowDuplicates]
      })
    },
    contractCall: function contractCall() {
      return licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTerms(request);
    },
    workflowClient: licenseAttachmentWorkflowsClient
  };
};
/**
 * Transforms a request for the `mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens` contract method.
 */
var transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest = function transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest(_ref15) {
  var request = _ref15.request,
    nftMintFee = _ref15.nftMintFee,
    isPublicMinting = _ref15.isPublicMinting,
    totalDerivativeMintingFee = _ref15.totalDerivativeMintingFee,
    royaltyTokenDistributionWorkflowsClient = _ref15.royaltyTokenDistributionWorkflowsClient;
  var _getRoyaltyShares2 = getRoyaltyShares(request.royaltyShares),
    royaltyShares = _getRoyaltyShares2.royaltyShares;
  /**
   * TODO: Consider the scenario where the SPG token is WIP and the derivative token is ERC20.
   * The SDK should handle both cases in the `contractCallWithFees` method.
   * Currently, it only supports WIP tokens and does not handle ERC20 tokens, such as approving ERC20 tokens.
   */
  var transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
    royaltyShares: royaltyShares
  });
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: transformRequest,
    isUseMulticall3: isPublicMinting,
    spenders: [{
      address: royaltyTokenDistributionWorkflowsClient.address,
      amount: totalDerivativeMintingFee
    }, {
      address: request.spgNftContract,
      amount: nftMintFee
    }],
    totalFees: totalDerivativeMintingFee + nftMintFee,
    encodedTxData: {
      to: royaltyTokenDistributionWorkflowsClient.address,
      data: encodeFunctionData({
        abi: royaltyTokenDistributionWorkflowsAbi,
        functionName: "mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",
        args: [request.spgNftContract, request.recipient, request.ipMetadata, request.derivData, request.royaltyShares, request.allowDuplicates]
      })
    },
    workflowClient: royaltyTokenDistributionWorkflowsClient,
    contractCall: function contractCall() {
      return royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(transformRequest);
    }
  };
};
/**
 * Transforms a request for the `mintAndRegisterIpAndMakeDerivative` contract method.
 */

var transferMintAndRegisterIpAndMakeDerivativeRequest = function transferMintAndRegisterIpAndMakeDerivativeRequest(_ref16) {
  var request = _ref16.request,
    derivativeWorkflowsClient = _ref16.derivativeWorkflowsClient,
    nftMintFee = _ref16.nftMintFee,
    isPublicMinting = _ref16.isPublicMinting,
    totalDerivativeMintingFee = _ref16.totalDerivativeMintingFee;
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: request,
    isUseMulticall3: isPublicMinting,
    spenders: [{
      address: derivativeWorkflowsClient.address,
      amount: totalDerivativeMintingFee
    }, {
      address: request.spgNftContract,
      amount: nftMintFee
    }],
    totalFees: totalDerivativeMintingFee + nftMintFee,
    encodedTxData: {
      to: derivativeWorkflowsClient.address,
      data: encodeFunctionData({
        abi: derivativeWorkflowsAbi,
        functionName: "mintAndRegisterIpAndMakeDerivative",
        args: [request.spgNftContract, request.derivData, request.ipMetadata, request.recipient, request.allowDuplicates]
      })
    },
    contractCall: function contractCall() {
      return derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivative(request);
    },
    workflowClient: derivativeWorkflowsClient
  };
};
/**
 * Transforms a request for the `distributeRoyaltyTokens` contract method.
 */
var transferDistributeRoyaltyTokensRequest = /*#__PURE__*/function () {
  var _ref18 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref17) {
    var request, rpcClient, wallet, chainId, ipId, deadline, ipRoyaltyVault, totalAmount, calculatedDeadline, ipRoyaltyVaultImpl, balance, royaltyTokenDistributionWorkflowsClient, ipAccount, _yield$ipAccount$stat, state, signatureApproveRoyaltyTokens, transformRequest;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          request = _ref17.request, rpcClient = _ref17.rpcClient, wallet = _ref17.wallet, chainId = _ref17.chainId;
          ipId = request.ipId, deadline = request.deadline, ipRoyaltyVault = request.ipRoyaltyVault, totalAmount = request.totalAmount;
          _context8.next = 4;
          return getCalculatedDeadline(rpcClient, deadline);
        case 4:
          calculatedDeadline = _context8.sent;
          ipRoyaltyVaultImpl = new IpRoyaltyVaultImplReadOnlyClient(rpcClient, ipRoyaltyVault);
          _context8.next = 8;
          return ipRoyaltyVaultImpl.balanceOf({
            account: ipId
          });
        case 8:
          balance = _context8.sent;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          if (!(BigInt(balance) < BigInt(totalAmount))) {
            _context8.next = 12;
            break;
          }
          throw new Error("The balance of the IP account in the IP Royalty Vault is insufficient to distribute the royalty tokens.");
        case 12:
          ipAccount = new IpAccountImplClient(rpcClient, wallet, validateAddress(ipId));
          _context8.next = 15;
          return ipAccount.state();
        case 15:
          _yield$ipAccount$stat = _context8.sent;
          state = _yield$ipAccount$stat.result;
          _context8.next = 19;
          return generateOperationSignature({
            ipIdAddress: ipId,
            methodType: SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS,
            deadline: calculatedDeadline,
            ipRoyaltyVault: ipRoyaltyVault,
            totalAmount: totalAmount,
            state: state,
            encodeData: encodeFunctionData({
              abi: ipRoyaltyVaultImplAbi,
              functionName: "approve",
              args: [royaltyTokenDistributionWorkflowsAddress[chainId], BigInt(totalAmount)]
            }),
            wallet: wallet,
            chainId: chainId
          });
        case 19:
          signatureApproveRoyaltyTokens = _context8.sent;
          transformRequest = {
            ipId: ipId,
            royaltyShares: request.royaltyShares,
            sigApproveRoyaltyTokens: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signatureApproveRoyaltyTokens
            }
          };
          return _context8.abrupt("return", {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.distributeRoyaltyTokens(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsAddress[chainId],
              data: encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "distributeRoyaltyTokens",
                args: [transformRequest.ipId, transformRequest.royaltyShares, transformRequest.sigApproveRoyaltyTokens]
              })
            }
          });
        case 22:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return function transferDistributeRoyaltyTokensRequest(_x8) {
    return _ref18.apply(this, arguments);
  };
}();
var prepareRoyaltyTokensDistributionRequests = /*#__PURE__*/function () {
  var _ref20 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref19) {
    var royaltyDistributionRequests, ipRegisteredLog, ipRoyaltyVault, rpcClient, wallet, chainId, results, _iterator, _step, _loop;
    return _regeneratorRuntime().wrap(function _callee9$(_context0) {
      while (1) switch (_context0.prev = _context0.next) {
        case 0:
          royaltyDistributionRequests = _ref19.royaltyDistributionRequests, ipRegisteredLog = _ref19.ipRegisteredLog, ipRoyaltyVault = _ref19.ipRoyaltyVault, rpcClient = _ref19.rpcClient, wallet = _ref19.wallet, chainId = _ref19.chainId;
          if (!(royaltyDistributionRequests.length === 0)) {
            _context0.next = 3;
            break;
          }
          return _context0.abrupt("return", []);
        case 3:
          results = [];
          _iterator = _createForOfIteratorHelper(royaltyDistributionRequests);
          _context0.prev = 5;
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var req, filterIpIdAndTokenId, _req$royaltyShares, _getRoyaltyShares3, royaltyShares, totalAmount, calculatedDeadline, response;
            return _regeneratorRuntime().wrap(function _loop$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  req = _step.value;
                  filterIpIdAndTokenId = ipRegisteredLog.find(function (_ref21) {
                    var tokenContract = _ref21.tokenContract,
                      tokenId = _ref21.tokenId;
                    return tokenContract === req.nftContract && tokenId === req.tokenId;
                  });
                  if (!filterIpIdAndTokenId) {
                    _context9.next = 11;
                    break;
                  }
                  _getRoyaltyShares3 = getRoyaltyShares((_req$royaltyShares = req.royaltyShares) !== null && _req$royaltyShares !== void 0 ? _req$royaltyShares : []), royaltyShares = _getRoyaltyShares3.royaltyShares, totalAmount = _getRoyaltyShares3.totalAmount;
                  _context9.next = 6;
                  return getCalculatedDeadline(rpcClient, req.deadline);
                case 6:
                  calculatedDeadline = _context9.sent;
                  _context9.next = 9;
                  return transferDistributeRoyaltyTokensRequest({
                    request: {
                      ipId: filterIpIdAndTokenId.ipId,
                      ipRoyaltyVault: ipRoyaltyVault.find(function (item) {
                        return item.ipId === filterIpIdAndTokenId.ipId;
                      }).ipRoyaltyVault,
                      royaltyShares: royaltyShares,
                      totalAmount: totalAmount,
                      deadline: calculatedDeadline
                    },
                    rpcClient: rpcClient,
                    wallet: wallet,
                    chainId: chainId
                  });
                case 9:
                  response = _context9.sent;
                  results.push(response);
                case 11:
                case "end":
                  return _context9.stop();
              }
            }, _loop);
          });
          _iterator.s();
        case 8:
          if ((_step = _iterator.n()).done) {
            _context0.next = 12;
            break;
          }
          return _context0.delegateYield(_loop(), "t0", 10);
        case 10:
          _context0.next = 8;
          break;
        case 12:
          _context0.next = 17;
          break;
        case 14:
          _context0.prev = 14;
          _context0.t1 = _context0["catch"](5);
          _iterator.e(_context0.t1);
        case 17:
          _context0.prev = 17;
          _iterator.f();
          return _context0.finish(17);
        case 20:
          return _context0.abrupt("return", results);
        case 21:
        case "end":
          return _context0.stop();
      }
    }, _callee9, null, [[5, 14, 17, 20]]);
  }));
  return function prepareRoyaltyTokensDistributionRequests(_x9) {
    return _ref20.apply(this, arguments);
  };
}();

var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAssetClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.accessControllerClient = new AccessControllerClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
    this.licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
    this.derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
    this.royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
    this.royaltyModuleEventClient = new RoyaltyModuleEventClient(rpcClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.spgNftClient = new SpgnftImplReadOnlyClient(rpcClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = this.wallet.account.address;
  }
  return _createClass(IPAssetClient, [{
    key: "generateCreatorMetadata",
    value: function generateCreatorMetadata(creator) {
      return creator;
    }
  }, {
    key: "generateIpMetadata",
    value: function generateIpMetadata(metadata) {
      return metadata;
    }

    /**
     * Registers an NFT as IP, creating a corresponding IP record.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
  }, {
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, tokenId, ipIdAddress, isRegistered, object, calculatedDeadline, signature, _request$txOptions2, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context.next = 4;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              ipIdAddress = _context.sent;
              _context.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context.sent;
              if (!isRegistered) {
                _context.next = 10;
                break;
              }
              return _context.abrupt("return", {
                ipId: ipIdAddress
              });
            case 10:
              object = {
                tokenId: tokenId,
                nftContract: validateAddress(request.nftContract),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadata: {
                  signer: zeroAddress,
                  deadline: BigInt(0),
                  signature: zeroHash
                }
              };
              if (!request.ipMetadata) {
                _context.next = 19;
                break;
              }
              _context.next = 14;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 14:
              calculatedDeadline = _context.sent;
              _context.next = 17;
              return generateOperationSignature({
                ipIdAddress: ipIdAddress,
                methodType: SignatureMethodType.REGISTER,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 17:
              signature = _context.sent;
              object.sigMetadata = {
                signer: validateAddress(this.walletAddress),
                deadline: calculatedDeadline,
                signature: signature
              };
            case 19:
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 27;
                break;
              }
              if (!request.ipMetadata) {
                _context.next = 24;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.registrationWorkflowsClient.registerIpEncode(object)
              });
            case 24:
              return _context.abrupt("return", {
                encodedTxData: this.ipAssetRegistryClient.registerEncode({
                  tokenContract: object.nftContract,
                  tokenId: object.tokenId,
                  chainid: BigInt(chain[this.chainId])
                })
              });
            case 25:
              _context.next = 45;
              break;
            case 27:
              if (!request.ipMetadata) {
                _context.next = 33;
                break;
              }
              _context.next = 30;
              return this.registrationWorkflowsClient.registerIp(object);
            case 30:
              txHash = _context.sent;
              _context.next = 36;
              break;
            case 33:
              _context.next = 35;
              return this.ipAssetRegistryClient.register({
                tokenContract: object.nftContract,
                tokenId: object.tokenId,
                chainid: BigInt(this.chainId)
              });
            case 35:
              txHash = _context.sent;
            case 36:
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 44;
                break;
              }
              _context.next = 39;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 39:
              txReceipt = _context.sent;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              return _context.abrupt("return", _objectSpread2({
                txHash: txHash
              }, log));
            case 44:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 45:
              _context.next = 50;
              break;
            case 47:
              _context.prev = 47;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register IP");
            case 50:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 47]]);
      }));
      function register(_x) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * Batch registers an NFT as IP, creating a corresponding IP record.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "batchRegister",
    value: (function () {
      var _batchRegister = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _this = this;
        var _request$txOptions3, contracts, spgContracts, encodedTxData, _iterator, _step, arg, result, spgTxHash, txHash, results, processTransaction;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              contracts = [];
              spgContracts = [];
              _iterator = _createForOfIteratorHelper(request.args);
              _context3.prev = 4;
              _iterator.s();
            case 6:
              if ((_step = _iterator.n()).done) {
                _context3.next = 21;
                break;
              }
              arg = _step.value;
              _context3.prev = 8;
              _context3.next = 11;
              return this.register(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 11:
              result = _context3.sent;
              encodedTxData = result.encodedTxData.data;
              _context3.next = 18;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](8);
              throw new Error(_context3.t0.message.replace("Failed to register IP:", "").trim());
            case 18:
              if (arg.ipMetadata) {
                spgContracts.push(encodedTxData);
              } else {
                contracts.push({
                  target: this.ipAssetRegistryClient.address,
                  allowFailure: false,
                  callData: encodedTxData
                });
              }
            case 19:
              _context3.next = 6;
              break;
            case 21:
              _context3.next = 26;
              break;
            case 23:
              _context3.prev = 23;
              _context3.t1 = _context3["catch"](4);
              _iterator.e(_context3.t1);
            case 26:
              _context3.prev = 26;
              _iterator.f();
              return _context3.finish(26);
            case 29:
              if (!(spgContracts.length > 0)) {
                _context3.next = 33;
                break;
              }
              _context3.next = 32;
              return this.registrationWorkflowsClient.multicall({
                data: spgContracts
              });
            case 32:
              spgTxHash = _context3.sent;
            case 33:
              if (!(contracts.length > 0)) {
                _context3.next = 37;
                break;
              }
              _context3.next = 36;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 36:
              txHash = _context3.sent;
            case 37:
              results = [];
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 49;
                break;
              }
              processTransaction = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hash, contractType) {
                  var txReceipt, eventResults;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return _this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                          hash: hash
                        }));
                      case 2:
                        txReceipt = _context2.sent;
                        eventResults = _this.getIpIdAndTokenIdsFromEvent(txReceipt, contractType);
                        results.push.apply(results, _toConsumableArray(eventResults));
                      case 5:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }));
                return function processTransaction(_x3, _x4) {
                  return _ref.apply(this, arguments);
                };
              }();
              if (!txHash) {
                _context3.next = 43;
                break;
              }
              _context3.next = 43;
              return processTransaction(txHash, "nftContract");
            case 43:
              if (!spgTxHash) {
                _context3.next = 46;
                break;
              }
              _context3.next = 46;
              return processTransaction(spgTxHash, "spgNftContract");
            case 46:
              return _context3.abrupt("return", {
                txHash: txHash,
                spgTxHash: spgTxHash,
                results: results
              });
            case 49:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 50:
              _context3.next = 55;
              break;
            case 52:
              _context3.prev = 52;
              _context3.t2 = _context3["catch"](0);
              handleError(_context3.t2, "Failed to batch register IP");
            case 55:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 52], [4, 23, 26, 29], [8, 15]]);
      }));
      function batchRegister(_x2) {
        return _batchRegister.apply(this, arguments);
      }
      return batchRegister;
    }()
    /**
     * Registers a derivative directly with parent IP's license terms, without needing license tokens,
     * and attaches the license terms of the parent IPs to the derivative IP.
     * The license terms must be attached to the parent IP before calling this function.
     * All IPs attached default license terms by default.
     * The derivative IP owner must be the caller or an authorized operator.
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _this2 = this;
        var _request$txOptions4, isChildIpIdRegistered, derivativeData, object, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context4.sent;
              if (isChildIpIdRegistered) {
                _context4.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              _context4.next = 8;
              return validateDerivativeData({
                derivativeDataInput: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 8:
              derivativeData = _context4.sent;
              object = _objectSpread2({
                childIpId: request.childIpId
              }, derivativeData);
              encodedTxData = this.licensingModuleClient.registerDerivativeEncode(object);
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context4.next = 15;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 15:
              contractCall = function contractCall() {
                return _this2.licensingModuleClient.registerDerivative(object);
              };
              return _context4.abrupt("return", this.handleRegistrationWithFees({
                sender: this.walletAddress,
                derivData: object,
                contractCall: contractCall,
                txOptions: request.txOptions,
                encodedTxs: [encodedTxData],
                spgSpenderAddress: this.royaltyModuleEventClient.address,
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                })
              }));
            case 17:
              _context4.next = 22;
              break;
            case 19:
              _context4.prev = 19;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register derivative");
            case 22:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 19]]);
      }));
      function registerDerivative(_x5) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * Batch registers a derivative directly with parent IP's license terms.
     */
    )
  }, {
    key: "batchRegisterDerivative",
    value: (function () {
      var _batchRegisterDerivative = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions5, contracts, licenseModuleAddress, _iterator2, _step2, arg, calculatedDeadline, ipAccount, data, _yield$ipAccount$stat, state, signature, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              contracts = [];
              licenseModuleAddress = validateAddress(this.licensingModuleClient.address);
              _iterator2 = _createForOfIteratorHelper(request.args);
              _context5.prev = 4;
              _iterator2.s();
            case 6:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 31;
                break;
              }
              arg = _step2.value;
              _context5.prev = 8;
              _context5.next = 11;
              return this.registerDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 11:
              _context5.next = 16;
              break;
            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](8);
              throw new Error(_context5.t0.message.replace("Failed to register derivative:", "").trim());
            case 16:
              _context5.next = 18;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 18:
              calculatedDeadline = _context5.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(arg.childIpId));
              data = encodeFunctionData({
                abi: licensingModuleAbi,
                functionName: "registerDerivative",
                args: [arg.childIpId, arg.parentIpIds, arg.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }), arg.licenseTemplate || this.licenseTemplateClient.address, zeroAddress, BigInt(arg.maxMintingFee || 0), Number(arg.maxRts || MAX_ROYALTY_TOKEN), getRevenueShare(arg.maxRevenueShare || 100, RevShareType.MAX_REVENUE_SHARE)]
              });
              _context5.next = 23;
              return ipAccount.state();
            case 23:
              _yield$ipAccount$stat = _context5.sent;
              state = _yield$ipAccount$stat.result;
              _context5.next = 27;
              return generateOperationSignature({
                ipIdAddress: arg.childIpId,
                methodType: SignatureMethodType.BATCH_REGISTER_DERIVATIVE,
                state: state,
                encodeData: data,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 27:
              signature = _context5.sent;
              contracts.push({
                target: arg.childIpId,
                allowFailure: false,
                callData: encodeFunctionData({
                  abi: ipAccountImplAbi,
                  functionName: "executeWithSig",
                  args: [licenseModuleAddress, BigInt(0), data, this.wallet.account.address, calculatedDeadline, signature]
                })
              });
            case 29:
              _context5.next = 6;
              break;
            case 31:
              _context5.next = 36;
              break;
            case 33:
              _context5.prev = 33;
              _context5.t1 = _context5["catch"](4);
              _iterator2.e(_context5.t1);
            case 36:
              _context5.prev = 36;
              _iterator2.f();
              return _context5.finish(36);
            case 39:
              _context5.next = 41;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 41:
              txHash = _context5.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.waitForTransaction)) {
                _context5.next = 48;
                break;
              }
              _context5.next = 45;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 45:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 48:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 49:
              _context5.next = 54;
              break;
            case 51:
              _context5.prev = 51;
              _context5.t2 = _context5["catch"](0);
              handleError(_context5.t2, "Failed to batch register derivative");
            case 54:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 51], [4, 33, 36, 39], [8, 13]]);
      }));
      function batchRegisterDerivative(_x6) {
        return _batchRegisterDerivative.apply(this, arguments);
      }
      return batchRegisterDerivative;
    }()
    /**
     * Registers a derivative with license tokens. The derivative IP is registered with license tokens minted from the parent IP's license terms.
     * The license terms of the parent IPs issued with license tokens are attached to the derivative IP.
     * The caller must be the derivative IP owner or an authorized operator.
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _request$txOptions6, req, isChildIpIdRegistered, _request$txOptions7, txHash;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              req = {
                childIpId: validateAddress(request.childIpId),
                licenseTokenIds: request.licenseTokenIds.map(function (id) {
                  return BigInt(id);
                }),
                royaltyContext: zeroAddress,
                maxRts: Number(request.maxRts)
              };
              validateMaxRts(req.maxRts);
              _context6.next = 5;
              return this.isRegistered(request.childIpId);
            case 5:
              isChildIpIdRegistered = _context6.sent;
              if (isChildIpIdRegistered) {
                _context6.next = 8;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 8:
              if (!(request.licenseTokenIds.length === 0)) {
                _context6.next = 10;
                break;
              }
              throw new Error("The licenseTokenIds must be provided.");
            case 10:
              _context6.next = 12;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 12:
              request.licenseTokenIds = _context6.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.encodedTxDataOnly)) {
                _context6.next = 17;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: this.licensingModuleClient.registerDerivativeWithLicenseTokensEncode(req)
              });
            case 17:
              _context6.next = 19;
              return this.licensingModuleClient.registerDerivativeWithLicenseTokens(req);
            case 19:
              txHash = _context6.sent;
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.waitForTransaction)) {
                _context6.next = 26;
                break;
              }
              _context6.next = 23;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 23:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 26:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 27:
              _context6.next = 32;
              break;
            case 29:
              _context6.prev = 29;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to register derivative with license tokens");
            case 32:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 29]]);
      }));
      function registerDerivativeWithLicenseTokens(_x7) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * Mint an NFT from a collection and register it as an IP.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "mintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _mintAndRegisterIpAssetWithPilTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {
        var _this3 = this;
        var _request$txOptions8, _yield$validateLicens, licenseTerms, _yield$transformRegis, transformRequest, encodedTxData, contractCall, rsp, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient);
            case 3:
              _yield$validateLicens = _context7.sent;
              licenseTerms = _yield$validateLicens.licenseTerms;
              _context7.next = 7;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 7:
              _yield$transformRegis = _context7.sent;
              transformRequest = _yield$transformRegis.transformRequest;
              encodedTxData = this.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTermsEncode(transformRequest);
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.encodedTxDataOnly)) {
                _context7.next = 12;
                break;
              }
              return _context7.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 12:
              contractCall = function contractCall() {
                return _this3.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTerms(transformRequest);
              };
              _context7.next = 15;
              return this.handleRegistrationWithFees({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgNftContract: transformRequest.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 15:
              rsp = _context7.sent;
              if (!rsp.receipt) {
                _context7.next = 23;
                break;
              }
              _context7.next = 19;
              return this.getLicenseTermsId(licenseTerms);
            case 19:
              licenseTermsIds = _context7.sent;
              return _context7.abrupt("return", _objectSpread2(_objectSpread2({}, rsp), {}, {
                licenseTermsIds: licenseTermsIds
              }));
            case 23:
              return _context7.abrupt("return", rsp);
            case 24:
              _context7.next = 29;
              break;
            case 26:
              _context7.prev = 26;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to mint and register IP and attach PIL terms");
            case 29:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 26]]);
      }));
      function mintAndRegisterIpAssetWithPilTerms(_x8) {
        return _mintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Batch mint an NFT from a collection and register it as an IP.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "batchMintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _batchMintAndRegisterIpAssetWithPilTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var _request$txOptions9, calldata, _iterator3, _step3, arg, result, txHash, txReceipt, results, j, licenseTerms, licenseTermsData, i, licenseTerm, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              calldata = [];
              _iterator3 = _createForOfIteratorHelper(request.args);
              _context8.prev = 3;
              _iterator3.s();
            case 5:
              if ((_step3 = _iterator3.n()).done) {
                _context8.next = 13;
                break;
              }
              arg = _step3.value;
              _context8.next = 9;
              return this.mintAndRegisterIpAssetWithPilTerms(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 9:
              result = _context8.sent;
              calldata.push(result.encodedTxData.data);
            case 11:
              _context8.next = 5;
              break;
            case 13:
              _context8.next = 18;
              break;
            case 15:
              _context8.prev = 15;
              _context8.t0 = _context8["catch"](3);
              _iterator3.e(_context8.t0);
            case 18:
              _context8.prev = 18;
              _iterator3.f();
              return _context8.finish(18);
            case 21:
              _context8.next = 23;
              return this.licenseAttachmentWorkflowsClient.multicall({
                data: calldata
              });
            case 23:
              txHash = _context8.sent;
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.waitForTransaction)) {
                _context8.next = 50;
                break;
              }
              _context8.next = 27;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 27:
              txReceipt = _context8.sent;
              results = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt).map(function (log) {
                return {
                  ipId: log.ipId,
                  tokenId: log.tokenId,
                  spgNftContract: log.tokenContract,
                  licenseTermsIds: []
                };
              }); // Due to emit event log by sequence, we need to get license terms id from request.args
              j = 0;
            case 30:
              if (!(j < request.args.length)) {
                _context8.next = 49;
                break;
              }
              licenseTerms = [];
              licenseTermsData = request.args[j].licenseTermsData;
              i = 0;
            case 34:
              if (!(i < licenseTermsData.length)) {
                _context8.next = 42;
                break;
              }
              _context8.next = 37;
              return validateLicenseTerms(licenseTermsData[i].terms, this.rpcClient);
            case 37:
              licenseTerm = _context8.sent;
              licenseTerms.push(licenseTerm);
            case 39:
              i++;
              _context8.next = 34;
              break;
            case 42:
              _context8.next = 44;
              return this.getLicenseTermsId(licenseTerms);
            case 44:
              licenseTermsIds = _context8.sent;
              results[j].licenseTermsIds = licenseTermsIds;
            case 46:
              j++;
              _context8.next = 30;
              break;
            case 49:
              return _context8.abrupt("return", {
                txHash: txHash,
                results: results
              });
            case 50:
              return _context8.abrupt("return", {
                txHash: txHash
              });
            case 53:
              _context8.prev = 53;
              _context8.t1 = _context8["catch"](0);
              handleError(_context8.t1, "Failed to batch mint and register IP and attach PIL terms");
            case 56:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[0, 53], [3, 15, 18, 21]]);
      }));
      function batchMintAndRegisterIpAssetWithPilTerms(_x9) {
        return _batchMintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return batchMintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Register a given NFT as an IP and attach Programmable IP License Terms.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        var _request$txOptions0, ipIdAddress, isRegistered, _yield$validateLicens2, licenseTerms, _yield$transformRegis2, _transformRequest, _request$txOptions1, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              request.tokenId = BigInt(request.tokenId);
              _context9.next = 4;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: request.tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              ipIdAddress = _context9.sent;
              _context9.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context9.sent;
              if (!isRegistered) {
                _context9.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 10:
              _context9.next = 12;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient);
            case 12:
              _yield$validateLicens2 = _context9.sent;
              licenseTerms = _yield$validateLicens2.licenseTerms;
              _context9.next = 16;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 16:
              _yield$transformRegis2 = _context9.sent;
              _transformRequest = _yield$transformRegis2.transformRequest;
              if (!((_request$txOptions0 = request.txOptions) !== null && _request$txOptions0 !== void 0 && _request$txOptions0.encodedTxDataOnly)) {
                _context9.next = 22;
                break;
              }
              return _context9.abrupt("return", {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTermsEncode(_transformRequest)
              });
            case 22:
              _context9.next = 24;
              return this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTerms(_transformRequest);
            case 24:
              txHash = _context9.sent;
              if (!((_request$txOptions1 = request.txOptions) !== null && _request$txOptions1 !== void 0 && _request$txOptions1.waitForTransaction)) {
                _context9.next = 38;
                break;
              }
              _context9.next = 28;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 28:
              txReceipt = _context9.sent;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              _context9.t0 = _objectSpread2;
              _context9.t1 = txHash;
              _context9.next = 34;
              return this.getLicenseTermsId(licenseTerms);
            case 34:
              _context9.t2 = _context9.sent;
              _context9.t3 = {
                txHash: _context9.t1,
                licenseTermsIds: _context9.t2
              };
              _context9.t4 = log;
              return _context9.abrupt("return", (0, _context9.t0)(_context9.t3, _context9.t4));
            case 38:
              return _context9.abrupt("return", {
                txHash: txHash
              });
            case 39:
              _context9.next = 44;
              break;
            case 41:
              _context9.prev = 41;
              _context9.t5 = _context9["catch"](0);
              handleError(_context9.t5, "Failed to register IP and attach PIL terms");
            case 44:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 41]]);
      }));
      function registerIpAndAttachPilTerms(_x0) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * Register the given NFT as a derivative IP with metadata without using license tokens.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerDerivativeIp",
    value: (function () {
      var _registerDerivativeIp = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee0(request) {
        var _this4 = this;
        var _request$txOptions10, tokenId, ipIdAddress, isRegistered, _yield$transformRegis3, _transformRequest2, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee0$(_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              _context0.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context0.next = 4;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              ipIdAddress = _context0.sent;
              _context0.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context0.sent;
              if (!isRegistered) {
                _context0.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 10:
              _context0.next = 12;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 12:
              _yield$transformRegis3 = _context0.sent;
              _transformRequest2 = _yield$transformRegis3.transformRequest;
              encodedTxData = this.derivativeWorkflowsClient.registerIpAndMakeDerivativeEncode(_transformRequest2);
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.encodedTxDataOnly)) {
                _context0.next = 17;
                break;
              }
              return _context0.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 17:
              contractCall = function contractCall() {
                return _this4.derivativeWorkflowsClient.registerIpAndMakeDerivative(_transformRequest2);
              };
              return _context0.abrupt("return", this.handleRegistrationWithFees({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                derivData: _transformRequest2.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 21:
              _context0.prev = 21;
              _context0.t0 = _context0["catch"](0);
              handleError(_context0.t0, "Failed to register derivative IP");
            case 24:
            case "end":
              return _context0.stop();
          }
        }, _callee0, this, [[0, 21]]);
      }));
      function registerDerivativeIp(_x1) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP without license tokens.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee1(request) {
        var _this5 = this;
        var _request$txOptions11, spgNftContract, _yield$transformRegis4, _transformRequest3, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee1$(_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              _context1.prev = 0;
              spgNftContract = validateAddress(request.spgNftContract);
              _context1.next = 4;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              _yield$transformRegis4 = _context1.sent;
              _transformRequest3 = _yield$transformRegis4.transformRequest;
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeEncode(_transformRequest3);
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.encodedTxDataOnly)) {
                _context1.next = 9;
                break;
              }
              return _context1.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 9:
              contractCall = function contractCall() {
                return _this5.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivative(_transformRequest3);
              };
              return _context1.abrupt("return", this.handleRegistrationWithFees({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                spgNftContract: spgNftContract,
                derivData: _transformRequest3.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 13:
              _context1.prev = 13;
              _context1.t0 = _context1["catch"](0);
              handleError(_context1.t0, "Failed to mint and register IP and make derivative");
            case 16:
            case "end":
              return _context1.stop();
          }
        }, _callee1, this, [[0, 13]]);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x10) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Batch mint an NFT from a collection and register it as a derivative IP without license tokens.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "batchMintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _batchMintAndRegisterIpAndMakeDerivative = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {
        var _request$txOptions12, calldata, _iterator4, _step4, arg, result, txHash, txReceipt;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              calldata = [];
              _iterator4 = _createForOfIteratorHelper(request.args);
              _context10.prev = 3;
              _iterator4.s();
            case 5:
              if ((_step4 = _iterator4.n()).done) {
                _context10.next = 19;
                break;
              }
              arg = _step4.value;
              _context10.prev = 7;
              _context10.next = 10;
              return this.mintAndRegisterIpAndMakeDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 10:
              result = _context10.sent;
              calldata.push(result.encodedTxData.data);
              _context10.next = 17;
              break;
            case 14:
              _context10.prev = 14;
              _context10.t0 = _context10["catch"](7);
              throw new Error(_context10.t0.message.replace("Failed to mint and register IP and make derivative: ", "").trim());
            case 17:
              _context10.next = 5;
              break;
            case 19:
              _context10.next = 24;
              break;
            case 21:
              _context10.prev = 21;
              _context10.t1 = _context10["catch"](3);
              _iterator4.e(_context10.t1);
            case 24:
              _context10.prev = 24;
              _iterator4.f();
              return _context10.finish(24);
            case 27:
              _context10.next = 29;
              return this.derivativeWorkflowsClient.multicall({
                data: calldata
              });
            case 29:
              txHash = _context10.sent;
              if (!((_request$txOptions12 = request.txOptions) !== null && _request$txOptions12 !== void 0 && _request$txOptions12.waitForTransaction)) {
                _context10.next = 35;
                break;
              }
              _context10.next = 33;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 33:
              txReceipt = _context10.sent;
              return _context10.abrupt("return", {
                txHash: txHash,
                results: this.getIpIdAndTokenIdsFromEvent(txReceipt, "spgNftContract")
              });
            case 35:
              return _context10.abrupt("return", {
                txHash: txHash
              });
            case 38:
              _context10.prev = 38;
              _context10.t2 = _context10["catch"](0);
              handleError(_context10.t2, "Failed to batch mint and register IP and make derivative");
            case 41:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[0, 38], [3, 21, 24, 27], [7, 14]]);
      }));
      function batchMintAndRegisterIpAndMakeDerivative(_x11) {
        return _batchMintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return batchMintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Mint an NFT from a SPGNFT collection and register it with metadata as an IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIp",
    value: (function () {
      var _mintAndRegisterIp = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request) {
        var _this6 = this;
        var _request$txOptions13, _object, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.prev = 0;
              _object = {
                spgNftContract: validateAddress(request.spgNftContract),
                recipient: validateAddress(request.recipient || this.walletAddress),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                allowDuplicates: request.allowDuplicates || true
              };
              encodedTxData = this.registrationWorkflowsClient.mintAndRegisterIpEncode(_object);
              if (!((_request$txOptions13 = request.txOptions) !== null && _request$txOptions13 !== void 0 && _request$txOptions13.encodedTxDataOnly)) {
                _context11.next = 5;
                break;
              }
              return _context11.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 5:
              contractCall = function contractCall() {
                return _this6.registrationWorkflowsClient.mintAndRegisterIp(_object);
              };
              return _context11.abrupt("return", this.handleRegistrationWithFees({
                sender: this.walletAddress,
                spgSpenderAddress: this.registrationWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                spgNftContract: _object.spgNftContract,
                txOptions: request.txOptions,
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                })
              }));
            case 9:
              _context11.prev = 9;
              _context11.t0 = _context11["catch"](0);
              handleError(_context11.t0, "Failed to mint and register IP");
            case 12:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this, [[0, 9]]);
      }));
      function mintAndRegisterIp(_x12) {
        return _mintAndRegisterIp.apply(this, arguments);
      }
      return mintAndRegisterIp;
    }()
    /**
     * Register Programmable IP License Terms (if unregistered) and attach it to IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} event.
     */
    )
  }, {
    key: "registerPilTermsAndAttach",
    value: (function () {
      var _registerPilTermsAndAttach = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {
        var _request$txOptions14, ipId, isRegistered, _yield$validateLicens3, licenseTerms, licenseTermsData, calculatedDeadline, ipAccount, _yield$ipAccount$stat2, state, signature, _object2, _request$txOptions15, txHash, licenseTermsIds;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.prev = 0;
              ipId = request.ipId;
              _context12.next = 4;
              return this.isRegistered(ipId);
            case 4:
              isRegistered = _context12.sent;
              if (isRegistered) {
                _context12.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(ipId, " is not registered."));
            case 7:
              _context12.next = 9;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient);
            case 9:
              _yield$validateLicens3 = _context12.sent;
              licenseTerms = _yield$validateLicens3.licenseTerms;
              licenseTermsData = _yield$validateLicens3.licenseTermsData;
              _context12.next = 14;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 14:
              calculatedDeadline = _context12.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              _context12.next = 18;
              return ipAccount.state();
            case 18:
              _yield$ipAccount$stat2 = _context12.sent;
              state = _yield$ipAccount$stat2.result;
              _context12.next = 22;
              return generateOperationSignature({
                ipIdAddress: ipId,
                methodType: SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 22:
              signature = _context12.sent;
              _object2 = {
                ipId: ipId,
                licenseTermsData: licenseTermsData,
                sigAttachAndConfig: {
                  signer: validateAddress(this.walletAddress),
                  deadline: calculatedDeadline,
                  signature: signature
                }
              };
              if (!((_request$txOptions14 = request.txOptions) !== null && _request$txOptions14 !== void 0 && _request$txOptions14.encodedTxDataOnly)) {
                _context12.next = 28;
                break;
              }
              return _context12.abrupt("return", {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttachEncode(_object2)
              });
            case 28:
              _context12.next = 30;
              return this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttach(_object2);
            case 30:
              txHash = _context12.sent;
              if (!((_request$txOptions15 = request.txOptions) !== null && _request$txOptions15 !== void 0 && _request$txOptions15.waitForTransaction)) {
                _context12.next = 40;
                break;
              }
              _context12.next = 34;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 34:
              _context12.next = 36;
              return this.getLicenseTermsId(licenseTerms);
            case 36:
              licenseTermsIds = _context12.sent;
              return _context12.abrupt("return", {
                txHash: txHash,
                licenseTermsIds: licenseTermsIds
              });
            case 40:
              return _context12.abrupt("return", {
                txHash: txHash
              });
            case 41:
              _context12.next = 46;
              break;
            case 43:
              _context12.prev = 43;
              _context12.t0 = _context12["catch"](0);
              handleError(_context12.t0, "Failed to register PIL terms and attach");
            case 46:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this, [[0, 43]]);
      }));
      function registerPilTermsAndAttach(_x13) {
        return _registerPilTermsAndAttach.apply(this, arguments);
      }
      return registerPilTermsAndAttach;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP using license tokens.
     * Requires caller to have the minter role or the SPG NFT to allow public minting. Caller must own the license tokens and have approved DerivativeWorkflows to transfer them.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request) {
        var _this7 = this;
        var _request$txOptions16, licenseTokenIds, _object3, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.prev = 0;
              _context14.next = 3;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 3:
              licenseTokenIds = _context14.sent;
              _object3 = {
                spgNftContract: validateAddress(request.spgNftContract),
                recipient: validateAddress(request.recipient || this.walletAddress),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                licenseTokenIds: licenseTokenIds,
                royaltyContext: zeroAddress,
                maxRts: Number(request.maxRts),
                allowDuplicates: request.allowDuplicates || true
              };
              validateMaxRts(_object3.maxRts);
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(_object3);
              if (!((_request$txOptions16 = request.txOptions) !== null && _request$txOptions16 !== void 0 && _request$txOptions16.encodedTxDataOnly)) {
                _context14.next = 9;
                break;
              }
              return _context14.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 9:
              contractCall = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        return _context13.abrupt("return", _this7.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_object3));
                      case 1:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13);
                }));
                return function contractCall() {
                  return _ref2.apply(this, arguments);
                };
              }();
              return _context14.abrupt("return", this.handleRegistrationWithFees({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  // need to disable multicall to avoid needing to transfer the license
                  // token to the multicall contract.
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgNftContract: _object3.spgNftContract,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 13:
              _context14.prev = 13;
              _context14.t0 = _context14["catch"](0);
              handleError(_context14.t0, "Failed to mint and register IP and make derivative with license tokens");
            case 16:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this, [[0, 13]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x14) {
        return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT as a derivative IP using license tokens.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _registerIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(request) {
        var _request$txOptions17, tokenId, ipIdAddress, isRegistered, licenseTokenIds, calculatedDeadline, signature, _object4, _request$txOptions18, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context15.next = 4;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              ipIdAddress = _context15.sent;
              _context15.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context15.sent;
              if (!isRegistered) {
                _context15.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 10:
              _context15.next = 12;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 12:
              licenseTokenIds = _context15.sent;
              _context15.next = 15;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 15:
              calculatedDeadline = _context15.sent;
              _context15.next = 18;
              return generateOperationSignature({
                ipIdAddress: ipIdAddress,
                methodType: SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 18:
              signature = _context15.sent;
              _object4 = _objectSpread2(_objectSpread2({}, request), {}, {
                tokenId: tokenId,
                licenseTokenIds: licenseTokenIds,
                royaltyContext: zeroAddress,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadataAndRegister: {
                  signer: validateAddress(this.walletAddress),
                  deadline: calculatedDeadline,
                  signature: signature
                },
                maxRts: Number(request.maxRts)
              });
              validateMaxRts(_object4.maxRts);
              if (!((_request$txOptions17 = request.txOptions) !== null && _request$txOptions17 !== void 0 && _request$txOptions17.encodedTxDataOnly)) {
                _context15.next = 25;
                break;
              }
              return _context15.abrupt("return", {
                encodedTxData: this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokensEncode(_object4)
              });
            case 25:
              _context15.next = 27;
              return this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokens(_object4);
            case 27:
              txHash = _context15.sent;
              if (!((_request$txOptions18 = request.txOptions) !== null && _request$txOptions18 !== void 0 && _request$txOptions18.waitForTransaction)) {
                _context15.next = 34;
                break;
              }
              _context15.next = 31;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 31:
              receipt = _context15.sent;
              log = this.getIpIdAndTokenIdsFromEvent(receipt)[0];
              return _context15.abrupt("return", _objectSpread2({
                txHash: txHash
              }, log));
            case 34:
              return _context15.abrupt("return", {
                txHash: txHash
              });
            case 35:
              _context15.next = 40;
              break;
            case 37:
              _context15.prev = 37;
              _context15.t0 = _context15["catch"](0);
              handleError(_context15.t0, "Failed to register IP and make derivative with license tokens");
            case 40:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this, [[0, 37]]);
      }));
      function registerIpAndMakeDerivativeWithLicenseTokens(_x15) {
        return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT and attach license terms and distribute royalty
     * tokens. In order to successfully distribute royalty tokens, the first
     * license terms attached to the IP must be a commercial license.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88 | `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request) {
        var _request$txOptions19, _getRoyaltyShares, royaltyShares, totalAmount, _yield$validateLicens4, licenseTerms, calculatedDeadline, ipIdAddress, isRegistered, _yield$transformRegis5, _transformRequest4, registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash, txReceipt, ipId, licenseTermsIds, ipRoyaltyVault, distributeRoyaltyTokensTxHash;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.prev = 0;
              _getRoyaltyShares = getRoyaltyShares(request.royaltyShares), royaltyShares = _getRoyaltyShares.royaltyShares, totalAmount = _getRoyaltyShares.totalAmount;
              _context16.next = 4;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient);
            case 4:
              _yield$validateLicens4 = _context16.sent;
              licenseTerms = _yield$validateLicens4.licenseTerms;
              _context16.next = 8;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 8:
              calculatedDeadline = _context16.sent;
              _context16.next = 11;
              return getIpIdAddress({
                nftContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId),
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 11:
              ipIdAddress = _context16.sent;
              _context16.next = 14;
              return this.isRegistered(ipIdAddress);
            case 14:
              isRegistered = _context16.sent;
              if (!isRegistered) {
                _context16.next = 17;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 17:
              _context16.next = 19;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 19:
              _yield$transformRegis5 = _context16.sent;
              _transformRequest4 = _yield$transformRegis5.transformRequest;
              _context16.next = 23;
              return this.royaltyTokenDistributionWorkflowsClient.registerIpAndAttachPilTermsAndDeployRoyaltyVault(_transformRequest4);
            case 23:
              registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash = _context16.sent;
              _context16.next = 26;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash
              }));
            case 26:
              txReceipt = _context16.sent;
              ipId = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0].ipId;
              _context16.next = 30;
              return this.getLicenseTermsId(licenseTerms);
            case 30:
              licenseTermsIds = _context16.sent;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(txReceipt)[0].ipRoyaltyVault;
              _context16.next = 34;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: calculatedDeadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 34:
              distributeRoyaltyTokensTxHash = _context16.sent;
              if (!((_request$txOptions19 = request.txOptions) !== null && _request$txOptions19 !== void 0 && _request$txOptions19.waitForTransaction)) {
                _context16.next = 38;
                break;
              }
              _context16.next = 38;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 38:
              return _context16.abrupt("return", {
                registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault
              });
            case 41:
              _context16.prev = 41;
              _context16.t0 = _context16["catch"](0);
              handleError(_context16.t0, "Failed to register IP and attach license terms and distribute royalty tokens");
            case 44:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[0, 41]]);
      }));
      function registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x16) {
        return _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Register the given NFT as a derivative IP and attach license terms and distribute royalty tokens.  In order to successfully distribute royalty tokens, the license terms attached to the IP must be
     * a commercial license.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88| `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(request) {
        var _this8 = this;
        var _request$txOptions20, ipIdAddress, _yield$transformRegis6, _transformRequest5, _getRoyaltyShares2, royaltyShares, totalAmount, isRegistered, encodedTxData, contractCall, _yield$this$handleReg, txHash, ipId, tokenId, receipt, ipRoyaltyVault, distributeRoyaltyTokensTxHash;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.prev = 0;
              _context17.next = 3;
              return getIpIdAddress({
                nftContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId),
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 3:
              ipIdAddress = _context17.sent;
              _context17.next = 6;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 6:
              _yield$transformRegis6 = _context17.sent;
              _transformRequest5 = _yield$transformRegis6.transformRequest;
              _getRoyaltyShares2 = getRoyaltyShares(request.royaltyShares), royaltyShares = _getRoyaltyShares2.royaltyShares, totalAmount = _getRoyaltyShares2.totalAmount;
              _context17.next = 11;
              return this.isRegistered(ipIdAddress);
            case 11:
              isRegistered = _context17.sent;
              if (!isRegistered) {
                _context17.next = 14;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 14:
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(_transformRequest5);
              contractCall = function contractCall() {
                return _this8.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVault(_transformRequest5);
              };
              _context17.next = 18;
              return this.handleRegistrationWithFees({
                wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                  useMulticallWhenPossible: false
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: _transformRequest5.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: _objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                  waitForTransaction: true
                })
              });
            case 18:
              _yield$this$handleReg = _context17.sent;
              txHash = _yield$this$handleReg.txHash;
              ipId = _yield$this$handleReg.ipId;
              tokenId = _yield$this$handleReg.tokenId;
              receipt = _yield$this$handleReg.receipt;
              if (!(tokenId === undefined || !ipId || !receipt)) {
                _context17.next = 25;
                break;
              }
              throw new Error("Failed to register derivative ip and deploy royalty vault.");
            case 25:
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt).filter(function (item) {
                return item.ipId === ipId;
              })[0].ipRoyaltyVault;
              _context17.next = 28;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: request.deadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 28:
              distributeRoyaltyTokensTxHash = _context17.sent;
              if (!((_request$txOptions20 = request.txOptions) !== null && _request$txOptions20 !== void 0 && _request$txOptions20.waitForTransaction)) {
                _context17.next = 32;
                break;
              }
              _context17.next = 32;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 32:
              return _context17.abrupt("return", {
                registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash: txHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                tokenId: tokenId,
                ipRoyaltyVault: ipRoyaltyVault
              });
            case 35:
              _context17.prev = 35;
              _context17.t0 = _context17["catch"](0);
              handleError(_context17.t0, "Failed to register derivative IP and attach license terms and distribute royalty tokens");
            case 38:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[0, 35]]);
      }));
      function registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x17) {
        return _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, attach PIL terms, and distribute royalty tokens.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88| `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(request) {
        var _this9 = this;
        var _yield$validateLicens5, licenseTerms, _yield$transformRegis7, _transformRequest6, encodedTxData, contractCall, _yield$this$handleReg2, txHash, ipId, tokenId, receipt, licenseTermsIds, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.prev = 0;
              _context18.next = 3;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient);
            case 3:
              _yield$validateLicens5 = _context18.sent;
              licenseTerms = _yield$validateLicens5.licenseTerms;
              _context18.next = 7;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 7:
              _yield$transformRegis7 = _context18.sent;
              _transformRequest6 = _yield$transformRegis7.transformRequest;
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(_transformRequest6);
              contractCall = function contractCall() {
                return _this9.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_transformRequest6);
              };
              _context18.next = 13;
              return this.handleRegistrationWithFees({
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgNftContract: _transformRequest6.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 13:
              _yield$this$handleReg2 = _context18.sent;
              txHash = _yield$this$handleReg2.txHash;
              ipId = _yield$this$handleReg2.ipId;
              tokenId = _yield$this$handleReg2.tokenId;
              receipt = _yield$this$handleReg2.receipt;
              if (receipt) {
                _context18.next = 20;
                break;
              }
              return _context18.abrupt("return", {
                txHash: txHash
              });
            case 20:
              _context18.next = 22;
              return this.getLicenseTermsId(licenseTerms);
            case 22:
              licenseTermsIds = _context18.sent;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt)[0].ipRoyaltyVault;
              return _context18.abrupt("return", {
                txHash: txHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault,
                tokenId: tokenId
              });
            case 27:
              _context18.prev = 27;
              _context18.t0 = _context18["catch"](0);
              handleError(_context18.t0, "Failed to mint and register IP and attach PIL terms and distribute royalty tokens");
            case 30:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this, [[0, 27]]);
      }));
      function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x18) {
        return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, make a derivative, and distribute royalty tokens.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(request) {
        var _this0 = this;
        var _yield$transformRegis8, _transformRequest7, encodedTxData, contractCall;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 3:
              _yield$transformRegis8 = _context19.sent;
              _transformRequest7 = _yield$transformRegis8.transformRequest;
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(_transformRequest7);
              contractCall = function contractCall() {
                return _this0.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_transformRequest7);
              };
              return _context19.abrupt("return", this.handleRegistrationWithFees({
                spgNftContract: _transformRequest7.spgNftContract,
                wipOptions: request.wipOptions,
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: _transformRequest7.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 10:
              _context19.prev = 10;
              _context19.t0 = _context19["catch"](0);
              handleError(_context19.t0, "Failed to mint and register IP and make derivative and distribute royalty tokens");
            case 13:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[0, 10]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x19) {
        return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;
    }())
  }, {
    key: "distributeRoyaltyTokens",
    value: function () {
      var _distributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request) {
        var _request$txOptions21;
        var _yield$transferDistri, transformRequest, txHash;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return transferDistributeRoyaltyTokensRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 2:
              _yield$transferDistri = _context20.sent;
              transformRequest = _yield$transferDistri.transformRequest;
              _context20.next = 6;
              return this.royaltyTokenDistributionWorkflowsClient.distributeRoyaltyTokens(transformRequest);
            case 6:
              txHash = _context20.sent;
              if (!((_request$txOptions21 = request.txOptions) !== null && _request$txOptions21 !== void 0 && _request$txOptions21.waitForTransaction)) {
                _context20.next = 11;
                break;
              }
              _context20.next = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              return _context20.abrupt("return", txHash);
            case 11:
              return _context20.abrupt("return", txHash);
            case 12:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function distributeRoyaltyTokens(_x20) {
        return _distributeRoyaltyTokens.apply(this, arguments);
      }
      return distributeRoyaltyTokens;
    }()
  }, {
    key: "isRegistered",
    value: function () {
      var _isRegistered = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(ipId) {
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 2:
              return _context21.abrupt("return", _context21.sent);
            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function isRegistered(_x21) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }()
    /**
     * Batch register multiple IP assets in optimized transactions, supporting various registration methods:
     * - {@link mintAndRegisterIpAndMakeDerivative}
     * - {@link mintAndRegisterIpAssetWithPilTerms}
     * - {@link mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens}
     * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens}
     * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerIpAndAttachPilTerms}
     * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerDerivativeIp}
     *
     * This method optimizes transaction processing by:
     * 1. Transforming all requests into appropriate workflow formats
     * 2. Grouping related workflow requests together
     * 3. Intelligently selecting between multicall3 and SPG's multicall based on compatibility
     *
     * The batching strategy significantly reduces gas costs and improves transaction throughput
     * by minimizing the number of separate blockchain transactions. It also handles complex
     * workflows like royalty token distribution automatically.
     *
     * The method supports automatic token handling for minting fees:
     * - If the wallet's IP token balance is insufficient to cover minting fees, it automatically wraps native IP tokens into WIP tokens.
     * - It checks allowances for all required spenders and automatically approves them if their current allowance is lower than needed.
     * - These automatic processes can be configured through the `wipOptions` parameter to control behavior like multicall usage and approval settings.
     *
     * @remark Multicall selection logic:
     *
     * 1. For `mintAndRegister*` methods:
     *    - When `spgNftContract` has public minting disabled: Uses SPG's multicall
     *    - When `spgNftContract` has public minting enabled: Uses multicall3
     *    - Exception: {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} always uses
     *      SPG's multicall due to contract logic
     *
     * 2. For `register*` methods:
     *    - Always uses SPG's multicall for batching registration operations
     */
  }, {
    key: "batchRegisterIpAssetsWithOptimizedWorkflows",
    value: (function () {
      var _batchRegisterIpAssetsWithOptimizedWorkflows = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request) {
        var transferWorkflowResponses, _iterator5, _step5, req, res, royaltyDistributionRequests, txResponses, responses, prepareRoyaltyTokensDistributionResponses, _iterator6, _step6, _step6$value, txHash, receipt, iPRegisteredLog, ipRoyaltyVaultEvent, response, distributeRoyaltyTokensTxHashes, txResponse;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              // Transform requests into workflow format
              transferWorkflowResponses = [];
              _iterator5 = _createForOfIteratorHelper(request.requests);
              _context22.prev = 3;
              _iterator5.s();
            case 5:
              if ((_step5 = _iterator5.n()).done) {
                _context22.next = 13;
                break;
              }
              req = _step5.value;
              _context22.next = 9;
              return transformRegistrationRequest({
                request: req,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 9:
              res = _context22.sent;
              transferWorkflowResponses.push(res);
            case 11:
              _context22.next = 5;
              break;
            case 13:
              _context22.next = 18;
              break;
            case 15:
              _context22.prev = 15;
              _context22.t0 = _context22["catch"](3);
              _iterator5.e(_context22.t0);
            case 18:
              _context22.prev = 18;
              _iterator5.f();
              return _context22.finish(18);
            case 21:
              /**
               * Extract royalty distribution requests from workflow responses that contain royalty shares
               * We need to handle `distributeRoyaltyTokens` separately because this method requires
               * a signature with the royalty vault address, which is only available after the initial registration
               */
              royaltyDistributionRequests = transferWorkflowResponses.filter(function (res) {
                var _res$extraData;
                return (_res$extraData = res.extraData) === null || _res$extraData === void 0 ? void 0 : _res$extraData.royaltyShares;
              }).map(function (res) {
                return {
                  nftContract: res.transformRequest.nftContract,
                  tokenId: res.transformRequest.tokenId,
                  royaltyShares: res.extraData.royaltyShares,
                  deadline: res.extraData.deadline
                };
              }); // Process initial registration transactions
              _context22.next = 24;
              return handleMulticall({
                transferWorkflowResponses: transferWorkflowResponses,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                walletAddress: this.walletAddress,
                wipOptions: request.wipOptions,
                chainId: this.chainId
              });
            case 24:
              txResponses = _context22.sent;
              responses = [];
              prepareRoyaltyTokensDistributionResponses = []; // Process each transaction response
              _iterator6 = _createForOfIteratorHelper(txResponses);
              _context22.prev = 28;
              _iterator6.s();
            case 30:
              if ((_step6 = _iterator6.n()).done) {
                _context22.next = 41;
                break;
              }
              _step6$value = _step6.value, txHash = _step6$value.txHash, receipt = _step6$value.receipt;
              iPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt);
              ipRoyaltyVaultEvent = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt); // Prepare royalty distribution if needed
              _context22.next = 36;
              return prepareRoyaltyTokensDistributionRequests({
                royaltyDistributionRequests: royaltyDistributionRequests,
                ipRegisteredLog: iPRegisteredLog,
                ipRoyaltyVault: ipRoyaltyVaultEvent,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 36:
              response = _context22.sent;
              prepareRoyaltyTokensDistributionResponses.push.apply(prepareRoyaltyTokensDistributionResponses, _toConsumableArray(response));
              responses.push({
                txHash: txHash,
                receipt: receipt,
                ipIdAndTokenId: iPRegisteredLog.map(function (log) {
                  return {
                    ipId: log.ipId,
                    tokenId: log.tokenId
                  };
                })
              });
            case 39:
              _context22.next = 30;
              break;
            case 41:
              _context22.next = 46;
              break;
            case 43:
              _context22.prev = 43;
              _context22.t1 = _context22["catch"](28);
              _iterator6.e(_context22.t1);
            case 46:
              _context22.prev = 46;
              _iterator6.f();
              return _context22.finish(46);
            case 49:
              if (!(prepareRoyaltyTokensDistributionResponses.length > 0)) {
                _context22.next = 54;
                break;
              }
              _context22.next = 52;
              return handleMulticall({
                transferWorkflowResponses: prepareRoyaltyTokensDistributionResponses,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                walletAddress: this.walletAddress,
                wipOptions: request.wipOptions,
                chainId: this.chainId
              });
            case 52:
              txResponse = _context22.sent;
              distributeRoyaltyTokensTxHashes = txResponse.map(function (tx) {
                return tx.txHash;
              });
            case 54:
              return _context22.abrupt("return", _objectSpread2({
                registrationResults: responses
              }, distributeRoyaltyTokensTxHashes && {
                distributeRoyaltyTokensTxHashes: distributeRoyaltyTokensTxHashes
              }));
            case 57:
              _context22.prev = 57;
              _context22.t2 = _context22["catch"](0);
              handleError(_context22.t2, "Failed to batch register IP assets with optimized workflows");
            case 60:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this, [[0, 57], [3, 15, 18, 21], [28, 43, 46, 49]]);
      }));
      function batchRegisterIpAssetsWithOptimizedWorkflows(_x22) {
        return _batchRegisterIpAssetsWithOptimizedWorkflows.apply(this, arguments);
      }
      return batchRegisterIpAssetsWithOptimizedWorkflows;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(licenseTerms) {
        var licenseTermsIds, _iterator7, _step7, licenseTerm, licenseRes;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              licenseTermsIds = [];
              _iterator7 = _createForOfIteratorHelper(licenseTerms);
              _context23.prev = 2;
              _iterator7.s();
            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context23.next = 12;
                break;
              }
              licenseTerm = _step7.value;
              _context23.next = 8;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: licenseTerm
              });
            case 8:
              licenseRes = _context23.sent;
              licenseTermsIds.push(licenseRes.selectedLicenseTermsId);
            case 10:
              _context23.next = 4;
              break;
            case 12:
              _context23.next = 17;
              break;
            case 14:
              _context23.prev = 14;
              _context23.t0 = _context23["catch"](2);
              _iterator7.e(_context23.t0);
            case 17:
              _context23.prev = 17;
              _iterator7.f();
              return _context23.finish(17);
            case 20:
              return _context23.abrupt("return", licenseTermsIds);
            case 21:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this, [[2, 14, 17, 20]]);
      }));
      function getLicenseTermsId(_x23) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }, {
    key: "validateLicenseTokenIds",
    value: function () {
      var _validateLicenseTokenIds = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(licenseTokenIds) {
        var newLicenseTokenIds, _iterator8, _step8, licenseTokenId, tokenOwnerAddress;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              if (!(licenseTokenIds.length === 0)) {
                _context24.next = 2;
                break;
              }
              throw new Error("License token IDs must be provided.");
            case 2:
              newLicenseTokenIds = licenseTokenIds.map(function (id) {
                return BigInt(id);
              });
              _iterator8 = _createForOfIteratorHelper(newLicenseTokenIds);
              _context24.prev = 4;
              _iterator8.s();
            case 6:
              if ((_step8 = _iterator8.n()).done) {
                _context24.next = 15;
                break;
              }
              licenseTokenId = _step8.value;
              _context24.next = 10;
              return this.licenseTokenReadOnlyClient.ownerOf({
                tokenId: licenseTokenId
              });
            case 10:
              tokenOwnerAddress = _context24.sent;
              if (tokenOwnerAddress) {
                _context24.next = 13;
                break;
              }
              throw new Error("License token id ".concat(licenseTokenId, " must be owned by the caller."));
            case 13:
              _context24.next = 6;
              break;
            case 15:
              _context24.next = 20;
              break;
            case 17:
              _context24.prev = 17;
              _context24.t0 = _context24["catch"](4);
              _iterator8.e(_context24.t0);
            case 20:
              _context24.prev = 20;
              _iterator8.f();
              return _context24.finish(20);
            case 23:
              return _context24.abrupt("return", newLicenseTokenIds);
            case 24:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this, [[4, 17, 20, 23]]);
      }));
      function validateLicenseTokenIds(_x24) {
        return _validateLicenseTokenIds.apply(this, arguments);
      }
      return validateLicenseTokenIds;
    }()
  }, {
    key: "getIpIdAndTokenIdsFromEvent",
    value: function getIpIdAndTokenIdsFromEvent(txReceipt, key) {
      var IPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
      return IPRegisteredLog.map(function (log) {
        var baseResult = {
          ipId: log.ipId,
          tokenId: log.tokenId
        };
        if (key) {
          return _objectSpread2(_objectSpread2({}, baseResult), {}, _defineProperty({}, key, log.tokenContract));
        }
        return baseResult;
      });
    }
  }, {
    key: "handleRegistrationWithFees",
    value: function () {
      var _handleRegistrationWithFees = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(_ref3) {
        var _wipOptions$useMultic;
        var sender, derivData, spgNftContract, spgSpenderAddress, txOptions, wipOptions, encodedTxs, contractCall, totalFees, wipSpenders, useMulticallWhenPossible, nftMintFee, publicMinting, totalDerivativeMintingFee, _yield$contractCallWi, txHash, receipt, _this$getIpIdAndToken, _event$ipId, _event$tokenId, event;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              sender = _ref3.sender, derivData = _ref3.derivData, spgNftContract = _ref3.spgNftContract, spgSpenderAddress = _ref3.spgSpenderAddress, txOptions = _ref3.txOptions, wipOptions = _ref3.wipOptions, encodedTxs = _ref3.encodedTxs, contractCall = _ref3.contractCall;
              totalFees = 0n;
              wipSpenders = [];
              useMulticallWhenPossible = (_wipOptions$useMultic = wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) !== null && _wipOptions$useMultic !== void 0 ? _wipOptions$useMultic : true; // get spg minting fee
              if (!spgNftContract) {
                _context25.next = 14;
                break;
              }
              _context25.next = 7;
              return calculateSPGWipMintFee(new SpgnftImplReadOnlyClient(this.rpcClient, spgNftContract));
            case 7:
              nftMintFee = _context25.sent;
              _context25.next = 10;
              return getPublicMinting(spgNftContract, this.rpcClient);
            case 10:
              publicMinting = _context25.sent;
              /**
               * If the SPG NFT contract's public minting is disabled, we need to check if the caller has the `minter role`.
               * When public minting is disabled, we can't use multicall because we need to perform additional role checks
               * that aren't compatible with batched transactions.
               *
               * This is because role-based access control requires the transaction's msg.sender to be verified directly,
               * which is not preserved when using multicall (where the multicall contract becomes the sender).
               */
              if (!publicMinting) {
                useMulticallWhenPossible = false;
              }
              totalFees += nftMintFee;
              wipSpenders.push({
                address: spgNftContract,
                amount: nftMintFee
              });
            case 14:
              if (!derivData) {
                _context25.next = 20;
                break;
              }
              _context25.next = 17;
              return calculateDerivativeMintingFee({
                derivData: derivData,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId,
                sender: sender
              });
            case 17:
              totalDerivativeMintingFee = _context25.sent;
              totalFees += totalDerivativeMintingFee;
              if (totalDerivativeMintingFee > 0) {
                wipSpenders.push({
                  address: spgSpenderAddress,
                  amount: totalDerivativeMintingFee
                });
              }
            case 20:
              if (!(totalFees < 0)) {
                _context25.next = 22;
                break;
              }
              throw new Error("Total fees for registering derivative should never be negative: ".concat(totalFees));
            case 22:
              _context25.next = 24;
              return contractCallWithFees({
                totalFees: totalFees,
                options: {
                  wipOptions: _objectSpread2(_objectSpread2({}, wipOptions), {}, {
                    useMulticallWhenPossible: useMulticallWhenPossible
                  })
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: wipSpenders,
                contractCall: contractCall,
                sender: sender,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: encodedTxs
              });
            case 24:
              _yield$contractCallWi = _context25.sent;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (!receipt) {
                _context25.next = 30;
                break;
              }
              event = (_this$getIpIdAndToken = this.getIpIdAndTokenIdsFromEvent(receipt)) === null || _this$getIpIdAndToken === void 0 ? void 0 : _this$getIpIdAndToken[0];
              return _context25.abrupt("return", _objectSpread2({
                txHash: txHash,
                receipt: receipt
              }, event && {
                ipId: (_event$ipId = event.ipId) !== null && _event$ipId !== void 0 ? _event$ipId : undefined,
                tokenId: (_event$tokenId = event.tokenId) !== null && _event$tokenId !== void 0 ? _event$tokenId : undefined
              }));
            case 30:
              return _context25.abrupt("return", {
                txHash: txHash
              });
            case 31:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function handleRegistrationWithFees(_x25) {
        return _handleRegistrationWithFees.apply(this, arguments);
      }
      return handleRegistrationWithFees;
    }()
  }]);
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, PermissionClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.accessControllerClient = new AccessControllerClient(this.rpcClient, this.wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(this.rpcClient, this.wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(this.rpcClient, this.wallet);
  }

  /**
   * Sets the permission for a specific function call.
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level is an enum of `AccessPermission`.
   * By default, all policies are set to ABSTAIN, which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
   */
  return _createClass(PermissionClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                to: request.to,
                func: request.func ? toFunctionSelector(request.func) : defaultFunctionSelector,
                permission: request.permission
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.accessControllerClient.setPermissionEncode(req)
              });
            case 8:
              _context.next = 10;
              return this.accessControllerClient.setPermission(req);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to set permissions");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
    /**
     * Specific permission overrides wildcard permission with signature.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "createSetPermissionSignature",
    value: (function () {
      var _createSetPermissionSignature = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipId, signer, to, txOptions, func, permission, deadline, ipAccountClient, data, _yield$ipAccountClien, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, signature, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipId = request.ipId, signer = request.signer, to = request.to, txOptions = request.txOptions, func = request.func, permission = request.permission, deadline = request.deadline;
              _context2.next = 4;
              return this.checkIsRegistered(ipId);
            case 4:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setTransientPermission",
                args: [ipId, validateAddress(signer), validateAddress(to), func ? toFunctionSelector(func) : defaultFunctionSelector, permission]
              });
              _context2.next = 8;
              return ipAccountClient.state();
            case 8:
              _yield$ipAccountClien = _context2.sent;
              state = _yield$ipAccountClien.result;
              _context2.next = 12;
              return this.rpcClient.getBlock();
            case 12:
              blockTimestamp = _context2.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.next = 16;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: [{
                  ipId: ipId,
                  signer: signer,
                  to: to,
                  permission: permission,
                  func: func
                }],
                chainId: chain[this.chainId],
                wallet: this.wallet
              });
            case 16:
              _yield$getPermissionS = _context2.sent;
              signature = _yield$getPermissionS.signature;
              req = {
                to: validateAddress(this.accessControllerClient.address),
                value: BigInt(0),
                data: data,
                signer: signer,
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 23;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 23:
              _context2.next = 25;
              return ipAccountClient.executeWithSig(req);
            case 25:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 32;
                break;
              }
              _context2.next = 29;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 29:
              return _context2.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 32:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 33:
              _context2.next = 38;
              break;
            case 35:
              _context2.prev = 35;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to create set permission signature");
            case 38:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 35]]);
      }));
      function createSetPermissionSignature(_x2) {
        return _createSetPermissionSignature.apply(this, arguments);
      }
      return createSetPermissionSignature;
    }()
    /**
     * Sets permission to a signer for all functions across all modules.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "setAllPermissions",
    value: (function () {
      var _setAllPermissions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                permission: request.permission
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 8;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.accessControllerClient.setAllPermissionsEncode(req)
              });
            case 8:
              _context3.next = 10;
              return this.accessControllerClient.setAllPermissions(req);
            case 10:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 17;
                break;
              }
              _context3.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context3.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context3.next = 23;
              break;
            case 20:
              _context3.prev = 20;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to set all permissions");
            case 23:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 20]]);
      }));
      function setAllPermissions(_x3) {
        return _setAllPermissions.apply(this, arguments);
      }
      return setAllPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "setBatchPermissions",
    value: (function () {
      var _setBatchPermissions = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, permissions, txOptions, _iterator, _step, permission, req, _request$txOptions8, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              permissions = request.permissions, txOptions = request.txOptions;
              _iterator = _createForOfIteratorHelper(permissions);
              _context4.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context4.next = 11;
                break;
              }
              permission = _step.value;
              _context4.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context4.next = 5;
              break;
            case 11:
              _context4.next = 16;
              break;
            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](3);
              _iterator.e(_context4.t0);
            case 16:
              _context4.prev = 16;
              _iterator.f();
              return _context4.finish(16);
            case 19:
              req = {
                permissions: permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 24;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.accessControllerClient.setBatchPermissionsEncode(req)
              });
            case 24:
              _context4.next = 26;
              return this.accessControllerClient.setBatchPermissions(req);
            case 26:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 33;
                break;
              }
              _context4.next = 30;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 30:
              return _context4.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 33:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 34:
              _context4.next = 39;
              break;
            case 36:
              _context4.prev = 36;
              _context4.t1 = _context4["catch"](0);
              handleError(_context4.t1, "Failed to set batch permissions");
            case 39:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 36], [3, 13, 16, 19]]);
      }));
      function setBatchPermissions(_x4) {
        return _setBatchPermissions.apply(this, arguments);
      }
      return setBatchPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction with signature.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "createBatchPermissionSignature",
    value: (function () {
      var _createBatchPermissionSignature = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, permissions, deadline, ipId, txOptions, _iterator2, _step2, permission, ipAccountClient, data, _yield$ipAccountClien2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, signature, req, _request$txOptions0, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              permissions = request.permissions, deadline = request.deadline, ipId = request.ipId, txOptions = request.txOptions;
              _iterator2 = _createForOfIteratorHelper(permissions);
              _context5.prev = 3;
              _iterator2.s();
            case 5:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 11;
                break;
              }
              permission = _step2.value;
              _context5.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context5.next = 5;
              break;
            case 11:
              _context5.next = 16;
              break;
            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](3);
              _iterator2.e(_context5.t0);
            case 16:
              _context5.prev = 16;
              _iterator2.f();
              return _context5.finish(16);
            case 19:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setBatchTransientPermissions",
                args: [permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })]
              });
              _context5.next = 23;
              return ipAccountClient.state();
            case 23:
              _yield$ipAccountClien2 = _context5.sent;
              state = _yield$ipAccountClien2.result;
              _context5.next = 27;
              return this.rpcClient.getBlock();
            case 27:
              blockTimestamp = _context5.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context5.next = 31;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: permissions,
                chainId: chain[this.chainId],
                wallet: this.wallet
              });
            case 31:
              _yield$getPermissionS2 = _context5.sent;
              signature = _yield$getPermissionS2.signature;
              req = {
                to: validateAddress(this.accessControllerClient.address),
                value: BigInt(0),
                data: data,
                signer: validateAddress(this.wallet.account.address),
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 38;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 38:
              _context5.next = 40;
              return ipAccountClient.executeWithSig(req);
            case 40:
              txHash = _context5.sent;
              if (!((_request$txOptions0 = request.txOptions) !== null && _request$txOptions0 !== void 0 && _request$txOptions0.waitForTransaction)) {
                _context5.next = 47;
                break;
              }
              _context5.next = 44;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 44:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 47:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 48:
              _context5.next = 53;
              break;
            case 50:
              _context5.prev = 50;
              _context5.t1 = _context5["catch"](0);
              handleError(_context5.t1, "Failed to create batch permission signature");
            case 53:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 50], [3, 13, 16, 19]]);
      }));
      function createBatchPermissionSignature(_x5) {
        return _createBatchPermissionSignature.apply(this, arguments);
      }
      return createBatchPermissionSignature;
    }())
  }, {
    key: "checkIsRegistered",
    value: function () {
      var _checkIsRegistered = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipId) {
        var isRegistered;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 2:
              isRegistered = _context6.sent;
              if (isRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("IP id with ".concat(ipId, " is not registered."));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function checkIsRegistered(_x6) {
        return _checkIsRegistered.apply(this, arguments);
      }
      return checkIsRegistered;
    }()
  }]);
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, LicenseClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.piLicenseTemplateReadOnlyClient = new PiLicenseTemplateReadOnlyClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.moduleRegistryReadOnlyClient = new ModuleRegistryReadOnlyClient(rpcClient);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = wallet.account.address;
  }
  /**
   * Registers new license terms and return the ID of the newly registered license terms.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
   */
  return _createClass(LicenseClient, [{
    key: "registerPILTerms",
    value: (function () {
      var _registerPILTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, object, licenseTermsId, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return validateLicenseTerms(request, this.rpcClient);
            case 3:
              object = _context.sent;
              _context.next = 6;
              return this.getLicenseTermsId(object);
            case 6:
              licenseTermsId = _context.sent;
              if (!(licenseTermsId !== 0n)) {
                _context.next = 9;
                break;
              }
              return _context.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 9:
              if (!(request !== null && request !== void 0 && (_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 13;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: object
                })
              });
            case 13:
              _context.next = 15;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: object
              });
            case 15:
              txHash = _context.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 24;
                break;
              }
              _context.next = 19;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 19:
              txReceipt = _context.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 24:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 25:
              _context.next = 30;
              break;
            case 27:
              _context.prev = 27;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register license terms");
            case 30:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 27]]);
      }));
      function registerPILTerms(_x) {
        return _registerPILTerms.apply(this, arguments);
      }
      return registerPILTerms;
    }()
    /**
     * Convenient function to register a PIL non commercial social remix license to the registry
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerNonComSocialRemixingPIL",
    value: (function () {
      var _registerNonComSocialRemixingPIL = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, licenseTerms, licenseTermsId, _request$txOptions4, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.NON_COMMERCIAL_REMIX);
              _context2.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context2.sent;
              if (!(licenseTermsId !== 0n)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!(request !== null && request !== void 0 && (_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 11;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context2.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context2.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 22;
                break;
              }
              _context2.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context2.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context2.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context2.next = 28;
              break;
            case 25:
              _context2.prev = 25;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register non commercial social remixing PIL");
            case 28:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 25]]);
      }));
      function registerNonComSocialRemixingPIL(_x2) {
        return _registerNonComSocialRemixingPIL.apply(this, arguments);
      }
      return registerNonComSocialRemixingPIL;
    }()
    /**
     * Convenient function to register a PIL commercial use license to the registry.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerCommercialUsePIL",
    value: (function () {
      var _registerCommercialUsePIL = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, licenseTerms, licenseTermsId, _request$txOptions6, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_USE, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyAddress: validateAddress(request.royaltyPolicyAddress || royaltyPolicyLapAddress[chain[this.chainId]])
              });
              _context3.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context3.sent;
              if (!(licenseTermsId !== 0n)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context3.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 22;
                break;
              }
              _context3.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context3.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context3.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context3.next = 28;
              break;
            case 25:
              _context3.prev = 25;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register commercial use PIL");
            case 28:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 25]]);
      }));
      function registerCommercialUsePIL(_x3) {
        return _registerCommercialUsePIL.apply(this, arguments);
      }
      return registerCommercialUsePIL;
    }()
    /**
     * Convenient function to register a PIL commercial Remix license to the registry.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerCommercialRemixPIL",
    value: (function () {
      var _registerCommercialRemixPIL = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, licenseTerms, licenseTermsId, _request$txOptions8, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_REMIX, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyAddress: validateAddress(request.royaltyPolicyAddress || royaltyPolicyLapAddress[chain[this.chainId]]),
                commercialRevShare: request.commercialRevShare
              });
              _context4.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context4.sent;
              if (!(licenseTermsId !== 0n)) {
                _context4.next = 7;
                break;
              }
              return _context4.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 11;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context4.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 22;
                break;
              }
              _context4.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context4.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context4.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context4.next = 28;
              break;
            case 25:
              _context4.prev = 25;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register commercial remix PIL");
            case 28:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 25]]);
      }));
      function registerCommercialRemixPIL(_x4) {
        return _registerCommercialRemixPIL.apply(this, arguments);
      }
      return registerCommercialRemixPIL;
    }()
    /**
     * Attaches license terms to an IP.
     */
    )
  }, {
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, isRegistered, isExisted, isAttachedLicenseTerms, req, _request$txOptions0, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context5.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.ipId)
              });
            case 4:
              isRegistered = _context5.sent;
              if (isRegistered) {
                _context5.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(request.ipId, " is not registered."));
            case 7:
              _context5.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context5.sent;
              if (isExisted) {
                _context5.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context5.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context5.sent;
              if (!isAttachedLicenseTerms) {
                _context5.next = 17;
                break;
              }
              return _context5.abrupt("return", {
                txHash: "",
                success: false
              });
            case 17:
              req = {
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.licensingModuleClient.attachLicenseTermsEncode(req)
              });
            case 22:
              _context5.next = 24;
              return this.licensingModuleClient.attachLicenseTerms(req);
            case 24:
              txHash = _context5.sent;
              if (!((_request$txOptions0 = request.txOptions) !== null && _request$txOptions0 !== void 0 && _request$txOptions0.waitForTransaction)) {
                _context5.next = 31;
                break;
              }
              _context5.next = 28;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 28:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 31:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 32:
              _context5.next = 37;
              break;
            case 34:
              _context5.prev = 34;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to attach license terms");
            case 37:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 34]]);
      }));
      function attachLicenseTerms(_x5) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * Mints license tokens for the license terms attached to an IP.
     * It might require the caller pay the minting fee, depending on the license terms or configured by the iP owner.
     * The minting fee is paid in the minting fee token specified in the license terms or configured by the IP owner.
     * IP owners can configure the minting fee of their IPs or configure the minting fee module to determine the minting fee.
     *
     * @remarks
     * Before minting license tokens, the license terms must be attached to the IP, with two exceptions:
     * 1. Default license terms can be minted without explicit attachment since they are automatically
     *    attached to all IPs by default
     * 2. IP owners have special privileges and can mint license tokens for their own IPs using any
     *    license terms, even if those terms are not explicitly attached
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L34 | `LicenseTokensMinted`} event.
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _this = this;
        var _request$txOptions1, receiver, req, isLicenseIpIdRegistered, isExisted, ipAccount, ipOwner, isAttachedLicenseTerms, encodedTxData, licenseMintingFee, wipSpenders, _yield$contractCallWi, txHash, receipt, targetLogs, startLicenseTokenId, licenseTokenIds, i;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              receiver = validateAddress(request.receiver || this.walletAddress);
              req = {
                licensorIpId: validateAddress(request.licensorIpId),
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId),
                amount: BigInt(request.amount || 1),
                receiver: receiver,
                royaltyContext: zeroAddress,
                maxMintingFee: BigInt(request.maxMintingFee),
                maxRevenueShare: getRevenueShare(request.maxRevenueShare, RevShareType.MAX_REVENUE_SHARE)
              };
              if (!(req.maxMintingFee < 0)) {
                _context6.next = 5;
                break;
              }
              throw new Error("The maxMintingFee must be greater than 0.");
            case 5:
              _context6.next = 7;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.licensorIpId)
              });
            case 7:
              isLicenseIpIdRegistered = _context6.sent;
              if (isLicenseIpIdRegistered) {
                _context6.next = 10;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 10:
              _context6.next = 12;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 12:
              isExisted = _context6.sent;
              if (isExisted) {
                _context6.next = 15;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 15:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, req.licensorIpId);
              _context6.next = 18;
              return ipAccount.owner();
            case 18:
              ipOwner = _context6.sent;
              if (!(ipOwner !== this.walletAddress)) {
                _context6.next = 25;
                break;
              }
              _context6.next = 22;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: req.licensorIpId,
                licenseTemplate: req.licenseTemplate,
                licenseTermsId: req.licenseTermsId
              });
            case 22:
              isAttachedLicenseTerms = _context6.sent;
              if (isAttachedLicenseTerms) {
                _context6.next = 25;
                break;
              }
              throw new Error("License terms id ".concat(req.licenseTermsId, " is not attached to the IP with id ").concat(req.licensorIpId, "."));
            case 25:
              encodedTxData = this.licensingModuleClient.mintLicenseTokensEncode(req);
              if (!((_request$txOptions1 = request.txOptions) !== null && _request$txOptions1 !== void 0 && _request$txOptions1.encodedTxDataOnly)) {
                _context6.next = 28;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 28:
              _context6.next = 30;
              return calculateLicenseWipMintFee({
                predictMintingFeeRequest: req,
                rpcClient: this.rpcClient,
                chainId: this.chainId,
                walletAddress: this.walletAddress
              });
            case 30:
              licenseMintingFee = _context6.sent;
              wipSpenders = [];
              if (licenseMintingFee > 0n) {
                wipSpenders.push({
                  address: royaltyModuleAddress[chain[this.chainId]],
                  amount: licenseMintingFee
                });
              }
              _context6.next = 35;
              return contractCallWithFees({
                totalFees: licenseMintingFee,
                options: {
                  wipOptions: request.wipOptions
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: wipSpenders,
                contractCall: function contractCall() {
                  return _this.licensingModuleClient.mintLicenseTokens(req);
                },
                wallet: this.wallet,
                sender: this.walletAddress,
                txOptions: request.txOptions,
                encodedTxs: [encodedTxData]
              });
            case 35:
              _yield$contractCallWi = _context6.sent;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (receipt) {
                _context6.next = 40;
                break;
              }
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 40:
              targetLogs = this.licensingModuleClient.parseTxLicenseTokensMintedEvent(receipt);
              startLicenseTokenId = targetLogs[0].startLicenseTokenId;
              licenseTokenIds = [];
              for (i = 0; i < req.amount; i++) {
                licenseTokenIds.push(startLicenseTokenId + BigInt(i));
              }
              return _context6.abrupt("return", {
                txHash: txHash,
                licenseTokenIds: licenseTokenIds,
                receipt: receipt
              });
            case 47:
              _context6.prev = 47;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to mint license tokens");
            case 50:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 47]]);
      }));
      function mintLicenseTokens(_x6) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * Gets license terms of the given ID.
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(selectedLicenseTermsId) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return this.piLicenseTemplateReadOnlyClient.getLicenseTerms({
                selectedLicenseTermsId: BigInt(selectedLicenseTermsId)
              });
            case 3:
              return _context7.abrupt("return", _context7.sent);
            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to get license terms");
            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 6]]);
      }));
      function getLicenseTerms(_x7) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }()
    /**
     * Pre-compute the minting license fee for the given IP and license terms. The function can be used to calculate the minting license fee before minting license tokens.
     */
    )
  }, {
    key: "predictMintingLicenseFee",
    value: (function () {
      var _predictMintingLicenseFee2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var isLicenseIpIdRegistered, licenseTermsId, isExisted, object;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.licensorIpId)
              });
            case 3:
              isLicenseIpIdRegistered = _context8.sent;
              if (isLicenseIpIdRegistered) {
                _context8.next = 6;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 6:
              licenseTermsId = BigInt(request.licenseTermsId);
              _context8.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: licenseTermsId
              });
            case 9:
              isExisted = _context8.sent;
              if (isExisted) {
                _context8.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                receiver: validateAddress(request.receiver || this.walletAddress),
                amount: BigInt(request.amount),
                royaltyContext: zeroAddress,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: licenseTermsId
              });
              _context8.next = 15;
              return predictMintingLicenseFee({
                predictMintingFeeRequest: object,
                rpcClient: this.rpcClient,
                chainId: this.chainId,
                walletAddress: this.walletAddress
              });
            case 15:
              return _context8.abrupt("return", _context8.sent);
            case 18:
              _context8.prev = 18;
              _context8.t0 = _context8["catch"](0);
              handleError(_context8.t0, "Failed to predict minting license fee");
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[0, 18]]);
      }));
      function predictMintingLicenseFee$1(_x8) {
        return _predictMintingLicenseFee2.apply(this, arguments);
      }
      return predictMintingLicenseFee$1;
    }()
    /**
     * Sets the licensing configuration for a specific license terms of an IP. If both licenseTemplate and licenseTermsId are not specified then the licensing config apply to all licenses of given IP.
     */
    )
  }, {
    key: "setLicensingConfig",
    value: (function () {
      var _setLicensingConfig = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        var _request$txOptions10, req, isLicenseIpIdRegistered, isExisted, isRegistered, _request$txOptions11, txHash;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              req = {
                ipId: request.ipId,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId),
                licensingConfig: validateLicenseConfig(request.licensingConfig)
              };
              if (!(req.licenseTemplate === zeroAddress && req.licensingConfig.commercialRevShare !== 0)) {
                _context9.next = 4;
                break;
              }
              throw new Error("The license template cannot be zero address if commercial revenue share is not zero.");
            case 4:
              _context9.next = 6;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(req.ipId)
              });
            case 6:
              isLicenseIpIdRegistered = _context9.sent;
              if (isLicenseIpIdRegistered) {
                _context9.next = 9;
                break;
              }
              throw new Error("The licensor IP with id ".concat(req.ipId, " is not registered."));
            case 9:
              _context9.next = 11;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 11:
              isExisted = _context9.sent;
              if (isExisted) {
                _context9.next = 14;
                break;
              }
              throw new Error("License terms id ".concat(req.licenseTermsId, " do not exist."));
            case 14:
              if (!(req.licensingConfig.licensingHook !== zeroAddress)) {
                _context9.next = 20;
                break;
              }
              _context9.next = 17;
              return this.moduleRegistryReadOnlyClient.isRegistered({
                moduleAddress: req.licensingConfig.licensingHook
              });
            case 17:
              isRegistered = _context9.sent;
              if (isRegistered) {
                _context9.next = 20;
                break;
              }
              throw new Error("The licensing hook is not registered.");
            case 20:
              if (!(req.licenseTemplate === zeroAddress && req.licenseTermsId !== 0n)) {
                _context9.next = 22;
                break;
              }
              throw new Error("The license template is zero address but license terms id is not zero.");
            case 22:
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.encodedTxDataOnly)) {
                _context9.next = 26;
                break;
              }
              return _context9.abrupt("return", {
                encodedTxData: this.licensingModuleClient.setLicensingConfigEncode(req)
              });
            case 26:
              _context9.next = 28;
              return this.licensingModuleClient.setLicensingConfig(req);
            case 28:
              txHash = _context9.sent;
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.waitForTransaction)) {
                _context9.next = 33;
                break;
              }
              _context9.next = 32;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 32:
              return _context9.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 33:
              return _context9.abrupt("return", {
                txHash: txHash
              });
            case 34:
              _context9.next = 39;
              break;
            case 36:
              _context9.prev = 36;
              _context9.t0 = _context9["catch"](0);
              handleError(_context9.t0, "Failed to set licensing config");
            case 39:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 36]]);
      }));
      function setLicensingConfig(_x9) {
        return _setLicensingConfig.apply(this, arguments);
      }
      return setLicensingConfig;
    }())
  }, {
    key: "getLicensingConfig",
    value: function () {
      var _getLicensingConfig = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee0(request) {
        var licensingConfigParam;
        return _regeneratorRuntime().wrap(function _callee0$(_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              _context0.prev = 0;
              licensingConfigParam = {
                ipId: validateAddress(request.ipId),
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId)
              };
              _context0.next = 4;
              return this.licenseRegistryReadOnlyClient.getLicensingConfig(licensingConfigParam);
            case 4:
              return _context0.abrupt("return", _context0.sent);
            case 7:
              _context0.prev = 7;
              _context0.t0 = _context0["catch"](0);
              handleError(_context0.t0, "Failed to get licensing config");
            case 10:
            case "end":
              return _context0.stop();
          }
        }, _callee0, this, [[0, 7]]);
      }));
      function getLicensingConfig(_x0) {
        return _getLicensingConfig.apply(this, arguments);
      }
      return getLicensingConfig;
    }()
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee1(request) {
        var licenseRes;
        return _regeneratorRuntime().wrap(function _callee1$(_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              _context1.next = 2;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: request
              });
            case 2:
              licenseRes = _context1.sent;
              return _context1.abrupt("return", licenseRes.selectedLicenseTermsId);
            case 4:
            case "end":
              return _context1.stop();
          }
        }, _callee1, this);
      }));
      function getLicenseTermsId(_x1) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }]);
}();

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

var v0Prefix = "1220";
var convertCIDtoHashIPFS = function convertCIDtoHashIPFS(cid) {
  var isV0 = cid.startsWith("Qm");
  var parsedCID = CID.parse(cid);
  var base58CID = isV0 ? parsedCID.toString() : parsedCID.toV0().toString();
  var bytes = bs58.decode(base58CID);
  var base16CID = Array.from(bytes).map(function (_byte) {
    return _byte.toString(16).padStart(2, "0");
  }).join("");
  return "0x" + base16CID.slice(v0Prefix.length);
};
var convertHashIPFStoCID = function convertHashIPFStoCID(hash) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "v0";
  var base16CID = v0Prefix + hash.slice(2);
  var bytes = new Uint8Array(base16CID.match(/.{1,2}/g).map(function (_byte2) {
    return parseInt(_byte2, 16);
  }));
  var base58CID = bs58.encode(Buffer.from(bytes));
  if (version === "v0") {
    return base58CID;
  } else {
    return CID.parse(base58CID, base58btc).toV1().toString();
  }
};

/**
 * The ABI for the OptimisticOracleV3 contract. Contract address may be changed.
 * @see https://aeneid.storyscan.io/address/0xABac6a158431edED06EE6cba37eDE8779F599eE4?tab=contract_abi
 */
var ASSERTION_ABI = [{
  inputs: [{
    internalType: "bytes32",
    name: "assertionId",
    type: "bytes32"
  }],
  name: "getAssertion",
  outputs: [{
    components: [{
      components: [{
        internalType: "bool",
        name: "arbitrateViaEscalationManager",
        type: "bool"
      }, {
        internalType: "bool",
        name: "discardOracle",
        type: "bool"
      }, {
        internalType: "bool",
        name: "validateDisputers",
        type: "bool"
      }, {
        internalType: "address",
        name: "assertingCaller",
        type: "address"
      }, {
        internalType: "address",
        name: "escalationManager",
        type: "address"
      }],
      internalType: "struct OptimisticOracleV3Interface.EscalationManagerSettings",
      name: "escalationManagerSettings",
      type: "tuple"
    }, {
      internalType: "address",
      name: "asserter",
      type: "address"
    }, {
      internalType: "uint64",
      name: "assertionTime",
      type: "uint64"
    }, {
      internalType: "bool",
      name: "settled",
      type: "bool"
    }, {
      internalType: "contract IERC20",
      name: "currency",
      type: "address"
    }, {
      internalType: "uint64",
      name: "expirationTime",
      type: "uint64"
    }, {
      internalType: "bool",
      name: "settlementResolution",
      type: "bool"
    }, {
      internalType: "bytes32",
      name: "domainId",
      type: "bytes32"
    }, {
      internalType: "bytes32",
      name: "identifier",
      type: "bytes32"
    }, {
      internalType: "uint256",
      name: "bond",
      type: "uint256"
    }, {
      internalType: "address",
      name: "callbackRecipient",
      type: "address"
    }, {
      internalType: "address",
      name: "disputer",
      type: "address"
    }],
    internalType: "struct OptimisticOracleV3Interface.Assertion",
    name: "",
    type: "tuple"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes32",
    name: "assertionId",
    type: "bytes32"
  }],
  name: "settleAssertion",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "currency",
    type: "address"
  }],
  name: "getMinimumBond",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];

var getOov3Contract = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(arbitrationPolicyUmaClient) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return arbitrationPolicyUmaClient.oov3();
        case 2:
          return _context.abrupt("return", _context.sent);
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getOov3Contract(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getAssertionDetails = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(rpcClient, arbitrationPolicyUmaClient, assertionId) {
    var oov3Contract, _yield$rpcClient$read, bond;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return getOov3Contract(arbitrationPolicyUmaClient);
        case 2:
          oov3Contract = _context2.sent;
          _context2.next = 5;
          return rpcClient.readContract({
            address: oov3Contract,
            abi: ASSERTION_ABI,
            functionName: "getAssertion",
            args: [assertionId]
          });
        case 5:
          _yield$rpcClient$read = _context2.sent;
          bond = _yield$rpcClient$read.bond;
          return _context2.abrupt("return", bond);
        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getAssertionDetails(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
var getMinimumBond = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(rpcClient, arbitrationPolicyUmaClient, currency) {
    var oov3Contract;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return getOov3Contract(arbitrationPolicyUmaClient);
        case 2:
          oov3Contract = _context3.sent;
          _context3.next = 5;
          return rpcClient.readContract({
            address: oov3Contract,
            abi: ASSERTION_ABI,
            functionName: "getMinimumBond",
            args: [currency]
          });
        case 5:
          return _context3.abrupt("return", _context3.sent);
        case 6:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function getMinimumBond(_x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
  };
}();

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, DisputeClient);
    this.rpcClient = rpcClient;
    this.disputeModuleClient = new DisputeModuleClient(rpcClient, wallet);
    this.arbitrationPolicyUmaClient = new ArbitrationPolicyUmaClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.chainId = chainId;
    this.wallet = wallet;
  }

  /**
   * Raises a dispute on a given ipId.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L64 | `DisputeRaised`} event.
   */
  return _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _this = this;
        var _request$txOptions, liveness, _yield$Promise$all, _yield$Promise$all2, minLiveness, maxLiveness, _yield$Promise$all3, _yield$Promise$all4, minimumBond, maximumBond, bonds, tag, data, _yield$this$disputeMo, isWhiteList, req, encodedTxData, contractCall, _yield$contractCallWi, txHash, receipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              liveness = BigInt(request.liveness);
              _context.next = 4;
              return Promise.all([this.arbitrationPolicyUmaClient.minLiveness(), this.arbitrationPolicyUmaClient.maxLiveness()]);
            case 4:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              minLiveness = _yield$Promise$all2[0];
              maxLiveness = _yield$Promise$all2[1];
              if (!(liveness < minLiveness || liveness > maxLiveness)) {
                _context.next = 10;
                break;
              }
              throw new Error("Liveness must be between ".concat(minLiveness, " and ").concat(maxLiveness, "."));
            case 10:
              _context.next = 12;
              return Promise.all([getMinimumBond(this.rpcClient, this.arbitrationPolicyUmaClient, WIP_TOKEN_ADDRESS), this.arbitrationPolicyUmaClient.maxBonds({
                token: WIP_TOKEN_ADDRESS
              })]);
            case 12:
              _yield$Promise$all3 = _context.sent;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              minimumBond = _yield$Promise$all4[0];
              maximumBond = _yield$Promise$all4[1];
              bonds = BigInt(request.bond || minimumBond);
              if (!(bonds > maximumBond || bonds < minimumBond)) {
                _context.next = 19;
                break;
              }
              throw new Error("Bonds must be between ".concat(minimumBond, " and ").concat(maximumBond, "."));
            case 19:
              tag = stringToHex(request.targetTag, {
                size: 32
              });
              data = encodeAbiParameters([{
                name: "",
                type: "uint64"
              }, {
                name: "",
                type: "address"
              }, {
                name: "",
                type: "uint256"
              }], [liveness, WIP_TOKEN_ADDRESS, bonds]);
              _context.next = 23;
              return this.disputeModuleClient.isWhitelistedDisputeTag({
                tag: tag
              });
            case 23:
              _yield$this$disputeMo = _context.sent;
              isWhiteList = _yield$this$disputeMo.allowed;
              if (isWhiteList) {
                _context.next = 27;
                break;
              }
              throw new Error("The target tag ".concat(request.targetTag, " is not whitelisted."));
            case 27:
              req = {
                targetIpId: validateAddress(request.targetIpId),
                targetTag: tag,
                disputeEvidenceHash: convertCIDtoHashIPFS(request.cid),
                data: data
              };
              encodedTxData = this.disputeModuleClient.raiseDisputeEncode(req);
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 33;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 33:
              contractCall = function contractCall() {
                return _this.disputeModuleClient.raiseDispute(req);
              };
              _context.next = 36;
              return contractCallWithFees({
                totalFees: bonds,
                options: {
                  wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                    // Disable multicall because multicall makes more complex due to disputeInitiator in this version.
                    useMulticallWhenPossible: false
                  })
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: [{
                  address: this.arbitrationPolicyUmaClient.address,
                  amount: bonds
                }],
                contractCall: contractCall,
                encodedTxs: [encodedTxData],
                wallet: this.wallet,
                txOptions: request.txOptions,
                sender: this.wallet.account.address
              });
            case 36:
              _yield$contractCallWi = _context.sent;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (receipt) {
                _context.next = 41;
                break;
              }
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 41:
              targetLogs = this.disputeModuleClient.parseTxDisputeRaisedEvent(receipt);
              return _context.abrupt("return", {
                txHash: txHash,
                disputeId: targetLogs[0].disputeId
              });
            case 43:
              _context.next = 48;
              break;
            case 45:
              _context.prev = 45;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to raise dispute");
            case 48:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 45]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L84 | `DisputeCancelled`} event.
     */
    )
  }, {
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, _req, _request$txOptions3, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _req = {
                disputeId: BigInt(request.disputeId),
                data: request.data ? request.data : "0x"
              };
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.disputeModuleClient.cancelDisputeEncode(_req)
              });
            case 6:
              _context2.next = 8;
              return this.disputeModuleClient.cancelDispute(_req);
            case 8:
              txHash = _context2.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context2.next = 12;
                break;
              }
              _context2.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to cancel dispute");
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 15]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L104 | `DisputeResolved`} event.
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$data, _request$txOptions4, _req2, _request$txOptions5, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _req2 = {
                disputeId: BigInt(request.disputeId),
                data: (_request$data = request.data) !== null && _request$data !== void 0 ? _request$data : "0x"
              };
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.disputeModuleClient.resolveDisputeEncode(_req2)
              });
            case 6:
              _context3.next = 8;
              return this.disputeModuleClient.resolveDispute(_req2);
            case 8:
              txHash = _context3.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.waitForTransaction)) {
                _context3.next = 12;
                break;
              }
              _context3.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context3.next = 18;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to resolve dispute");
            case 18:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 15]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }()
    /**
     * Tags a derivative if a parent has been tagged with an infringement tag
     * or a group ip if a group member has been tagged with an infringement tag.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L93 | `IpTaggedOnRelatedIpInfringement`} event.
     */
    )
  }, {
    key: "tagIfRelatedIpInfringed",
    value: (function () {
      var _tagIfRelatedIpInfringed = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _this2 = this;
        var _request$options, objects, txHashes, calls, txHash, _iterator, _step, object, _txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              objects = request.infringementTags.map(function (arg) {
                return {
                  ipIdToTag: validateAddress(arg.ipId),
                  infringerDisputeId: BigInt(arg.disputeId)
                };
              });
              txHashes = [];
              if (!(((_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.useMulticallWhenPossible) !== false && request.infringementTags.length > 1)) {
                _context4.next = 11;
                break;
              }
              calls = objects.map(function (object) {
                return {
                  target: _this2.disputeModuleClient.address,
                  allowFailure: false,
                  callData: _this2.disputeModuleClient.tagIfRelatedIpInfringedEncode(object).data
                };
              });
              _context4.next = 7;
              return this.multicall3Client.aggregate3({
                calls: calls
              });
            case 7:
              txHash = _context4.sent;
              txHashes.push(txHash);
              _context4.next = 30;
              break;
            case 11:
              _iterator = _createForOfIteratorHelper(objects);
              _context4.prev = 12;
              _iterator.s();
            case 14:
              if ((_step = _iterator.n()).done) {
                _context4.next = 22;
                break;
              }
              object = _step.value;
              _context4.next = 18;
              return this.disputeModuleClient.tagIfRelatedIpInfringed(object);
            case 18:
              _txHash = _context4.sent;
              txHashes.push(_txHash);
            case 20:
              _context4.next = 14;
              break;
            case 22:
              _context4.next = 27;
              break;
            case 24:
              _context4.prev = 24;
              _context4.t0 = _context4["catch"](12);
              _iterator.e(_context4.t0);
            case 27:
              _context4.prev = 27;
              _iterator.f();
              return _context4.finish(27);
            case 30:
              _context4.next = 32;
              return Promise.all(txHashes.map(function (txHash) {
                return waitForTxReceipt({
                  txHash: txHash,
                  txOptions: request.txOptions,
                  rpcClient: _this2.rpcClient
                });
              }));
            case 32:
              return _context4.abrupt("return", _context4.sent);
            case 35:
              _context4.prev = 35;
              _context4.t1 = _context4["catch"](0);
              handleError(_context4.t1, "Failed to tag related ip infringed");
            case 38:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 35], [12, 24, 27, 30]]);
      }));
      function tagIfRelatedIpInfringed(_x4) {
        return _tagIfRelatedIpInfringed.apply(this, arguments);
      }
      return tagIfRelatedIpInfringed;
    }()
    /**
     * Counters a dispute that was raised by another party on an IP using counter evidence.
     * The counter evidence (e.g., documents, images) should be uploaded to IPFS,
     * and its corresponding CID is converted to a hash for the request.
     *
     * @remarks
     *  The liveness period is split in two parts:
     *  - the first part of the liveness period in which only the IP's owner can be called the method.
     *  - a second part in which any address can be called the method.
     *
     * If you only have a `disputeId`, call {@link disputeIdToAssertionId} to get the `assertionId` needed here.
     */
    )
  }, {
    key: "disputeAssertion",
    value: (function () {
      var _disputeAssertion = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _this3 = this;
        var ipAccount, bond, counterEvidenceHash, encodedData, _yield$this$wrappedIp, allowance, _txHash2, contractCall, _yield$contractCallWi2, txHash, receipt;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              _context5.next = 4;
              return getAssertionDetails(this.rpcClient, this.arbitrationPolicyUmaClient, request.assertionId);
            case 4:
              bond = _context5.sent;
              counterEvidenceHash = convertCIDtoHashIPFS(request.counterEvidenceCID);
              encodedData = this.arbitrationPolicyUmaClient.disputeAssertionEncode({
                assertionId: request.assertionId,
                counterEvidenceHash: counterEvidenceHash
              });
              _context5.next = 9;
              return this.wrappedIpClient.allowance({
                owner: this.wallet.account.address,
                spender: ipAccount.address
              });
            case 9:
              _yield$this$wrappedIp = _context5.sent;
              allowance = _yield$this$wrappedIp.result;
              if (!(allowance < bond)) {
                _context5.next = 17;
                break;
              }
              _context5.next = 14;
              return this.wrappedIpClient.approve({
                spender: ipAccount.address,
                amount: maxUint256
              });
            case 14:
              _txHash2 = _context5.sent;
              _context5.next = 17;
              return this.rpcClient.waitForTransactionReceipt({
                hash: _txHash2
              });
            case 17:
              contractCall = function contractCall() {
                var calls = [];
                if (bond > 0) {
                  calls.push({
                    target: _this3.wrappedIpClient.address,
                    value: 0n,
                    data: _this3.wrappedIpClient.transferFromEncode({
                      from: _this3.wallet.account.address,
                      to: ipAccount.address,
                      amount: bond
                    }).data
                  });
                  calls.push({
                    target: _this3.wrappedIpClient.address,
                    value: 0n,
                    data: _this3.wrappedIpClient.approveEncode({
                      spender: _this3.arbitrationPolicyUmaClient.address,
                      amount: maxUint256
                    }).data
                  });
                }
                return ipAccount.executeBatch({
                  calls: [].concat(calls, [{
                    target: encodedData.to,
                    value: 0n,
                    data: encodedData.data
                  }]),
                  operation: 0
                });
              };
              _context5.next = 20;
              return contractCallWithFees({
                totalFees: bond,
                options: {
                  wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                    // Disable auto approve because msg.sender is ipAccount instead of wallet.
                    enableAutoApprove: false,
                    // Disable multicall because multicall makes more complex due to disputeInitiator in this version.
                    useMulticallWhenPossible: false
                  })
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                contractCall: contractCall,
                tokenSpenders: [{
                  address: this.arbitrationPolicyUmaClient.address,
                  amount: bond
                }],
                encodedTxs: [encodedData],
                wallet: this.wallet,
                sender: this.wallet.account.address,
                txOptions: request.txOptions
              });
            case 20:
              _yield$contractCallWi2 = _context5.sent;
              txHash = _yield$contractCallWi2.txHash;
              receipt = _yield$contractCallWi2.receipt;
              if (receipt) {
                _context5.next = 25;
                break;
              }
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 25:
              return _context5.abrupt("return", {
                txHash: txHash,
                receipt: receipt
              });
            case 28:
              _context5.prev = 28;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to dispute assertion");
            case 31:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 28]]);
      }));
      function disputeAssertion(_x5) {
        return _disputeAssertion.apply(this, arguments);
      }
      return disputeAssertion;
    }())
  }, {
    key: "disputeIdToAssertionId",
    value: function () {
      var _disputeIdToAssertionId = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(disputeId) {
        var assertionId;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.arbitrationPolicyUmaClient.disputeIdToAssertionId({
                disputeId: BigInt(disputeId)
              });
            case 2:
              assertionId = _context6.sent;
              return _context6.abrupt("return", assertionId);
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function disputeIdToAssertionId(_x6) {
        return _disputeIdToAssertionId.apply(this, arguments);
      }
      return disputeIdToAssertionId;
    }()
  }]);
}();

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAccountClient);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
    this.chainId = chainId;
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.erc20Client = new Erc20Client(rpcClient, wallet);
  }

  /**
   * Executes a transaction from the IP Account.
   */
  return _createClass(IPAccountClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipAccountClient, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              req = {
                to: request.to,
                value: BigInt(0),
                data: request.data
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: ipAccountClient.executeEncode(_objectSpread2(_objectSpread2({}, req), {}, {
                  operation: 0
                }))
              });
            case 7:
              _context.next = 9;
              return ipAccountClient.execute(_objectSpread2(_objectSpread2({}, req), {}, {
                operation: 0
              }));
            case 9:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context.next = 19;
              break;
            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to execute the IP Account transaction");
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 16]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /**
     * Executes a transaction from the IP Account with a signature.
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipAccountClient, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              req = {
                to: validateAddress(request.to),
                value: BigInt(request.value || 0),
                data: request.data,
                signer: validateAddress(request.signer),
                deadline: BigInt(request.deadline),
                signature: request.signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 7:
              _context2.next = 9;
              return ipAccountClient.executeWithSig(req);
            case 9:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 13;
                break;
              }
              _context2.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to execute with signature for the IP Account transaction");
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 16]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /**
     * Returns the IPAccount's internal nonce for transaction ordering.
     */
    )
  }, {
    key: "getIpAccountNonce",
    value: (function () {
      var _getIpAccountNonce = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ipId) {
        var ipAccount, _yield$ipAccount$stat, state;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              _context3.next = 4;
              return ipAccount.state();
            case 4:
              _yield$ipAccount$stat = _context3.sent;
              state = _yield$ipAccount$stat.result;
              return _context3.abrupt("return", state);
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to get the IP Account nonce");
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 9]]);
      }));
      function getIpAccountNonce(_x3) {
        return _getIpAccountNonce.apply(this, arguments);
      }
      return getIpAccountNonce;
    }()
    /**
     * Returns the identifier of the non-fungible token which owns the account
     */
    )
  }, {
    key: "getToken",
    value: (function () {
      var _getToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ipId) {
        var ipAccount, _yield$ipAccount$toke, _yield$ipAccount$toke2, chainId, tokenContract, tokenId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              _context4.next = 4;
              return ipAccount.token();
            case 4:
              _yield$ipAccount$toke = _context4.sent;
              _yield$ipAccount$toke2 = _slicedToArray(_yield$ipAccount$toke, 3);
              chainId = _yield$ipAccount$toke2[0];
              tokenContract = _yield$ipAccount$toke2[1];
              tokenId = _yield$ipAccount$toke2[2];
              return _context4.abrupt("return", {
                chainId: chainId,
                tokenContract: tokenContract,
                tokenId: tokenId
              });
            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to get the token");
            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 12]]);
      }));
      function getToken(_x4) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }()
    /**
     * Sets the metadataURI for an IP asset.
     */
    )
  }, {
    key: "setIpMetadata",
    value: (function () {
      var _setIpMetadata = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {
        var ipId, metadataURI, metadataHash, txOptions, data, _yield$this$execute, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              ipId = _ref.ipId, metadataURI = _ref.metadataURI, metadataHash = _ref.metadataHash, txOptions = _ref.txOptions;
              _context5.prev = 1;
              data = encodeFunctionData({
                abi: coreMetadataModuleAbi,
                functionName: "setMetadataURI",
                args: [validateAddress(ipId), metadataURI, metadataHash]
              });
              _context5.next = 5;
              return this.execute({
                ipId: ipId,
                to: coreMetadataModuleAddress[this.chainId],
                data: data,
                value: 0,
                txOptions: _objectSpread2(_objectSpread2({}, txOptions), {}, {
                  encodedTxDataOnly: false
                })
              });
            case 5:
              _yield$this$execute = _context5.sent;
              txHash = _yield$this$execute.txHash;
              return _context5.abrupt("return", txHash);
            case 10:
              _context5.prev = 10;
              _context5.t0 = _context5["catch"](1);
              handleError(_context5.t0, "Failed to set the IP metadata");
            case 13:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[1, 10]]);
      }));
      function setIpMetadata(_x5) {
        return _setIpMetadata.apply(this, arguments);
      }
      return setIpMetadata;
    }()
    /**
     * Transfers ERC20 tokens from the IP Account to the target address.
     */
    )
  }, {
    key: "transferErc20",
    value: (function () {
      var _transferErc = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var _this = this;
        var ipId, tokens, txOptions, ipAccount, calls, txHash;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              ipId = _ref2.ipId, tokens = _ref2.tokens, txOptions = _ref2.txOptions;
              _context6.prev = 1;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              calls = tokens.map(function (_ref3) {
                var token = _ref3.address,
                  target = _ref3.target,
                  amount = _ref3.amount;
                var encodedData;
                if (validateAddress(token) === WIP_TOKEN_ADDRESS) {
                  encodedData = _this.wrappedIpClient.transferEncode({
                    to: validateAddress(target),
                    amount: BigInt(amount)
                  }).data;
                } else {
                  encodedData = _this.erc20Client.transferEncode({
                    to: validateAddress(target),
                    value: BigInt(amount)
                  }).data;
                }
                return {
                  target: token,
                  data: encodedData,
                  value: 0n
                };
              });
              _context6.next = 6;
              return ipAccount.executeBatch({
                calls: calls,
                operation: 0
              });
            case 6:
              txHash = _context6.sent;
              return _context6.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 10:
              _context6.prev = 10;
              _context6.t0 = _context6["catch"](1);
              handleError(_context6.t0, "Failed to transfer Erc20");
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[1, 10]]);
      }));
      function transferErc20(_x6) {
        return _transferErc.apply(this, arguments);
      }
      return transferErc20;
    }())
  }]);
}();

/** The amount of revenue token claimable. */

/**
 * Native royalty policy created by the Story team
 */
var NativeRoyaltyPolicy = /*#__PURE__*/function (NativeRoyaltyPolicy) {
  NativeRoyaltyPolicy[NativeRoyaltyPolicy["LAP"] = 0] = "LAP";
  NativeRoyaltyPolicy[NativeRoyaltyPolicy["LRP"] = 1] = "LRP";
  return NativeRoyaltyPolicy;
}({});

/**
 * Allow custom royalty policy address or use a native royalty policy enum
 */

var royaltyPolicyInputToAddress = function royaltyPolicyInputToAddress(input, chainId) {
  switch (input) {
    case NativeRoyaltyPolicy.LAP:
      return royaltyPolicyLapAddress[chain[chainId]];
    case NativeRoyaltyPolicy.LRP:
      return royaltyPolicyLrpAddress[chain[chainId]];
    default:
      return validateAddress(input);
  }
};

var RoyaltyClient = /*#__PURE__*/function () {
  function RoyaltyClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, RoyaltyClient);
    this.royaltyModuleClient = new RoyaltyModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.ipRoyaltyVaultImplReadOnlyClient = new IpRoyaltyVaultImplReadOnlyClient(rpcClient);
    this.ipRoyaltyVaultImplEventClient = new IpRoyaltyVaultImplEventClient(rpcClient);
    this.royaltyWorkflowsClient = new RoyaltyWorkflowsClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = wallet.account.address;
  }
  /**
   * Claims all revenue from the child IPs of an ancestor IP, then transfer
   * all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
   * If claimed token is WIP, it will also be converted back to IP.
   *
   * @remarks
   * Even if there are no child IPs, you must still populate {@link ClaimAllRevenueRequest.currencyTokens} with
   * the token addresses you wish to claim. This is required for the claim operation to know which
   * token balances to process.
   */
  return _createClass(RoyaltyClient, [{
    key: "claimAllRevenue",
    value: (function () {
      var _claimAllRevenue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(req) {
        var _req$claimOptions, _req$claimOptions2, ancestorIpId, claimer, childIpIds, royaltyPolicies, currencyTokens, txHashes, txHash, receipt, _yield$this$getClaime, ownsClaimer, isClaimerIp, ipAccount, claimedTokens, autoTransfer, autoUnwrapIp, hashes, _hashes;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ancestorIpId = validateAddress(req.ancestorIpId);
              claimer = validateAddress(req.claimer);
              childIpIds = validateAddresses(req.childIpIds);
              royaltyPolicies = validateAddresses(req.royaltyPolicies);
              currencyTokens = validateAddresses(req.currencyTokens);
              txHashes = [];
              _context.next = 9;
              return this.royaltyWorkflowsClient.claimAllRevenue({
                ancestorIpId: ancestorIpId,
                claimer: claimer,
                childIpIds: childIpIds,
                royaltyPolicies: royaltyPolicies,
                currencyTokens: currencyTokens
              });
            case 9:
              txHash = _context.sent;
              _context.next = 12;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 12:
              receipt = _context.sent;
              txHashes.push(txHash);

              // determine if the claimer is an IP owned by the wallet
              _context.next = 16;
              return this.getClaimerInfo(claimer);
            case 16:
              _yield$this$getClaime = _context.sent;
              ownsClaimer = _yield$this$getClaime.ownsClaimer;
              isClaimerIp = _yield$this$getClaime.isClaimerIp;
              ipAccount = _yield$this$getClaime.ipAccount;
              if (ownsClaimer) {
                _context.next = 22;
                break;
              }
              return _context.abrupt("return", {
                receipt: receipt,
                txHashes: txHashes
              });
            case 22:
              claimedTokens = this.ipRoyaltyVaultImplEventClient.parseTxRevenueTokenClaimedEvent(receipt);
              autoTransfer = ((_req$claimOptions = req.claimOptions) === null || _req$claimOptions === void 0 ? void 0 : _req$claimOptions.autoTransferAllClaimedTokensFromIp) !== false;
              autoUnwrapIp = ((_req$claimOptions2 = req.claimOptions) === null || _req$claimOptions2 === void 0 ? void 0 : _req$claimOptions2.autoUnwrapIpTokens) !== false; // transfer claimed tokens from IP to wallet if wallet owns IP
              if (!(autoTransfer && isClaimerIp && ownsClaimer)) {
                _context.next = 30;
                break;
              }
              _context.next = 28;
              return this.transferClaimedTokensFromIpToWallet({
                ipAccount: ipAccount,
                claimedTokens: claimedTokens
              });
            case 28:
              hashes = _context.sent;
              txHashes.push.apply(txHashes, _toConsumableArray(hashes));
            case 30:
              if (!autoUnwrapIp) {
                _context.next = 35;
                break;
              }
              _context.next = 33;
              return this.unwrapWipTokens(claimedTokens);
            case 33:
              _hashes = _context.sent;
              if (_hashes) {
                txHashes.push(_hashes);
              }
            case 35:
              return _context.abrupt("return", {
                receipt: receipt,
                claimedTokens: claimedTokens,
                txHashes: txHashes
              });
            case 38:
              _context.prev = 38;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to claim all revenue");
            case 41:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 38]]);
      }));
      function claimAllRevenue(_x) {
        return _claimAllRevenue.apply(this, arguments);
      }
      return claimAllRevenue;
    }()
    /**
     * Automatically batch claims all revenue from the child IPs of multiple ancestor IPs.
     * if multicall is disabled, it will call @link{claimAllRevenue} for each ancestor IP.
     * Then transfer all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
     * If claimed token is WIP, it will also be converted back to IP.
     *
     * @remarks
     * Even if there are no child IPs, you must still populate `currencyTokens` in each ancestor IP
     * with the token addresses you wish to claim. This is required for the claim operation to know which
     * token balances to process.
     */
    )
  }, {
    key: "batchClaimAllRevenue",
    value: (function () {
      var _batchClaimAllRevenue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _this = this;
        var _request$options, _request$claimOptions, _request$claimOptions2, txHashes, receipts, claimedTokens, useMulticallWhenPossible, _iterator, _step, ancestorIp, result, encodedTxs, txHash, receipt, claimedTokenLogs, aggregatedClaimedTokens, claimers, autoTransfer, autoUnwrapIp, wipClaimableAmounts, _iterator2, _step2, _loop, hash;
        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              txHashes = [];
              receipts = [];
              claimedTokens = []; // if the number of ancestor IPs is 1 or if multicall is disabled, then just call claimAllRevenue.
              useMulticallWhenPossible = ((_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.useMulticallWhenPossible) !== false;
              if (!(request.ancestorIps.length === 1 || !useMulticallWhenPossible)) {
                _context3.next = 29;
                break;
              }
              _iterator = _createForOfIteratorHelper(request.ancestorIps);
              _context3.prev = 7;
              _iterator.s();
            case 9:
              if ((_step = _iterator.n()).done) {
                _context3.next = 19;
                break;
              }
              ancestorIp = _step.value;
              _context3.next = 13;
              return this.claimAllRevenue(_objectSpread2(_objectSpread2({}, ancestorIp), {}, {
                ancestorIpId: ancestorIp.ipId,
                claimOptions: {
                  autoTransferAllClaimedTokensFromIp: false,
                  autoUnwrapIpTokens: false
                }
              }));
            case 13:
              result = _context3.sent;
              txHashes.push.apply(txHashes, _toConsumableArray(result.txHashes));
              receipts.push(result.receipt);
              if (result.claimedTokens) {
                claimedTokens.push.apply(claimedTokens, _toConsumableArray(result.claimedTokens));
              }
            case 17:
              _context3.next = 9;
              break;
            case 19:
              _context3.next = 24;
              break;
            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](7);
              _iterator.e(_context3.t0);
            case 24:
              _context3.prev = 24;
              _iterator.f();
              return _context3.finish(24);
            case 27:
              _context3.next = 40;
              break;
            case 29:
              // Batch claimAllRevenue the calls into a single multicall
              encodedTxs = request.ancestorIps.map(function (_ref) {
                var ipId = _ref.ipId,
                  claimer = _ref.claimer,
                  childIpIds = _ref.childIpIds,
                  royaltyPolicies = _ref.royaltyPolicies,
                  currencyTokens = _ref.currencyTokens;
                var claim = {
                  ancestorIpId: validateAddress(ipId),
                  claimer: validateAddress(claimer),
                  childIpIds: validateAddresses(childIpIds),
                  royaltyPolicies: validateAddresses(royaltyPolicies),
                  currencyTokens: validateAddresses(currencyTokens)
                };
                return _this.royaltyWorkflowsClient.claimAllRevenueEncode(claim).data;
              });
              _context3.next = 32;
              return this.royaltyWorkflowsClient.multicall({
                data: encodedTxs
              });
            case 32:
              txHash = _context3.sent;
              _context3.next = 35;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 35:
              receipt = _context3.sent;
              txHashes.push(txHash);
              receipts.push(receipt);
              claimedTokenLogs = this.ipRoyaltyVaultImplEventClient.parseTxRevenueTokenClaimedEvent(receipt);
              claimedTokens.push.apply(claimedTokens, _toConsumableArray(claimedTokenLogs));
            case 40:
              // Aggregate claimed tokens by claimer and token address
              aggregatedClaimedTokens = Object.values(claimedTokens.reduce(function (acc, curr) {
                var key = "".concat(curr.claimer, "_").concat(curr.token);
                if (!acc[key]) {
                  acc[key] = _objectSpread2({}, curr);
                } else {
                  acc[key].amount += curr.amount;
                }
                return acc;
              }, {}));
              claimers = _toConsumableArray(new Set(request.ancestorIps.map(function (_ref2) {
                var claimer = _ref2.claimer;
                return claimer;
              })));
              autoTransfer = ((_request$claimOptions = request.claimOptions) === null || _request$claimOptions === void 0 ? void 0 : _request$claimOptions.autoTransferAllClaimedTokensFromIp) !== false;
              autoUnwrapIp = ((_request$claimOptions2 = request.claimOptions) === null || _request$claimOptions2 === void 0 ? void 0 : _request$claimOptions2.autoUnwrapIpTokens) !== false;
              wipClaimableAmounts = 0n;
              _iterator2 = _createForOfIteratorHelper(claimers);
              _context3.prev = 46;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var claimer, _yield$_this$getClaim, ownsClaimer, isClaimerIp, ipAccount, filterClaimedTokens, hashes;
                return _regeneratorRuntime().wrap(function _loop$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      claimer = _step2.value;
                      _context2.next = 3;
                      return _this.getClaimerInfo(claimer);
                    case 3:
                      _yield$_this$getClaim = _context2.sent;
                      ownsClaimer = _yield$_this$getClaim.ownsClaimer;
                      isClaimerIp = _yield$_this$getClaim.isClaimerIp;
                      ipAccount = _yield$_this$getClaim.ipAccount;
                      if (ownsClaimer) {
                        _context2.next = 9;
                        break;
                      }
                      return _context2.abrupt("return", 1);
                    case 9:
                      filterClaimedTokens = aggregatedClaimedTokens.filter(function (item) {
                        return item.claimer === claimer;
                      }); // transfer claimed tokens from IP to wallet if wallet owns IP
                      if (!(autoTransfer && isClaimerIp && ownsClaimer)) {
                        _context2.next = 15;
                        break;
                      }
                      _context2.next = 13;
                      return _this.transferClaimedTokensFromIpToWallet({
                        ipAccount: ipAccount,
                        claimedTokens: filterClaimedTokens
                      });
                    case 13:
                      hashes = _context2.sent;
                      txHashes.push.apply(txHashes, _toConsumableArray(hashes));
                    case 15:
                      // Sum up the amount of WIP tokens claimed
                      wipClaimableAmounts += filterClaimedTokens.reduce(function (acc, curr) {
                        if (curr.token === WIP_TOKEN_ADDRESS) {
                          return acc + curr.amount;
                        }
                        return acc;
                      }, 0n);
                    case 16:
                    case "end":
                      return _context2.stop();
                  }
                }, _loop);
              });
              _iterator2.s();
            case 49:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 55;
                break;
              }
              return _context3.delegateYield(_loop(), "t1", 51);
            case 51:
              if (!_context3.t1) {
                _context3.next = 53;
                break;
              }
              return _context3.abrupt("continue", 53);
            case 53:
              _context3.next = 49;
              break;
            case 55:
              _context3.next = 60;
              break;
            case 57:
              _context3.prev = 57;
              _context3.t2 = _context3["catch"](46);
              _iterator2.e(_context3.t2);
            case 60:
              _context3.prev = 60;
              _iterator2.f();
              return _context3.finish(60);
            case 63:
              if (!(wipClaimableAmounts > 0n && autoUnwrapIp)) {
                _context3.next = 68;
                break;
              }
              _context3.next = 66;
              return this.unwrapWipTokens([{
                token: WIP_TOKEN_ADDRESS,
                amount: wipClaimableAmounts,
                claimer: this.walletAddress
              }]);
            case 66:
              hash = _context3.sent;
              if (hash) {
                txHashes.push(hash);
              }
            case 68:
              return _context3.abrupt("return", {
                receipts: receipts,
                claimedTokens: aggregatedClaimedTokens,
                txHashes: txHashes
              });
            case 71:
              _context3.prev = 71;
              _context3.t3 = _context3["catch"](0);
              handleError(new Error(_context3.t3.message.replace("Failed to claim all revenue: ", "").trim()), "Failed to batch claim all revenue");
            case 74:
            case "end":
              return _context3.stop();
          }
        }, _callee2, this, [[0, 71], [7, 21, 24, 27], [46, 57, 60, 63]]);
      }));
      function batchClaimAllRevenue(_x2) {
        return _batchClaimAllRevenue.apply(this, arguments);
      }
      return batchClaimAllRevenue;
    }()
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     */
    )
  }, {
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _this2 = this;
        var _request$txOptions, receiverIpId, payerIpId, token, amount, erc20Options, wipOptions, txOptions, sender, payAmount, isReceiverRegistered, isPayerRegistered, req, encodedTxData, contractCall, tokenSpenders;
        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              receiverIpId = request.receiverIpId, payerIpId = request.payerIpId, token = request.token, amount = request.amount, erc20Options = request.erc20Options, wipOptions = request.wipOptions, txOptions = request.txOptions;
              sender = this.wallet.account.address;
              payAmount = BigInt(amount);
              if (!(payAmount <= 0n)) {
                _context4.next = 6;
                break;
              }
              throw new Error("The amount to pay must be number greater than 0.");
            case 6:
              _context4.next = 8;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(receiverIpId)
              });
            case 8:
              isReceiverRegistered = _context4.sent;
              if (isReceiverRegistered) {
                _context4.next = 11;
                break;
              }
              throw new Error("The receiver IP with id ".concat(receiverIpId, " is not registered."));
            case 11:
              if (!(validateAddress(payerIpId) && payerIpId !== zeroAddress)) {
                _context4.next = 17;
                break;
              }
              _context4.next = 14;
              return this.ipAssetRegistryClient.isRegistered({
                id: payerIpId
              });
            case 14:
              isPayerRegistered = _context4.sent;
              if (isPayerRegistered) {
                _context4.next = 17;
                break;
              }
              throw new Error("The payer IP with id ".concat(request.payerIpId, " is not registered."));
            case 17:
              req = {
                receiverIpId: receiverIpId,
                payerIpId: payerIpId,
                token: validateAddress(token),
                amount: BigInt(amount)
              };
              encodedTxData = this.royaltyModuleClient.payRoyaltyOnBehalfEncode(req);
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context4.next = 21;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: encodedTxData
              });
            case 21:
              contractCall = function contractCall() {
                return _this2.royaltyModuleClient.payRoyaltyOnBehalf(req);
              };
              tokenSpenders = [{
                address: this.royaltyModuleClient.address,
                amount: payAmount
              }];
              _context4.next = 25;
              return contractCallWithFees({
                totalFees: payAmount,
                options: {
                  erc20Options: erc20Options,
                  wipOptions: wipOptions
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: tokenSpenders,
                contractCall: contractCall,
                sender: sender,
                token: token,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: [encodedTxData]
              });
            case 25:
              return _context4.abrupt("return", _context4.sent);
            case 28:
              _context4.prev = 28;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to pay royalty on behalf");
            case 31:
            case "end":
              return _context4.stop();
          }
        }, _callee3, this, [[0, 28]]);
      }));
      function payRoyaltyOnBehalf(_x3) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * Get total amount of revenue token claimable by a royalty token holder.
     * Returns the amount of revenue token claimable by the claimer.
     */
    )
  }, {
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var proxyAddress, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return this.getRoyaltyVaultAddress(validateAddress(request.royaltyVaultIpId));
            case 3:
              proxyAddress = _context5.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplReadOnlyClient(this.rpcClient, proxyAddress);
              _context5.next = 7;
              return ipRoyaltyVault.claimableRevenue({
                claimer: validateAddress(request.claimer),
                token: validateAddress(request.token)
              });
            case 7:
              return _context5.abrupt("return", _context5.sent);
            case 10:
              _context5.prev = 10;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to calculate claimable revenue");
            case 13:
            case "end":
              return _context5.stop();
          }
        }, _callee4, this, [[0, 10]]);
      }));
      function claimableRevenue(_x4) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * Get the royalty vault proxy address of given royaltyVaultIpId.
     */
    )
  }, {
    key: "getRoyaltyVaultAddress",
    value: (function () {
      var _getRoyaltyVaultAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(royaltyVaultIpId) {
        var isRoyaltyVaultIpIdRegistered;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(royaltyVaultIpId)
              });
            case 2:
              isRoyaltyVaultIpIdRegistered = _context6.sent;
              if (isRoyaltyVaultIpIdRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " is not registered."));
            case 5:
              _context6.next = 7;
              return this.royaltyModuleClient.ipRoyaltyVaults({
                ipId: royaltyVaultIpId
              });
            case 7:
              return _context6.abrupt("return", _context6.sent);
            case 8:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function getRoyaltyVaultAddress(_x5) {
        return _getRoyaltyVaultAddress.apply(this, arguments);
      }
      return getRoyaltyVaultAddress;
    }()
    /**
     * Transfers to vault an amount of revenue tokens claimable via a royalty policy.
     */
    )
  }, {
    key: "transferToVault",
    value: (function () {
      var _transferToVault = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref3) {
        var txOptions, ipId, royaltyPolicy, ancestorIpId, token, royaltyPolicyAddress, protocolArgs, _yield$this$rpcClient, call, txHash;
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              txOptions = _ref3.txOptions, ipId = _ref3.ipId, royaltyPolicy = _ref3.royaltyPolicy, ancestorIpId = _ref3.ancestorIpId, token = _ref3.token;
              royaltyPolicyAddress = royaltyPolicyInputToAddress(royaltyPolicy, this.chainId);
              protocolArgs = [validateAddress(ipId), validateAddress(ancestorIpId), validateAddress(token)];
              _context7.next = 5;
              return this.rpcClient.simulateContract({
                abi: royaltyPolicyLrpAbi,
                // same abi for all royalty policies
                address: royaltyPolicyAddress,
                functionName: "transferToVault",
                account: this.wallet.account,
                args: protocolArgs
              });
            case 5:
              _yield$this$rpcClient = _context7.sent;
              call = _yield$this$rpcClient.request;
              _context7.next = 9;
              return this.wallet.writeContract(call);
            case 9:
              txHash = _context7.sent;
              return _context7.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                rpcClient: this.rpcClient,
                txOptions: txOptions
              }));
            case 11:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this);
      }));
      function transferToVault(_x6) {
        return _transferToVault.apply(this, arguments);
      }
      return transferToVault;
    }())
  }, {
    key: "transferClaimedTokensFromIpToWallet",
    value: function () {
      var _transferClaimedTokensFromIpToWallet = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref4) {
        var ipAccount, claimedTokens, txHashes, calls, _iterator3, _step3, _step3$value, token, amount, hash;
        return _regeneratorRuntime().wrap(function _callee7$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              ipAccount = _ref4.ipAccount, claimedTokens = _ref4.claimedTokens;
              txHashes = [];
              calls = [];
              _iterator3 = _createForOfIteratorHelper(claimedTokens);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  _step3$value = _step3.value, token = _step3$value.token, amount = _step3$value.amount;
                  calls.push({
                    target: token,
                    value: BigInt(0),
                    data: encodeFunctionData({
                      abi: erc20Abi$1,
                      functionName: "transfer",
                      args: [this.walletAddress, amount]
                    })
                  });
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              _context8.next = 7;
              return ipAccount.executeBatch({
                calls: calls,
                operation: 0
              });
            case 7:
              hash = _context8.sent;
              _context8.next = 10;
              return this.rpcClient.waitForTransactionReceipt({
                hash: hash
              });
            case 10:
              txHashes.push(hash);
              return _context8.abrupt("return", txHashes);
            case 12:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this);
      }));
      function transferClaimedTokensFromIpToWallet(_x7) {
        return _transferClaimedTokensFromIpToWallet.apply(this, arguments);
      }
      return transferClaimedTokensFromIpToWallet;
    }()
  }, {
    key: "getClaimerInfo",
    value: function () {
      var _getClaimerInfo = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(claimer) {
        var isClaimerIp, ipAccount, ownsClaimer, ipOwner;
        return _regeneratorRuntime().wrap(function _callee8$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: claimer
              });
            case 2:
              isClaimerIp = _context9.sent;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, claimer);
              ownsClaimer = claimer === this.walletAddress;
              if (!isClaimerIp) {
                _context9.next = 10;
                break;
              }
              _context9.next = 8;
              return ipAccount.owner();
            case 8:
              ipOwner = _context9.sent;
              ownsClaimer = ipOwner === this.walletAddress;
            case 10:
              return _context9.abrupt("return", {
                ownsClaimer: ownsClaimer,
                isClaimerIp: isClaimerIp,
                ipAccount: ipAccount
              });
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee8, this);
      }));
      function getClaimerInfo(_x8) {
        return _getClaimerInfo.apply(this, arguments);
      }
      return getClaimerInfo;
    }()
    /**
     * Unwraps WIP tokens back to their underlying IP tokens. Only accepts a single WIP token entry
     * in the claimed tokens array. Throws an error if multiple WIP tokens are found.
     */
  }, {
    key: "unwrapWipTokens",
    value: (function () {
      var _unwrapWipTokens = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(claimedTokens) {
        var wipTokens, wipToken, hash;
        return _regeneratorRuntime().wrap(function _callee9$(_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              wipTokens = claimedTokens.filter(function (token) {
                return token.token === WIP_TOKEN_ADDRESS;
              });
              if (!(wipTokens.length > 1)) {
                _context0.next = 3;
                break;
              }
              throw new Error("Multiple WIP tokens found in the claimed tokens.");
            case 3:
              wipToken = wipTokens[0];
              if (!(!wipToken || wipToken.amount <= 0n)) {
                _context0.next = 6;
                break;
              }
              return _context0.abrupt("return");
            case 6:
              _context0.next = 8;
              return this.wrappedIpClient.withdraw({
                value: wipToken.amount
              });
            case 8:
              hash = _context0.sent;
              _context0.next = 11;
              return this.rpcClient.waitForTransactionReceipt({
                hash: hash
              });
            case 11:
              return _context0.abrupt("return", hash);
            case 12:
            case "end":
              return _context0.stop();
          }
        }, _callee9, this);
      }));
      function unwrapWipTokens(_x9) {
        return _unwrapWipTokens.apply(this, arguments);
      }
      return unwrapWipTokens;
    }())
  }]);
}();

var NftClient = /*#__PURE__*/function () {
  function NftClient(rpcClient, wallet) {
    _classCallCheck(this, NftClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
  }

  /**
   * Creates a new SPG NFT Collection.
   *
   * Emits an on-chain `CollectionCreated` event.
   * @see {@link https://github.com/storyprotocol/protocol-periphery-v1/blob/v1.3.1/contracts/interfaces/workflows/IRegistrationWorkflows.sol#L12 | IRegistrationWorkflows}
   */
  return _createClass(NftClient, [{
    key: "createNFTCollection",
    value: (function () {
      var _createNFTCollection = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$baseURI, _request$maxSupply, _request$mintFee, _request$mintFeeToken, _request$txOptions, object, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (!(request.mintFee !== undefined && (request.mintFee < 0n || request.mintFeeToken === zeroAddress || !isAddress(request.mintFeeToken || "")))) {
                _context.next = 3;
                break;
              }
              throw new Error("Invalid mint fee token address, mint fee is greater than 0.");
            case 3:
              object = {
                spgNftInitParams: {
                  name: request.name,
                  symbol: request.symbol,
                  baseURI: (_request$baseURI = request.baseURI) !== null && _request$baseURI !== void 0 ? _request$baseURI : "",
                  maxSupply: (_request$maxSupply = request.maxSupply) !== null && _request$maxSupply !== void 0 ? _request$maxSupply : Number(maxUint32),
                  mintFee: (_request$mintFee = request.mintFee) !== null && _request$mintFee !== void 0 ? _request$mintFee : 0n,
                  mintFeeToken: (_request$mintFeeToken = request.mintFeeToken) !== null && _request$mintFeeToken !== void 0 ? _request$mintFeeToken : zeroAddress,
                  owner: validateAddress(request.owner || this.wallet.account.address),
                  mintFeeRecipient: validateAddress(request.mintFeeRecipient),
                  mintOpen: request.mintOpen,
                  isPublicMinting: request.isPublicMinting,
                  contractURI: request.contractURI
                }
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.registrationWorkflowsClient.createCollectionEncode(object)
              });
            case 8:
              _context.next = 10;
              return this.registrationWorkflowsClient.createCollection(object);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              txReceipt = _context.sent;
              targetLogs = this.registrationWorkflowsClient.parseTxCollectionCreatedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                spgNftContract: targetLogs[0].spgNftContract
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to create an SPG NFT collection");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function createNFTCollection(_x) {
        return _createNFTCollection.apply(this, arguments);
      }
      return createNFTCollection;
    }()
    /**
     * Returns the current mint token of the collection.
     */
    )
  }, {
    key: "getMintFeeToken",
    value: (function () {
      var _getMintFeeToken = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(spgNftContract) {
        var spgNftClient;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, validateAddress(spgNftContract));
              return _context2.abrupt("return", spgNftClient.mintFeeToken());
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getMintFeeToken(_x2) {
        return _getMintFeeToken.apply(this, arguments);
      }
      return getMintFeeToken;
    }()
    /**
     * Returns the current mint fee of the collection.
     */
    )
  }, {
    key: "getMintFee",
    value: (function () {
      var _getMintFee = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(spgNftContract) {
        var spgNftClient;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, validateAddress(spgNftContract));
              return _context3.abrupt("return", spgNftClient.mintFee());
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getMintFee(_x3) {
        return _getMintFee.apply(this, arguments);
      }
      return getMintFee;
    }()
    /**
     * Sets the token URI for a specific token id.
     *
     * @remarks
     * Only callable by the owner of the token.
     */
    )
  }, {
    key: "setTokenURI",
    value: (function () {
      var _setTokenURI = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref) {
        var tokenId, tokenURI, spgNftContract, txOptions, spgNftClient, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              tokenId = _ref.tokenId, tokenURI = _ref.tokenURI, spgNftContract = _ref.spgNftContract, txOptions = _ref.txOptions;
              _context4.prev = 1;
              spgNftClient = new SpgnftImplClient(this.rpcClient, this.wallet, spgNftContract);
              _context4.next = 5;
              return spgNftClient.setTokenUri({
                tokenId: BigInt(tokenId),
                tokenUri: tokenURI
              });
            case 5:
              txHash = _context4.sent;
              return _context4.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 9:
              _context4.prev = 9;
              _context4.t0 = _context4["catch"](1);
              handleError(_context4.t0, "Failed to set token URI");
            case 12:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[1, 9]]);
      }));
      function setTokenURI(_x4) {
        return _setTokenURI.apply(this, arguments);
      }
      return setTokenURI;
    }()
    /**
     * Returns the token URI for a specific token id.
     */
    )
  }, {
    key: "getTokenURI",
    value: (function () {
      var _getTokenURI = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref2) {
        var tokenId, spgNftContract, spgNftClient;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              tokenId = _ref2.tokenId, spgNftContract = _ref2.spgNftContract;
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, spgNftContract);
              _context5.next = 4;
              return spgNftClient.tokenUri({
                tokenId: BigInt(tokenId)
              });
            case 4:
              return _context5.abrupt("return", _context5.sent);
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTokenURI(_x5) {
        return _getTokenURI.apply(this, arguments);
      }
      return getTokenURI;
    }())
  }]);
}();

var GroupClient = /*#__PURE__*/function () {
  function GroupClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, GroupClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.groupingWorkflowsClient = new GroupingWorkflowsClient(rpcClient, wallet);
    this.groupingModuleEventClient = new GroupingModuleEventClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.groupingModuleClient = new GroupingModuleClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.royaltyModuleEventClient = new RoyaltyModuleEventClient(rpcClient);
  }
  /** Registers a Group IPA.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
   */
  return _createClass(GroupClient, [{
    key: "registerGroup",
    value: (function () {
      var _registerGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, object, _request$txOptions2, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              object = {
                groupPool: validateAddress(request.groupPool)
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.groupingModuleClient.registerGroupEncode(object)
              });
            case 6:
              _context.next = 8;
              return this.groupingModuleClient.registerGroup(object);
            case 8:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 15;
                break;
              }
              _context.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              txReceipt = _context.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 15:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context.next = 21;
              break;
            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register group");
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 18]]);
      }));
      function registerGroup(_x) {
        return _registerGroup.apply(this, arguments);
      }
      return registerGroup;
    }()
    /** Mint an NFT from a SPGNFT collection, register it with metadata as an IP, attach license terms to the registered IP, and add it to a group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _mintAndRegisterIpAndAttachLicenseAndAddToGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, groupId, recipient, spgNftContract, deadline, isRegistered, ipAccount, _yield$ipAccount$stat, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, sigAddToGroupSignature, object, _request$txOptions4, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              groupId = request.groupId, recipient = request.recipient, spgNftContract = request.spgNftContract, deadline = request.deadline;
              _context2.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(groupId)
              });
            case 4:
              isRegistered = _context2.sent;
              if (isRegistered) {
                _context2.next = 7;
                break;
              }
              throw new Error("Group IP ".concat(groupId, " is not registered."));
            case 7:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, groupId);
              _context2.next = 10;
              return ipAccount.state();
            case 10:
              _yield$ipAccount$stat = _context2.sent;
              state = _yield$ipAccount$stat.result;
              _context2.next = 14;
              return this.rpcClient.getBlock();
            case 14:
              blockTimestamp = _context2.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.next = 18;
              return getPermissionSignature({
                ipId: groupId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: groupId,
                  signer: validateAddress(this.groupingWorkflowsClient.address),
                  to: validateAddress(this.groupingModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 18:
              _yield$getPermissionS = _context2.sent;
              sigAddToGroupSignature = _yield$getPermissionS.signature;
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                allowDuplicates: request.allowDuplicates || true,
                spgNftContract: validateAddress(spgNftContract),
                recipient: validateAddress(recipient || this.wallet.account.address),
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare, RevShareType.MAX_ALLOWED_REWARD_SHARE)),
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigAddToGroup: {
                  signer: validateAddress(this.wallet.account.address),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                }
              });
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 25;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 25:
              _context2.next = 27;
              return this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup(object);
            case 27:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 34;
                break;
              }
              _context2.next = 31;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 31:
              receipt = _context2.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context2.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 34:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 35:
              _context2.next = 40;
              break;
            case 37:
              _context2.prev = 37;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to mint and register IP and attach license and add to group");
            case 40:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 37]]);
      }));
      function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x2) {
        return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register an NFT as IP with metadata, attach license terms to the registered IP, and add it to a group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _registerIpAndAttachLicenseAndAddToGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, _request$txOptions6, ipIdAddress, isRegistered, ipAccount, _yield$ipAccount$stat2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, sigAddToGroupSignature, _yield$getPermissionS3, sigMetadataAndAttachSignature, object, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.ipAssetRegistryClient.ipId({
                chainId: BigInt(chain[this.chainId]),
                tokenContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId)
              });
            case 3:
              ipIdAddress = _context3.sent;
              _context3.next = 6;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.groupId)
              });
            case 6:
              isRegistered = _context3.sent;
              if (isRegistered) {
                _context3.next = 9;
                break;
              }
              throw new Error("Group IP ".concat(request.groupId, " is not registered."));
            case 9:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, request.groupId);
              _context3.next = 12;
              return ipAccount.state();
            case 12:
              _yield$ipAccount$stat2 = _context3.sent;
              state = _yield$ipAccount$stat2.result;
              _context3.next = 16;
              return this.rpcClient.getBlock();
            case 16:
              blockTimestamp = _context3.sent.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, request.deadline);
              _context3.next = 20;
              return getPermissionSignature({
                ipId: request.groupId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: request.groupId,
                  signer: this.groupingWorkflowsClient.address,
                  to: this.groupingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 20:
              _yield$getPermissionS2 = _context3.sent;
              sigAddToGroupSignature = _yield$getPermissionS2.signature;
              _context3.next = 24;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: validateAddress(this.coreMetadataModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: validateAddress(this.licensingModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: this.licensingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 24:
              _yield$getPermissionS3 = _context3.sent;
              sigMetadataAndAttachSignature = _yield$getPermissionS3.signature;
              object = {
                nftContract: request.nftContract,
                groupId: request.groupId,
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                tokenId: BigInt(request.tokenId),
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare, RevShareType.MAX_ALLOWED_REWARD_SHARE)),
                sigAddToGroup: {
                  signer: validateAddress(this.wallet.account.address),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                },
                sigMetadataAndAttachAndConfig: {
                  signer: this.wallet.account.address,
                  deadline: calculatedDeadline,
                  signature: sigMetadataAndAttachSignature
                }
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 29;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 29:
              _context3.next = 31;
              return this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroup(object);
            case 31:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 38;
                break;
              }
              _context3.next = 35;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 35:
              receipt = _context3.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context3.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 38:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 41:
              _context3.prev = 41;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register IP and attach license and add to group");
            case 44:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 41]]);
      }));
      function registerIpAndAttachLicenseAndAddToGroup(_x3) {
        return _registerIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return registerIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register a group IP with a group reward pool and attach license terms to the group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
     */
    )
  }, {
    key: "registerGroupAndAttachLicense",
    value: (function () {
      var _registerGroupAndAttachLicense = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, _request$txOptions8, object, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              object = {
                groupPool: validateAddress(request.groupPool),
                licenseData: this.getLicenseData(request.licenseData)[0]
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseEncode(object)
              });
            case 4:
              _context4.next = 6;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicense(object);
            case 6:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 13;
                break;
              }
              _context4.next = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              txReceipt = _context4.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context4.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 13:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context4.prev = 16;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register group and attach license");
            case 19:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 16]]);
      }));
      function registerGroupAndAttachLicense(_x4) {
        return _registerGroupAndAttachLicense.apply(this, arguments);
      }
      return registerGroupAndAttachLicense;
    }()
    /** Register a group IP with a group reward pool, attach license terms to the group IP, and add individual IPs to the group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
     */
    )
  }, {
    key: "registerGroupAndAttachLicenseAndAddIps",
    value: (function () {
      var _registerGroupAndAttachLicenseAndAddIps = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, _request$txOptions0, object, i, isRegistered, _i, isAttachedLicenseTerms, txHash, txReceipt, groupId;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              object = {
                groupPool: validateAddress(request.groupPool),
                ipIds: request.ipIds,
                licenseData: this.getLicenseData(request.licenseData)[0],
                maxAllowedRewardShare: BigInt(getRevenueShare(request.maxAllowedRewardShare))
              };
              i = 0;
            case 3:
              if (!(i < request.ipIds.length)) {
                _context5.next = 12;
                break;
              }
              _context5.next = 6;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.ipIds[i])
              });
            case 6:
              isRegistered = _context5.sent;
              if (isRegistered) {
                _context5.next = 9;
                break;
              }
              throw new Error("IP ".concat(request.ipIds[i], " is not registered."));
            case 9:
              i++;
              _context5.next = 3;
              break;
            case 12:
              _i = 0;
            case 13:
              if (!(_i < request.ipIds.length)) {
                _context5.next = 22;
                break;
              }
              _context5.next = 16;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipIds[_i],
                licenseTemplate: object.licenseData.licenseTemplate,
                licenseTermsId: object.licenseData.licenseTermsId
              });
            case 16:
              isAttachedLicenseTerms = _context5.sent;
              if (isAttachedLicenseTerms) {
                _context5.next = 19;
                break;
              }
              throw new Error("License terms must be attached to IP ".concat(request.ipIds[_i], " before adding to group."));
            case 19:
              _i++;
              _context5.next = 13;
              break;
            case 22:
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 24;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIpsEncode(object)
              });
            case 24:
              _context5.next = 26;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIps(object);
            case 26:
              txHash = _context5.sent;
              if (!((_request$txOptions0 = request.txOptions) !== null && _request$txOptions0 !== void 0 && _request$txOptions0.waitForTransaction)) {
                _context5.next = 33;
                break;
              }
              _context5.next = 30;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 30:
              txReceipt = _context5.sent;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context5.abrupt("return", {
                txHash: txHash,
                groupId: groupId
              });
            case 33:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 36:
              _context5.prev = 36;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to register group and attach license and add ips");
            case 39:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 36]]);
      }));
      function registerGroupAndAttachLicenseAndAddIps(_x5) {
        return _registerGroupAndAttachLicenseAndAddIps.apply(this, arguments);
      }
      return registerGroupAndAttachLicenseAndAddIps;
    }()
    /**
     * Collect royalties for the entire group and distribute the rewards to each member IP's royalty vault.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L38 | `CollectedRoyaltiesToGroupPool`} event.
     */
    )
  }, {
    key: "collectAndDistributeGroupRoyalties",
    value: (function () {
      var _collectAndDistributeGroupRoyalties = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref) {
        var _this = this;
        var groupIpId, currencyTokens, memberIpIds, txOptions, collectAndClaimParams, isGroupRegistered, txHash, _yield$waitForTxRecei, receipt, collectedRoyalties, royaltiesDistributed;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              groupIpId = _ref.groupIpId, currencyTokens = _ref.currencyTokens, memberIpIds = _ref.memberIpIds, txOptions = _ref.txOptions;
              _context7.prev = 1;
              if (currencyTokens.length) {
                _context7.next = 4;
                break;
              }
              throw new Error("At least one currency token is required.");
            case 4:
              if (memberIpIds.length) {
                _context7.next = 6;
                break;
              }
              throw new Error("At least one member IP ID is required.");
            case 6:
              if (!currencyTokens.some(function (token) {
                return token === zeroAddress;
              })) {
                _context7.next = 8;
                break;
              }
              throw new Error("Currency token cannot be the zero address.");
            case 8:
              collectAndClaimParams = {
                groupIpId: validateAddress(groupIpId),
                currencyTokens: validateAddresses(currencyTokens),
                memberIpIds: validateAddresses(memberIpIds)
              };
              _context7.next = 11;
              return this.ipAssetRegistryClient.isRegistered({
                id: collectAndClaimParams.groupIpId
              });
            case 11:
              isGroupRegistered = _context7.sent;
              if (isGroupRegistered) {
                _context7.next = 14;
                break;
              }
              throw new Error("The group IP with ID ".concat(collectAndClaimParams.groupIpId, " is not registered."));
            case 14:
              _context7.next = 16;
              return Promise.all(collectAndClaimParams.memberIpIds.map(/*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipId) {
                  var isMemberRegistered;
                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return _this.ipAssetRegistryClient.isRegistered({
                          id: ipId
                        });
                      case 2:
                        isMemberRegistered = _context6.sent;
                        if (isMemberRegistered) {
                          _context6.next = 5;
                          break;
                        }
                        throw new Error("Member IP with ID ".concat(ipId, " is not registered ."));
                      case 5:
                      case "end":
                        return _context6.stop();
                    }
                  }, _callee6);
                }));
                return function (_x7) {
                  return _ref2.apply(this, arguments);
                };
              }()));
            case 16:
              _context7.next = 18;
              return this.groupingWorkflowsClient.collectRoyaltiesAndClaimReward(collectAndClaimParams);
            case 18:
              txHash = _context7.sent;
              _context7.next = 21;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 21:
              _yield$waitForTxRecei = _context7.sent;
              receipt = _yield$waitForTxRecei.receipt;
              if (receipt) {
                _context7.next = 25;
                break;
              }
              return _context7.abrupt("return", {
                txHash: txHash
              });
            case 25:
              collectedRoyalties = this.groupingModuleEventClient.parseTxCollectedRoyaltiesToGroupPoolEvent(receipt).map(function (_ref3) {
                var groupId = _ref3.groupId,
                  amount = _ref3.amount,
                  token = _ref3.token;
                return {
                  groupId: groupId,
                  amount: amount,
                  token: token
                };
              });
              royaltiesDistributed = this.royaltyModuleEventClient.parseTxRoyaltyPaidEvent(receipt).map(function (_ref4) {
                var receiverIpId = _ref4.receiverIpId,
                  amount = _ref4.amount,
                  token = _ref4.token,
                  amountAfterFee = _ref4.amountAfterFee;
                return {
                  ipId: receiverIpId,
                  amount: amount,
                  token: token,
                  amountAfterFee: amountAfterFee
                };
              });
              return _context7.abrupt("return", {
                txHash: txHash,
                collectedRoyalties: collectedRoyalties,
                royaltiesDistributed: royaltiesDistributed
              });
            case 30:
              _context7.prev = 30;
              _context7.t0 = _context7["catch"](1);
              handleError(_context7.t0, "Failed to collect and distribute group royalties");
            case 33:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[1, 30]]);
      }));
      function collectAndDistributeGroupRoyalties(_x6) {
        return _collectAndDistributeGroupRoyalties.apply(this, arguments);
      }
      return collectAndDistributeGroupRoyalties;
    }()
    /**
     * Adds IPs to group.
     * The function must be called by the Group IP owner or an authorized operator.
     */
    )
  }, {
    key: "addIpsToGroup",
    value: (function () {
      var _addIpsToGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref5) {
        var groupIpId, ipIds, maxAllowedRewardSharePercentage, txOptions, addIpParam, txHash;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              groupIpId = _ref5.groupIpId, ipIds = _ref5.ipIds, maxAllowedRewardSharePercentage = _ref5.maxAllowedRewardSharePercentage, txOptions = _ref5.txOptions;
              _context8.prev = 1;
              addIpParam = {
                groupIpId: validateAddress(groupIpId),
                ipIds: validateAddresses(ipIds),
                maxAllowedRewardShare: BigInt(getRevenueShare(maxAllowedRewardSharePercentage || 100, RevShareType.MAX_ALLOWED_REWARD_SHARE))
              };
              _context8.next = 5;
              return this.groupingModuleClient.addIp(addIpParam);
            case 5:
              txHash = _context8.sent;
              _context8.next = 8;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 8:
              return _context8.abrupt("return", _context8.sent);
            case 11:
              _context8.prev = 11;
              _context8.t0 = _context8["catch"](1);
              handleError(_context8.t0, "Failed to add IP to group");
            case 14:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[1, 11]]);
      }));
      function addIpsToGroup(_x8) {
        return _addIpsToGroup.apply(this, arguments);
      }
      return addIpsToGroup;
    }()
    /**
     * Returns the available reward for each IP in the group.
     */
    )
  }, {
    key: "getClaimableReward",
    value: (function () {
      var _getClaimableReward = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref6) {
        var groupIpId, currencyToken, memberIpIds, claimableReward;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              groupIpId = _ref6.groupIpId, currencyToken = _ref6.currencyToken, memberIpIds = _ref6.memberIpIds;
              _context9.prev = 1;
              _context9.next = 4;
              return this.groupingModuleClient.getClaimableReward({
                groupId: validateAddress(groupIpId),
                ipIds: validateAddresses(memberIpIds),
                token: validateAddress(currencyToken)
              });
            case 4:
              claimableReward = _context9.sent;
              return _context9.abrupt("return", claimableReward);
            case 8:
              _context9.prev = 8;
              _context9.t0 = _context9["catch"](1);
              handleError(_context9.t0, "Failed to get claimable reward");
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[1, 8]]);
      }));
      function getClaimableReward(_x9) {
        return _getClaimableReward.apply(this, arguments);
      }
      return getClaimableReward;
    }()
    /**
     * Removes IPs from group.
     * The function must be called by the Group IP owner or an authorized operator.
     */
    )
  }, {
    key: "removeIpsFromGroup",
    value: (function () {
      var _removeIpsFromGroup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee0(_ref7) {
        var groupIpId, ipIds, txOptions, removeIpParam, txHash;
        return _regeneratorRuntime().wrap(function _callee0$(_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              groupIpId = _ref7.groupIpId, ipIds = _ref7.ipIds, txOptions = _ref7.txOptions;
              _context0.prev = 1;
              removeIpParam = {
                groupIpId: validateAddress(groupIpId),
                ipIds: validateAddresses(ipIds)
              };
              _context0.next = 5;
              return this.groupingModuleClient.removeIp(removeIpParam);
            case 5:
              txHash = _context0.sent;
              _context0.next = 8;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 8:
              return _context0.abrupt("return", _context0.sent);
            case 11:
              _context0.prev = 11;
              _context0.t0 = _context0["catch"](1);
              handleError(_context0.t0, "Failed to remove IPs from group");
            case 14:
            case "end":
              return _context0.stop();
          }
        }, _callee0, this, [[1, 11]]);
      }));
      function removeIpsFromGroup(_x0) {
        return _removeIpsFromGroup.apply(this, arguments);
      }
      return removeIpsFromGroup;
    }()
    /**
     * Claims reward.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L31 | `ClaimedReward`} event.
     */
    )
  }, {
    key: "claimReward",
    value: (function () {
      var _claimReward = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee1(_ref8) {
        var groupIpId, currencyToken, memberIpIds, txOptions, claimRewardParam, txHash, _yield$waitForTxRecei2, receipt, claimedReward;
        return _regeneratorRuntime().wrap(function _callee1$(_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              groupIpId = _ref8.groupIpId, currencyToken = _ref8.currencyToken, memberIpIds = _ref8.memberIpIds, txOptions = _ref8.txOptions;
              _context1.prev = 1;
              claimRewardParam = {
                groupId: validateAddress(groupIpId),
                ipIds: validateAddresses(memberIpIds),
                token: validateAddress(currencyToken)
              };
              _context1.next = 5;
              return this.groupingModuleClient.claimReward(claimRewardParam);
            case 5:
              txHash = _context1.sent;
              _context1.next = 8;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 8:
              _yield$waitForTxRecei2 = _context1.sent;
              receipt = _yield$waitForTxRecei2.receipt;
              if (receipt) {
                _context1.next = 12;
                break;
              }
              return _context1.abrupt("return", {
                txHash: txHash
              });
            case 12:
              claimedReward = this.groupingModuleEventClient.parseTxClaimedRewardEvent(receipt);
              return _context1.abrupt("return", {
                txHash: txHash,
                claimedReward: claimedReward
              });
            case 16:
              _context1.prev = 16;
              _context1.t0 = _context1["catch"](1);
              handleError(_context1.t0, "Failed to claim reward");
            case 19:
            case "end":
              return _context1.stop();
          }
        }, _callee1, this, [[1, 16]]);
      }));
      function claimReward(_x1) {
        return _claimReward.apply(this, arguments);
      }
      return claimReward;
    }()
    /**
     * Collects royalties into the pool, making them claimable by group member IPs.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L38 | `CollectedRoyaltiesToGroupPool`} event.
     */
    )
  }, {
    key: "collectRoyalties",
    value: (function () {
      var _collectRoyalties = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref9) {
        var groupIpId, currencyToken, txOptions, collectRoyaltiesParam, txHash, _yield$waitForTxRecei3, receipt, collectedRoyalties;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              groupIpId = _ref9.groupIpId, currencyToken = _ref9.currencyToken, txOptions = _ref9.txOptions;
              _context10.prev = 1;
              collectRoyaltiesParam = {
                groupId: validateAddress(groupIpId),
                token: validateAddress(currencyToken)
              };
              _context10.next = 5;
              return this.groupingModuleClient.collectRoyalties(collectRoyaltiesParam);
            case 5:
              txHash = _context10.sent;
              _context10.next = 8;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 8:
              _yield$waitForTxRecei3 = _context10.sent;
              receipt = _yield$waitForTxRecei3.receipt;
              if (receipt) {
                _context10.next = 12;
                break;
              }
              return _context10.abrupt("return", {
                txHash: txHash
              });
            case 12:
              collectedRoyalties = this.groupingModuleEventClient.parseTxCollectedRoyaltiesToGroupPoolEvent(receipt)[0].amount;
              return _context10.abrupt("return", {
                txHash: txHash,
                collectedRoyalties: collectedRoyalties
              });
            case 16:
              _context10.prev = 16;
              _context10.t0 = _context10["catch"](1);
              handleError(_context10.t0, "Failed to collect royalties");
            case 19:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[1, 16]]);
      }));
      function collectRoyalties(_x10) {
        return _collectRoyalties.apply(this, arguments);
      }
      return collectRoyalties;
    }())
  }, {
    key: "getLicenseData",
    value: function getLicenseData(licenseData) {
      var _this2 = this;
      var isArray = Array.isArray(licenseData);
      if (isArray && licenseData.length === 0 || !licenseData) {
        throw new Error("License data is required.");
      }
      var licenseDataArray = isArray ? licenseData : [licenseData];
      return licenseDataArray.map(function (item) {
        return {
          licenseTemplate: validateAddress(item.licenseTemplate || _this2.licenseTemplateClient.address),
          licenseTermsId: BigInt(item.licenseTermsId),
          licensingConfig: validateLicenseConfig(item.licensingConfig)
        };
      });
    }
  }]);
}();

var WipClient = /*#__PURE__*/function () {
  function WipClient(rpcClient, wallet) {
    _classCallCheck(this, WipClient);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet, WIP_TOKEN_ADDRESS);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Wraps the selected amount of IP to WIP.
   * The WIP will be deposited to the wallet that transferred the IP.
   */
  return _createClass(WipClient, [{
    key: "deposit",
    value: (function () {
      var _deposit = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
        var amount, txOptions, _yield$this$rpcClient, call, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              amount = _ref.amount, txOptions = _ref.txOptions;
              _context.prev = 1;
              if (!(amount <= 0)) {
                _context.next = 4;
                break;
              }
              throw new Error("WIP deposit amount must be greater than 0.");
            case 4:
              _context.next = 6;
              return this.rpcClient.simulateContract({
                abi: wrappedIpAbi,
                address: WIP_TOKEN_ADDRESS,
                functionName: "deposit",
                account: this.wallet.account,
                value: BigInt(amount)
              });
            case 6:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 10;
              return this.wallet.writeContract(call);
            case 10:
              txHash = _context.sent;
              return _context.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](1);
              handleError(_context.t0, "Failed to deposit IP for WIP");
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 14]]);
      }));
      function deposit(_x) {
        return _deposit.apply(this, arguments);
      }
      return deposit;
    }()
    /**
     * Unwraps the selected amount of WIP to IP.
     */
    )
  }, {
    key: "withdraw",
    value: (function () {
      var _withdraw = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
        var amount, txOptions, targetAmt, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              amount = _ref2.amount, txOptions = _ref2.txOptions;
              _context2.prev = 1;
              targetAmt = BigInt(amount);
              if (!(targetAmt <= 0)) {
                _context2.next = 5;
                break;
              }
              throw new Error("WIP withdraw amount must be greater than 0.");
            case 5:
              _context2.next = 7;
              return this.wrappedIpClient.withdraw({
                value: targetAmt
              });
            case 7:
              txHash = _context2.sent;
              return _context2.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](1);
              handleError(_context2.t0, "Failed to withdraw WIP");
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 11]]);
      }));
      function withdraw(_x2) {
        return _withdraw.apply(this, arguments);
      }
      return withdraw;
    }()
    /**
     * Approve a spender to use the wallet's WIP balance.
     */
    )
  }, {
    key: "approve",
    value: (function () {
      var _approve = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(req) {
        var amount, spender, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              amount = BigInt(req.amount);
              if (!(amount <= 0)) {
                _context3.next = 4;
                break;
              }
              throw new Error("WIP approve amount must be greater than 0.");
            case 4:
              spender = validateAddress(req.spender);
              _context3.next = 7;
              return this.wrappedIpClient.approve({
                spender: spender,
                amount: amount
              });
            case 7:
              txHash = _context3.sent;
              return _context3.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: req.txOptions,
                rpcClient: this.rpcClient
              }));
            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to approve WIP");
            case 14:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 11]]);
      }));
      function approve(_x3) {
        return _approve.apply(this, arguments);
      }
      return approve;
    }()
    /**
     * Returns the balance of WIP for an address.
     */
    )
  }, {
    key: "balanceOf",
    value: (function () {
      var _balanceOf = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(addr) {
        var owner, ret;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              owner = validateAddress(addr);
              _context4.next = 3;
              return this.wrappedIpClient.balanceOf({
                owner: owner
              });
            case 3:
              ret = _context4.sent;
              return _context4.abrupt("return", ret.result);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function balanceOf(_x4) {
        return _balanceOf.apply(this, arguments);
      }
      return balanceOf;
    }()
    /**
     * Transfers `amount` of WIP to a recipient `to`.
     */
    )
  }, {
    key: "transfer",
    value: (function () {
      var _transfer = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var amount, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              amount = BigInt(request.amount);
              if (!(amount <= 0)) {
                _context5.next = 4;
                break;
              }
              throw new Error("WIP transfer amount must be greater than 0.");
            case 4:
              _context5.next = 6;
              return this.wrappedIpClient.transfer({
                to: validateAddress(request.to),
                amount: amount
              });
            case 6:
              txHash = _context5.sent;
              return _context5.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: request.txOptions,
                rpcClient: this.rpcClient
              }));
            case 10:
              _context5.prev = 10;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to transfer WIP");
            case 13:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 10]]);
      }));
      function transfer(_x5) {
        return _transfer.apply(this, arguments);
      }
      return transfer;
    }()
    /**
     * Transfers `amount` of WIP from `from` to a recipient `to`.
     */
    )
  }, {
    key: "transferFrom",
    value: (function () {
      var _transferFrom = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var amount, txHash;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              amount = BigInt(request.amount);
              if (!(amount <= 0)) {
                _context6.next = 4;
                break;
              }
              throw new Error("WIP transfer amount must be greater than 0.");
            case 4:
              _context6.next = 6;
              return this.wrappedIpClient.transferFrom({
                to: validateAddress(request.to),
                amount: amount,
                from: validateAddress(request.from)
              });
            case 6:
              txHash = _context6.sent;
              return _context6.abrupt("return", waitForTxReceipt({
                txHash: txHash,
                txOptions: request.txOptions,
                rpcClient: this.rpcClient
              }));
            case 10:
              _context6.prev = 10;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to transfer WIP");
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 10]]);
      }));
      function transferFrom(_x6) {
        return _transferFrom.apply(this, arguments);
      }
      return transferFrom;
    }())
  }]);
}();

if (typeof process !== "undefined") {
  dotenv.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    _defineProperty(this, "_royalty", null);
    _defineProperty(this, "_nftClient", null);
    _defineProperty(this, "_group", null);
    _defineProperty(this, "_wip", null);
    this.config = _objectSpread2(_objectSpread2({}, config), {}, {
      chainId: chain[config.chainId || "1315"]
    });
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.chainId),
      transport: this.config.transport
    };
    this.rpcClient = createPublicClient(clientConfig);
    if (this.config.wallet) {
      this.wallet = this.config.wallet;
    } else if (this.config.account) {
      var account = this.config.account;
      this.wallet = createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
        account: account
      }));
    } else {
      throw new Error("must specify a wallet or account");
    }
  }
  return _createClass(StoryClient, [{
    key: "chainId",
    get: function get() {
      return this.config.chainId;
    }
    /**
     * Factory method for creating an SDK client with a signer.
     *
     */
  }, {
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._license;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._ipAccount;
    }

    /**
     * Getter for the royalty client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "royalty",
    get: function get() {
      if (this._royalty === null) {
        this._royalty = new RoyaltyClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._royalty;
    }

    /**
     * Getter for the NFT client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "nftClient",
    get: function get() {
      if (this._nftClient === null) {
        this._nftClient = new NftClient(this.rpcClient, this.wallet);
      }
      return this._nftClient;
    }

    /**
     * Getter for the group client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "groupClient",
    get: function get() {
      if (this._group === null) {
        this._group = new GroupClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._group;
    }
  }, {
    key: "wipClient",
    get: function get() {
      if (this._wip === null) {
        this._wip = new WipClient(this.rpcClient, this.wallet);
      }
      return this._wip;
    }
  }, {
    key: "getWalletBalance",
    value: function () {
      var _getWalletBalance = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.wallet.account) {
                _context.next = 2;
                break;
              }
              throw new Error("No account found in wallet");
            case 2:
              _context.next = 4;
              return this.getBalance(this.wallet.account.address);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getWalletBalance() {
        return _getWalletBalance.apply(this, arguments);
      }
      return getWalletBalance;
    }()
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {
        var validAddress;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              validAddress = validateAddress(address);
              _context2.next = 3;
              return this.rpcClient.getBalance({
                address: validAddress
              });
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getBalance(_x) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }

    /**
     * Factory method for creating an SDK client with a signer.
     */
  }, {
    key: "newClientUseWallet",
    value: function newClientUseWallet(config) {
      return new StoryClient({
        chainId: config.chainId,
        transport: config.transport,
        wallet: config.wallet
      });
    }

    /**
     * Factory method for creating an SDK client with a signer.
     */
  }, {
    key: "newClientUseAccount",
    value: function newClientUseAccount(config) {
      return new StoryClient({
        account: config.account,
        chainId: config.chainId,
        transport: config.transport
      });
    }
  }]);
}();

/**
 * IPA Metadata Standard Parameters
 *
 * This is the metadata that is associated with an IP Asset,
 * and gets stored inside of an IP Account.
 *
 * @see {@link https://docs.story.foundation/docs/ipa-metadata-standard|IPA Metadata Standard Docs}
 */

/**
 * Experimental ip metadata fields that are not required but may be
 * considered for future use.
 */

/**
 * Enum representing the various relationship types in a story narrative.
 */
var StoryRelationship = /*#__PURE__*/function (StoryRelationship) {
  /** A character appears in a chapter. */
  StoryRelationship["APPEARS_IN"] = "APPEARS_IN";
  /** A chapter belongs to a book. */
  StoryRelationship["BELONGS_TO"] = "BELONGS_TO";
  /** A book is part of a series. */
  StoryRelationship["PART_OF"] = "PART_OF";
  /** A chapter continues from the previous one. */
  StoryRelationship["CONTINUES_FROM"] = "CONTINUES_FROM";
  /** An event leads to a consequence. */
  StoryRelationship["LEADS_TO"] = "LEADS_TO";
  /** An event foreshadows future developments. */
  StoryRelationship["FORESHADOWS"] = "FORESHADOWS";
  /** A character conflicts with another character. */
  StoryRelationship["CONFLICTS_WITH"] = "CONFLICTS_WITH";
  /** A decision results in a significant change. */
  StoryRelationship["RESULTS_IN"] = "RESULTS_IN";
  /** A subplot depends on the main plot. */
  StoryRelationship["DEPENDS_ON"] = "DEPENDS_ON";
  /** A prologue sets up the story. */
  StoryRelationship["SETS_UP"] = "SETS_UP";
  /** A chapter follows from the previous one. */
  StoryRelationship["FOLLOWS_FROM"] = "FOLLOWS_FROM";
  /** A twist reveals that something unexpected occurred. */
  StoryRelationship["REVEALS_THAT"] = "REVEALS_THAT";
  /** A character develops over the course of the story. */
  StoryRelationship["DEVELOPS_OVER"] = "DEVELOPS_OVER";
  /** A chapter introduces a new character or element. */
  StoryRelationship["INTRODUCES"] = "INTRODUCES";
  /** A conflict resolves in a particular outcome. */
  StoryRelationship["RESOLVES_IN"] = "RESOLVES_IN";
  /** A theme connects to the main narrative. */
  StoryRelationship["CONNECTS_TO"] = "CONNECTS_TO";
  /** A subplot relates to the central theme. */
  StoryRelationship["RELATES_TO"] = "RELATES_TO";
  /** A scene transitions from one setting to another. */
  StoryRelationship["TRANSITIONS_FROM"] = "TRANSITIONS_FROM";
  /** A character interacted with another character. */
  StoryRelationship["INTERACTED_WITH"] = "INTERACTED_WITH";
  /** An event leads into the climax. */
  StoryRelationship["LEADS_INTO"] = "LEADS_INTO";
  /** Story happening in parallel or around the same timeframe. */
  StoryRelationship["PARALLEL"] = "PARALLEL";
  return StoryRelationship;
}({});

/**
 * Enum representing the different relationship types for AI-related metadata.
 */
var AIRelationship = /*#__PURE__*/function (AIRelationship) {
  /** A model is trained on a dataset. */
  AIRelationship["TRAINED_ON"] = "TRAINED_ON";
  /** A model is finetuned from a base model. */
  AIRelationship["FINETUNED_FROM"] = "FINETUNED_FROM";
  /** An image is generated from a fine-tuned model. */
  AIRelationship["GENERATED_FROM"] = "GENERATED_FROM";
  /** A model requires data for training. */
  AIRelationship["REQUIRES_DATA"] = "REQUIRES_DATA";
  /** A remix is based on a specific workflow. */
  AIRelationship["BASED_ON"] = "BASED_ON";
  /** Sample data influences model output. */
  AIRelationship["INFLUENCES"] = "INFLUENCES";
  /** A pipeline creates a fine-tuned model. */
  AIRelationship["CREATES"] = "CREATES";
  /** A workflow utilizes a base model. */
  AIRelationship["UTILIZES"] = "UTILIZES";
  /** A fine-tuned model is derived from a base model. */
  AIRelationship["DERIVED_FROM"] = "DERIVED_FROM";
  /** A model produces generated images. */
  AIRelationship["PRODUCES"] = "PRODUCES";
  /** A remix modifies the base workflow. */
  AIRelationship["MODIFIES"] = "MODIFIES";
  /** An AI-generated image references original data. */
  AIRelationship["REFERENCES"] = "REFERENCES";
  /** A model is optimized by specific algorithms. */
  AIRelationship["OPTIMIZED_BY"] = "OPTIMIZED_BY";
  /** A fine-tuned model inherits features from the base model. */
  AIRelationship["INHERITS"] = "INHERITS";
  /** A fine-tuning process applies to a model. */
  AIRelationship["APPLIES_TO"] = "APPLIES_TO";
  /** A remix combines elements from multiple datasets. */
  AIRelationship["COMBINES"] = "COMBINES";
  /** A model generates variants of an image. */
  AIRelationship["GENERATES_VARIANTS"] = "GENERATES_VARIANTS";
  /** A fine-tuning process expands on base capabilities. */
  AIRelationship["EXPANDS_ON"] = "EXPANDS_ON";
  /** A workflow configures a models parameters. */
  AIRelationship["CONFIGURES"] = "CONFIGURES";
  /** A fine-tuned model adapts to new data. */
  AIRelationship["ADAPTS_TO"] = "ADAPTS_TO";
  return AIRelationship;
}({});

export { AIRelationship, AccessPermission, DisputeClient, GroupClient, IPAccountClient, IPAssetClient, LicenseClient, NativeRoyaltyPolicy, NftClient, PIL_TYPE, PermissionClient, RevShareType, RoyaltyClient, StoryClient, StoryRelationship, WIP_TOKEN_ADDRESS, WipClient, aeneid, convertCIDtoHashIPFS, convertHashIPFStoCID, getPermissionSignature, getSignature, mainnet, royaltyPolicyLapAddress, royaltyPolicyLrpAddress };
