import EventEmitter from 'eventemitter3';
import { JsonRpcProvider } from '@walletconnect/jsonrpc-provider';
import { RequestArguments } from '@walletconnect/jsonrpc-utils';
import { Chain } from 'viem';
import { SendOptions, PublicKey, Transaction, Connection, TransactionSignature, VersionedTransaction } from '@solana/web3.js';
import { SuiSignTransactionMethod, SuiSignAndExecuteTransactionMethod } from '@mysten/wallet-standard';
import TonWeb from 'tonweb';
import { WalletV4ContractR2 } from 'tonweb/dist/types/contract/wallet/v4/wallet-v4-contract-r2';
import { TronWeb, Types } from 'tronweb';
import { AnyRawTransaction, PublicKey as PublicKey$1 } from '@aptos-labs/ts-sdk';
import { WebWalletSDKType, WebWalletInvokeType } from '@tomo-inc/shared-type';
import { AptosSignTransactionMethod, AptosSignMessageMethod, AptosSignAndSubmitTransactionMethod, AptosConnectMethod } from '@aptos-labs/wallet-standard';

type Network = "mainnet" | "testnet" | "signet";
declare enum AddressType {
    P2PKH = 0,
    P2WPKH = 1,
    P2TR = 2,
    P2SH_P2WPKH = 3,
    M44_P2WPKH = 4,
    M44_P2TR = 5
}
interface AddressInfo {
    value: AddressType;
    label: string;
    name: string;
    displayName?: string;
    hdPath: string;
    address?: string;
}

declare class BitcoinProvider {
    network: Network;
    event: EventEmitter<string | symbol, any>;
    addressType: string;
    address: string;
    pubKey: string;
    core: TomoSDK;
    setCore(core: TomoSDK): void;
    getAccounts(): Promise<string[]>;
    getAddress(): Promise<string>;
    getPublicKey(): Promise<string>;
    getPublicKeyHex(): Promise<string>;
    getAllAddresses(): Promise<AddressInfo[]>;
    sendBitcoin(to: string, satAmount: number, feeRate: number): Promise<string>;
    signPsbt(psbtHex: string): Promise<string>;
    signPsbts(psbtHexs: string[]): Promise<string[]>;
    private signMessageBIP322;
    private signMessageEcdsa;
    signMessage(message: string, _type?: "ecdsa" | "bip322-simple"): Promise<string>;
    getNetwork(): Network;
    getAddressType(): string;
    switchNetwork(network: Network): Promise<void>;
    changeAddressType(addressType: string): Promise<void>;
    on(eventName: string, callBack: (e: any) => void): void;
    off(eventName: string, callBack: (e: any) => void): void;
    getBalance(address?: string): Promise<number>;
    getFeeRate(): Promise<any>;
    pushTx(txHex: string): Promise<string>;
    getInscriptionData(address: string, network?: Network): Promise<any>;
    getInscriptionInfo(insId: string, network?: Network): Promise<any>;
}

declare class SuiProvider {
    address: string;
    core: TomoSDK;
    constructor();
    getAddress(): Promise<string>;
    setCore(core: TomoSDK): void;
    signTransaction: SuiSignTransactionMethod;
    signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod;
    signMessage(_input: any): Promise<string | {
        bytes: string;
        signature: string;
    }>;
    signPersonalMessage(_input: {
        message: Uint8Array;
    }): Promise<string | {
        bytes: string;
        signature: string;
    }>;
}

type TonSigningTransactionType = {
    amount: string;
    toAddress: string;
    memo?: string;
    tokenContractAddress?: string;
    tokenPrecision?: number;
};
declare class TonProvider {
    address: string;
    publicKey: string;
    walletClass: WalletV4ContractR2;
    connection: any;
    core: TomoSDK;
    tonWebPromise: Promise<TonWeb>;
    constructor();
    getTonWeb(): Promise<TonWeb>;
    getAddress(): Promise<string>;
    setCore(core: TomoSDK): void;
    getBalance(address?: string): Promise<string>;
    sendTransaction(transactionInfo: TonSigningTransactionType): Promise<any>;
    private sendBoc;
}

declare class TronProvider {
    address: string | null;
    tronWeb: TronWeb;
    tronWebPromise: Promise<TronWeb>;
    core: TomoSDK;
    constructor();
    setCore(sdk: TomoSDK): void;
    getAddress(): Promise<string>;
    signMessage(message: string, privateKey?: string): Promise<string>;
    signTransaction(transaction: Types.Transaction): Promise<Types.SignedTransaction>;
}

type LoginType = "google" | "twitter" | "kakao" | "telegram";
type LinkSocialType = "google" | "twitter" | "telegram";
declare enum LoginAction {
    Login = "login",
    Link = "link"
}
interface LoginOptions {
    action?: LoginAction;
}
interface ChainConfig {
    chainId: number;
    rpcUrl?: string;
    chainList?: Chain[];
}
interface Config {
    connect?: string;
    relayBase?: string;
    clientId: string;
    ethereumProvider?: EthereumProvider;
    bitcoinProvider?: BitcoinProvider;
    solanaProvider?: any;
    tonProvider?: TonProvider;
    suiProvider?: SuiProvider;
    tronProvider?: TronProvider;
    walletDomain?: string;
}
interface UserSocialInfo {
    twitterBound: boolean;
    googleBound: boolean;
    appleBound: boolean;
    emailBound: boolean;
    username: string;
    email?: string;
    twitterHandle?: string;
    recoveryEmail?: string;
    tradePasswordBound?: boolean;
}
interface EvmTxParams {
    from: string;
    to: string;
    value: string;
    gasPrice?: string;
    gasLimit?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    data?: string;
}
interface SwapTxParams {
    from: string;
    to: string;
    value: string;
    gasPrice?: string;
    gasLimit?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    data?: string;
    fromToken?: any;
    toToken?: any;
    estFee?: string;
    estTime?: string;
    receive?: string;
    instructions?: any;
    signatures?: any;
}
interface EvmSendTransactionParam {
    txParams: EvmTxParams;
    chainId: number;
    rpcUrl: string;
}
interface SolSendTransactionParam {
    to?: string;
    value?: string;
    type?: "sign" | "send";
    mintAddress?: string;
    transaction?: string;
    transactions?: string[];
    options?: SendOptions;
}
interface BitcoinTxParam {
    from?: string;
    to?: string;
    amount?: number;
    psbtHex?: string;
    feeRate?: number;
    fromAddress?: string;
    pubKey?: string;
    psbtHexs?: string[];
}
interface BitcoinSendTransactionParam {
    txParams: BitcoinTxParam;
    address: string;
    addressType: string;
    network: string;
}
interface MovementSendTransactionParam {
    txParams: MovementTxParam;
    address: string;
    addressType: string;
    network: string;
}
interface MovementTxParam {
    type: "sign" | "send";
    transaction: {
        transaction: AnyRawTransaction;
        asFeePayer?: boolean;
    };
}
type ChainType = "bitcoin" | "evm" | "solana" | "tron" | "movement" | "sui";
type reqType = "signTx" | "signMessage";
type MfaReqType = "passkey";
interface Request {
    eventId: string;
    chainType?: string;
    origin: string;
    accessToken: string;
}
interface SignTxRequest extends Request {
    reqType: string;
    loginType?: string;
    txMeta: SolSendTransactionParam | EvmSendTransactionParam | BitcoinSendTransactionParam | MovementSendTransactionParam;
}
interface SignMessageRequest extends Request {
    reqType: string;
    loginType?: string;
    signInfo: {
        message: string;
        address?: string;
        addressType?: string;
    };
}
interface NormalRequest extends Request {
    reqType: string;
    loginType?: string;
}
type MfaRequest = NormalRequest;
type Theme = {
    projectId: number;
    projectName: string;
    style: string;
    color: string;
    cornerRadius: string;
    logo: string;
    termsUrl: string;
    privacyUrl: string;
};
type LoginMethod = {
    createdTime: string;
    id: number;
    projectId: number;
    loginMethodId: string;
    loginMethodName: string;
    enabled: boolean;
    type: string;
    priority: number;
};
type ChainStatus = {
    chainId: string;
    chainName: string;
    description: string;
    enabled: boolean;
};
type Customization = {
    theme: Theme;
    loginMethods: LoginMethod[];
    chainStatuses: {
        chainStatus: ChainStatus[];
    };
};
type TronSendResult = {
    result: boolean;
    txID: string;
    transaction: any;
};

interface WalletRequestParams {
    sdkType?: WebWalletSDKType;
    options?: {
        [key: string]: any;
    };
}

declare class EthereumProvider extends EventEmitter {
    jsonRpcProvider: JsonRpcProvider;
    chainConfig: ChainConfig;
    core: TomoSDK;
    chainList: Chain[];
    chainListFromCDN: {
        name: string;
        id: number;
        rpcUrl: string;
    }[];
    instanceId: string;
    initialPromise: Promise<void>;
    connectUrl: string;
    constructor(params?: {
        connectUrl?: string;
    });
    private initial;
    private getChainConfig;
    private getChainListFromCDN;
    private getChain;
    connect(): Promise<void>;
    request<Result = any, Params = any>(request: RequestArguments<Params>, context?: any): Promise<Result>;
    get chainIdDecimal(): number;
    get chainIdHex(): string;
    processWalletAction<Params = any>(request: RequestArguments<Params>): Promise<any>;
    sendAsync(payload: any, callback: (error: Error | null, result?: any) => void): void;
    getChainId(): Promise<number>;
    setCore(core: any): void;
    switchChain(chainId: string): Promise<void>;
    setChainConfig(chainConfig: ChainConfig): Promise<void>;
    getAddresses(): Promise<any[]>;
    requestAddresses(): Promise<any[]>;
    signMessage(msg: string, address: string): Promise<unknown>;
    signTypedData(address: string, msg: string): Promise<unknown>;
    sendTransaction(params: EvmTxParams): Promise<unknown>;
    recoverMessageAddress(message: string, signature: string): Promise<`0x${string}`>;
    sendRawTransaction(): Promise<void>;
}

type SignedTransaction = string;
declare class SolanaProvider {
    publicKey: PublicKey;
    connected: boolean;
    isConnected: boolean;
    connection: any;
    endpoint: string;
    core: TomoSDK;
    constructor(endpoint?: string);
    getPublicKey(): Promise<string>;
    getAddress(): Promise<string>;
    getBalance(): Promise<any>;
    setCore(core: TomoSDK): void;
    signTransaction<T extends Transaction>(transaction: T): Promise<SignedTransaction>;
    sendTransaction<T extends Transaction>(transaction: T, connection?: Connection): Promise<TransactionSignature>;
    signMessage(message: Uint8Array): Promise<Uint8Array>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    getTransactionHex(transaction: Transaction | VersionedTransaction, connection?: Connection): Promise<string>;
}

declare class MovementProvider {
    address: string | null;
    publicKey: PublicKey$1;
    connected: boolean;
    isConnected: boolean;
    connection: any;
    core: TomoSDK;
    chainId: number;
    constructor();
    setCore(core: TomoSDK): void;
    signTransaction: AptosSignTransactionMethod;
    signMessage: AptosSignMessageMethod;
    signAndSubmitTransaction: AptosSignAndSubmitTransactionMethod;
    getAddress: () => Promise<string>;
    switchChain: (chainId: number) => Promise<void>;
    connect: AptosConnectMethod;
    disconnect: () => Promise<void>;
}

declare const BASE_TEST_URL = "https://fans-tech-backend.tomo.services/api/";
declare const BASE_PROD_URL = "https://apps-prod.tomo.inc/api/";
declare function setHeaders(headers: {
    [key: string]: string;
}): void;

declare function getConnection(): any;
declare function createSolTx(fromAddress: string, toAddress: string, amount: number, mintAddress?: string): Promise<Transaction>;
/**
 * Parses a Solana transaction and extracts relevant information.
 *
 * @param transaction The Solana transaction to parse.
 * @returns An object containing the transaction's from address, to address, amount, and mint address (if applicable).
 */
declare function parseSolTx(transaction: Transaction): Promise<{
    from: string;
    to: string;
    value: number;
    mintAddress?: string;
}>;

declare const BASE_RELAY_TEST_URL = "https://social-relay-dev.tomo.inc";
declare const BASE_RELAY_PROD_URL = "https://social-relay.tomo.inc";

declare class TomoSDK {
    connectUrl: string;
    relayBase: string;
    events: EventEmitter<string | symbol, any>;
    clientId: string;
    chainConfig: ChainConfig;
    ethereumProvider: EthereumProvider;
    bitcoinProvider: BitcoinProvider;
    solanaProvider: SolanaProvider;
    tronProvider: TronProvider;
    movementProvider: MovementProvider;
    suiProvider: SuiProvider;
    googleAuthEventId: string;
    kakaoAuthEventId: string;
    telegramAuthEventId: string;
    walletDomain: string;
    constructor({ clientId, connect, relayBase, ethereumProvider, walletDomain }: Config);
    _initialize(): void;
    msgProcessor({ origin, data: { type, data, action } }: {
        origin: any;
        data: {
            type: any;
            data: any;
            action: any;
        };
    }): void;
    login(type: LoginType, options?: LoginOptions): Promise<any>;
    linkSocial(type: LinkSocialType): Promise<any>;
    getLinkSocialInfo(): Promise<any>;
    loginByGoogle(code: string): Promise<boolean>;
    linkGoogle(code: string): Promise<boolean>;
    loginByKakao(code: string): Promise<boolean>;
    loginByTelegram(authData: any): Promise<boolean>;
    linkTelegram(authData: any): Promise<boolean>;
    loginByTwitter(code: string): Promise<boolean>;
    linkTwitter(code: string): Promise<boolean>;
    sendCode(email: string): Promise<boolean>;
    verifyCode(code: string): Promise<boolean>;
    handleLoginByEmailSuccess(token: string): void;
    getEthAddress(): Promise<any>;
    getPrices(tokenSymbols: string): Promise<any>;
    logout(): Promise<void>;
    tradePaswordStatus(): Promise<boolean>;
    requestAccounts(chainType?: string): Promise<string | boolean>;
    verifyLoginEmail(email: string): Promise<string | boolean>;
    setPayPinAndEmail(): Promise<string | boolean>;
    setPayPin(): Promise<string | boolean>;
    changePayPin(): Promise<string | boolean>;
    bindEmail(): Promise<string | boolean>;
    addRecoveryEmail(type?: string): Promise<string | boolean>;
    hasEmail(): Promise<boolean>;
    bindEmailCode(email: string): Promise<boolean>;
    bindEmailCodeVerify(email: string, code: any): Promise<boolean>;
    getDefaultTokens(): Promise<any>;
    getDashboardTokens(clientId: string, chainId: string): Promise<any>;
    searchToken(content: string): Promise<any>;
    getHoldEvmTokens(address: string): Promise<any>;
    getHoldSolTokens(address: string): Promise<any>;
    getUserWalletTokens(address: string): Promise<any>;
    userWalletTokensUpdate(tokens: string[]): Promise<any>;
    userWalletTokenAdd(token: string, walletAddress: string): Promise<any>;
    userWalletTokenRemove(token: string, walletAddress: string): Promise<any>;
    createPasskey(): Promise<boolean>;
    getPasskeyStatus(): Promise<{
        localCreated: boolean;
        remoteExised: boolean;
    }>;
    getJwtToken(): Promise<string | null>;
    getUserSocialInfo(): Promise<UserSocialInfo>;
    getSwapTokens(chain: string): Promise<any>;
    getCustomization(): Promise<Customization>;
    static getCustomization(clientId: string): Promise<Customization>;
    onboarding(params?: WalletRequestParams): Promise<string | boolean>;
    openSwap(params?: WalletRequestParams): Promise<string | boolean>;
    openChangePayPin(params?: WalletRequestParams): Promise<string | boolean>;
    openOnramp(params?: WalletRequestParams): Promise<string | boolean>;
    openSend(params?: WalletRequestParams): Promise<string | boolean>;
    openReceive(params?: WalletRequestParams): Promise<string | boolean>;
    closeAllRelayWindow(): void;
    handleWebWalletInvoke: (type: WebWalletInvokeType, params?: WalletRequestParams) => Promise<void>;
}

export { BASE_PROD_URL, BASE_RELAY_PROD_URL, BASE_RELAY_TEST_URL, BASE_TEST_URL, BitcoinProvider, EthereumProvider, LoginAction, MovementProvider, SolanaProvider, SuiProvider, TomoSDK, TronProvider, createSolTx, getConnection as getSolConnection, parseSolTx, setHeaders };
export type { BitcoinSendTransactionParam, BitcoinTxParam, ChainConfig, ChainType, Config, Customization, EvmSendTransactionParam, EvmTxParams, LinkSocialType, LoginOptions, LoginType, MfaReqType, MfaRequest, MovementSendTransactionParam, Network, NormalRequest, Request, SignMessageRequest, SignTxRequest, SolSendTransactionParam, SwapTxParams, TronSendResult, UserSocialInfo, WalletRequestParams, reqType };
